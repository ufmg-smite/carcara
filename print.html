<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Carcara Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Carcara Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ufmg-smite/carcara" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Carcara is an independent proof checker and elaborator for SMT proofs in the <a href="https://verit.gitlabpages.uliege.be/alethe/specification.pdf">Alethe
format</a>, with a focus on performance
and usability. It can efficiently check Alethe proofs even in the presence of coarse-grained steps,
and reports detailed error messages in the case that the proof is invalid. Besides checking, Carcara
is capable of <em>elaborating</em> proofs, by adding ommited detail and breaking down hard-to-check steps
into multiple simpler steps.</p>
<p>This project was developed in the SMITE research group, at Universidade Federal de
Minas Gerais (UFMG). A research paper describing Carcara has been <a href="https://link.springer.com/chapter/10.1007/978-3-031-30823-9_19">published at TACAS
2023</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The Carcara source code and documentation are released under the <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License, version
2.0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h2>
<p>To build Carcara from source, you will first need to install Rust and Cargo. Currently, Carcara
requires at least Rust version 1.87. Once you have installed an appropriate version of Rust, you can
download and install the latest version of Carcara by running the following command:</p>
<pre><code>cargo install --git https://github.com/ufmg-smite/carcara.git
</code></pre>
<p>This will build the project and place the <code>carcara</code> binary in Cargo's binary directory
(<code>~/.cargo/bin</code> by default).</p>
<p>You can uninstall Carcara by running <code>cargo uninstall carcara-cli</code>.</p>
<h2 id="pre-built-binary"><a class="header" href="#pre-built-binary">Pre-built binary</a></h2>
<p>Alternatively, a pre-compiled executable for the <code>x86_64-unknown-linux-gnu</code> platform can be
downloaded from the <a href="https://github.com/ufmg-smite/carcara/releases">GitHub releases page</a>. To use
Carcara in other platforms or operating systems, or to use a more recent version of Carcara, we
recommend building from source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking-proofs-with-carcara"><a class="header" href="#checking-proofs-with-carcara">Checking proofs with Carcara</a></h1>
<p>To check a proof file with Carcara, use the <code>check</code> command, passing both the proof file and the
original SMT-LIB problem file:</p>
<pre><code>carcara check example.smt2.alethe example.smt2
</code></pre>
<p>If the problem filename is exactly the proof filename minus <code>.alethe</code>, you can omit it, and Carcara
will infer it:</p>
<pre><code>carcara check example.smt2.alethe
</code></pre>
<p>When checking a proof, Carcara will report one of three outcomes:</p>
<ul>
<li><code>valid</code>: The proof was fully checked, and no errors were found.</li>
<li><code>invalid</code>: An error was found in part of the proof; an error message will have been printed.</li>
<li><code>holey</code>: No errors were found, but the proof contained one or more "holes". These can be either
explicit applications of the <code>hole</code> rule, or steps that use an unknown or unsupported rule.</li>
</ul>
<p>See <code>carcara check --help</code> for a full list of options.</p>
<h2 id="dealing-with-unknown-rules"><a class="header" href="#dealing-with-unknown-rules">Dealing with unknown rules</a></h2>
<p>By default, Carcara will return a checking error when encountering a rule it does not recognize.
If instead you want to ignore such rules, you can use the <code>--ignore-unknown-rules</code>/<code>-i</code> flag.
Alternatively, you can use the <code>--allowed-rules</code> option to pass a specific list of unkown rules to
allow. For example:</p>
<pre><code>carcara check example.smt2.alethe --allowed-rules foo bar
</code></pre>
<p>If a proof uses a rule that is allowed by either <code>--ignore-unknown-rules</code> or <code>--allowed-rules</code>, it
will be considered <code>holey</code>.</p>
<h2 id="the-lia_generic-rule"><a class="header" href="#the-lia_generic-rule">The <code>lia_generic</code> rule</a></h2>
<p>Carcara does not check steps that use the <code>lia_generic</code> rule. This is an extremely coarse-grained
rule from the Alethe format, and is in general NP-hard to check. If you need to validate proofs
that contain this rule, you can use Carcara's proof elaboration to call an external tool that can
elaborate these steps into a series of easier-to-check steps. For more details, see <a href="elaboration.html">the proof
elaboration chapter</a>.</p>
<h2 id="parallel-checking"><a class="header" href="#parallel-checking">Parallel checking</a></h2>
<p>Using the <code>--num-threads</code>/<code>-u</code> option, you can control how many concurrent threads Carcara will use
to check the proof. If the given value is greater than 1, Carcara will split the proof steps among
that many worker threads, and check them in parallel. Note that proof parsing, which is oftentimes a
bottleneck in Carcara, will still be sequential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking-rare-rules"><a class="header" href="#checking-rare-rules">Checking Rare Rules</a></h1>
<p>SMT solvers can produce proofs that may depend on rare rules. In general, rare rules have the following format:</p>
<pre><code>(declare-rare-rule bool-implies-de-morgan ((x1 Bool) (y1 Bool))
  :args (x1 y1)
  :conclusion (= (not (=&gt; x1 y1)) (and x1 (not y1)))
)
</code></pre>
<p>First, we have a set of arguments and a conclusion. We can substitute the arguments into the conclusion. The substitution can be any first-order term available in the Alethe context.</p>
<pre><code>(step st191.t1 
  (cl (= (not (=&gt; (not (member$ ?v0 ?v1)) (= ?v0 ?v2)))
         (and (not (member$ ?v0 ?v1)) (not (= ?v0 ?v2)))))
  :rule rare_rewrite
  :args ("bool-implies-de-morgan" (not (member$ ?v0 ?v1)) (= ?v0 ?v2)))
</code></pre>
<p>Arguments can also be polymorphic:</p>
<pre><code class="language-lisp">(declare-rare-rule eq-refl ((@T0 Type) (t1 @T0))
  :args (t1)
  :premises ()
  :conclusion (= (= t1 t1) true))
</code></pre>
<p>We use <code>@Type</code> to denote an argument that is a polymorphic type. Polymorphic arguments are not passed in the <code>:args</code> field of the step statement:</p>
<pre><code class="language-lisp">(step t264
  (cl (= (= (op e3 e3) (op e3 e3)) true))
  :rule rare_rewrite
  :args ("eq-refl" (op e3 e3)))
</code></pre>
<h1 id="flags"><a class="header" href="#flags">Flags</a></h1>
<p>We use the <code>--rare-file</code> flag to pass the rare file, for example:</p>
<pre><code class="language-bash">carcara check your_file.smt2.alethe your_file.smt2 --rare-file your_rare_file.rare
</code></pre>
<p>Note that Carcara will only be able to check your proofs if every rewrite rule mentioned in the Alethe file is also present in your rare file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-elaboration"><a class="header" href="#proof-elaboration">Proof elaboration</a></h1>
<p>Besides checking a proof, Carcara is also capable of <em>proof elaboration</em>. You can elaborate a proof
file using the <code>elaborate</code> command:</p>
<pre><code>carcara elaborate example.smt2.alethe example.smt2
</code></pre>
<p>This will check and elaborate the given proof, and print the elaborated proof to the standard
output. By default, Carcara will print proofs using term sharing, i.e., using the <code>(! ... :named ...)</code> syntax. You can change this behavior with the <code>--no-print-with-sharing</code>/<code>-v</code> option.</p>
<p>Many of the same options used in the <code>check</code> command also apply to the <code>elaborate</code> command. See
<code>carcara elaborate --help</code> for more details.</p>
<h2 id="elaboration-pipeline"><a class="header" href="#elaboration-pipeline">Elaboration pipeline</a></h2>
<p>The specific elaboration applied to the proof is controlled via a <code>--pipeline</code> option. This takes a
series of elaboration steps, and will apply them in the given order. The possible elaboration steps
are:</p>
<ul>
<li><a href=""><code>polyeq</code></a></li>
<li><a href=""><code>lia-generic</code></a></li>
<li><a href=""><code>local</code></a></li>
<li><a href=""><code>uncrowd</code></a></li>
<li><a href=""><code>reordering</code></a></li>
<li><a href=""><code>hole</code></a></li>
</ul>
<p>By default, Carcara will attempt to apply all of these in the listed order.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The following command will elaborate the given proof file with the <code>uncrowd</code> and <code>polyeq</code>
elaboration steps, in that order:</p>
<pre><code>carcara elaborate example.smt2.alethe --pipeline uncrowd polyeq
</code></pre>
<p>Note that, if you pass a positional argument (e.g. the proof filename) after the pipeline argument,
you need an extra <code>--</code> argument to denote the end of the pipeline list:</p>
<pre><code>carcara elaborate --pipeline uncrowd polyeq -- example.smt2.alethe
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polyequality-elaboration"><a class="header" href="#polyequality-elaboration">Polyequality elaboration</a></h1>
<p>In Alethe, we call "polyequality" the notion of equivalence between terms modulo the reordering
of equalities. For example, we say that the terms <code>(or (= a b) c)</code> and <code>(or (= b a) c)</code> are
"polyequal", despite the equality term being flipped.</p>
<p>When checking an Alethe proof, a checker often needs to reason modulo polyequality. The <code>refl</code>
rule, for example, allows the two terms to be syntactically different, if they are equivalent by
polyequality. The following step is valid:</p>
<pre><code>(step t1 (cl (= (or (= a b) c) (or (= b a) c))) :rule refl)
</code></pre>
<p>The <code>polyeq</code> elaboration step can be used to remove all such instances where polyequality reasoning
is required. For exemple, calling <code>carcara elaborate --pipeline polyeq</code> on the above step will
transform it into the following steps:</p>
<pre><code>(step t1.t1 (cl (= (= a b) (= b a))) :rule eq_symmetric)
(step t1.t2 (cl (= (or (= a b) c) (or (= b a) c))) :rule cong :premises (t1.t1))
</code></pre>
<p>In this case, Carcara added an <code>eq_symmetric</code> step to equate the two flipped equalities, and used a
<code>cong</code> step to construct the original conclusion of <code>t1</code>. The exact elaboration differs by rule. The
rules affected by this elaboration step are:</p>
<ul>
<li><code>assume</code></li>
<li><code>refl</code></li>
<li><code>forall_inst</code></li>
<li><code>subproof</code></li>
<li><code>ite_intro</code></li>
<li><code>bfun_elim</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-elaboration"><a class="header" href="#local-elaboration">"Local" elaboration</a></h1>
<p>Carcara has a number of small elaboration procedures for specific rules, that simplify steps in some small local way. These are grouped in the <code>local</code> elaboration step. The rules affected by this are:</p>
<ul>
<li><code>eq_transitive</code></li>
<li><code>trans</code></li>
<li><code>cong</code></li>
<li><code>resolution</code></li>
</ul>
<h2 id="transitivity-rules"><a class="header" href="#transitivity-rules">Transitivity rules</a></h2>
<p>The <code>eq_transitive</code> and <code>trans</code> rules may sometimes contain the transitivity chain in an incorrect
order. Additionally, the premise equalities might be flipped. For example, for <code>trans</code>, you may
have:</p>
<pre><code>(assume h1 (= a b))
(assume h2 (= c d))
(assume h3 (= c b))
(step t4 (cl (= a d)) :rule trans :premises (h1 h2 h3))
</code></pre>
<p>In this case, the <code>local</code> elaboration step will change the order of <code>t4</code>'s premises so the transitivity chain is well ordered; and add an auxiliary step to flip the <code>h3</code> equality. After elaboration, we will have:</p>
<pre><code>(assume h1 (= a b))
(assume h2 (= c d))
(assume h3 (= c b))
(step t4.t1 (cl (= b c)) :rule symm :premises (h3))
(step t4 (cl (= a d)) :rule trans :premises (h1 t4.t1 h2))
</code></pre>
<p>A similar procedure is applied for the <code>eq_transitive</code> rule.</p>
<h2 id="cong-rule"><a class="header" href="#cong-rule"><code>cong</code> rule</a></h2>
<p>In the specific case where the <code>cong</code> rule is used over the <code>=</code> operator, the argument order might
be flipped in one of the terms. For example, the following step is valid according to the Alethe
specification:</p>
<pre><code>(assume h1 (= x y))
(step t2 (cl (= (= 0 x) (= y 0))) :rule cong :premises (h1))
</code></pre>
<p>To simplify this, the <code>local</code> elaboration will add <code>eq_symmetric</code> and <code>trans</code> auxiliary steps,
resulting in the following:</p>
<pre><code>(assume h1 (= x y))
(step t2.t1 (cl (= (= 0 x) (= x 0))) :rule eq_symmetric)
(step t2.t2 (cl (= (= x 0) (= y 0))) :rule cong :premises (h1))
(step t2 (cl (= (= 0 x) (= y 0))) :rule trans :premises (t2.t1 t2.t2))
</code></pre>
<h2 id="resolution-rule"><a class="header" href="#resolution-rule"><code>resolution</code> rule</a></h2>
<p>In Alethe, <code>resolution</code> steps do not need to provide the pivots used in the resolution chain. For example, in the following proof, the step <code>t4</code> omits the pivots:</p>
<pre><code>(step t1 (cl p (not q)) :rule hole)
(step t2 (cl (not p)) :rule hole)
(step t3 (cl q r) :rule hole)
(step t4 (cl r) :rule resolution :premises (t1 t2 t3))
</code></pre>
<p>During elaboration, Carcara can find which pivots were used and add them to the proof step as
arguments. For each pivot, two arguments are provided: the pivot term, and a boolean indicating
whether it appears on the left-hand clause with positive polarity. For the example above, the
elaborated step will be:</p>
<pre><code>(step t4 (cl r) :rule resolution :premises (t1 t2 t3) :args (p true q false))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-features"><a class="header" href="#other-features">Other features</a></h1>
<p>Besides proof checking and elaboration, Carcara has a number of other functions useful for dealing
with Alethe proofs. Run <code>carcara --help</code> to see a full list of subcommands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-parsingprinting"><a class="header" href="#proof-parsingprinting">Proof parsing/printing</a></h1>
<p>You can use the <code>carcara parse</code> command to parse a proof file and print it back to standard output.
This can be used to validate if a proof is syntactically valid without checking any proof steps, or
to print the proof with some syntactical transformation applied.</p>
<h2 id="addingremoving-term-sharing"><a class="header" href="#addingremoving-term-sharing">Adding/removing term sharing</a></h2>
<p>When printing a proof, Carcara automatically adds term sharing (i.e., the <code>(! ... :named ...)</code>
syntax). If you parse a proof that does not make use of term sharing with <code>carcara parse</code>, it will
by default be printed with term sharing added. Alternatively, you can remove term sharing from a
proof that uses it by passing the <code>--no-print-with-sharing</code>/<code>-v</code> option.</p>
<h2 id="expanding-let-terms"><a class="header" href="#expanding-let-terms">Expanding <code>let</code> terms</a></h2>
<p>You can use the <code>--expand-let-bindings</code> option to remove all <code>let</code> terms from the proof by inlining all attributed values. For example, the term</p>
<pre><code>(let ((x 1)) (let ((y (+ x 2))) (+ y 3)))
</code></pre>
<p>will be expanded into</p>
<pre><code>(+ (+ 1 2) 3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-slicing"><a class="header" href="#proof-slicing">Proof slicing</a></h1>
<p>The <code>carcara slice</code> command can be used to extract an individual step from a proof, along with
its transitive premises. Besides the usual arguments for parsing and printing the proof, this
command also takes a <code>--from</code> argument which gives the step id from which to slice, and an optional
<code>--max-distance</code>/<code>-d</code> argument, that specifies how many layers of transitive premises the slice
should include.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Consider the following Alethe proof:</p>
<pre><code>(assume a0 a)
(step t0 (cl a b) :rule hole :premises (a0))
(step t1 (cl b a) :rule hole :premises (t0))
(step t2 (cl a b (not a)) :rule hole :premises (t0))
(anchor :step t3)
(assume t3.a0 (not a))
(step t3.t0 (cl b) :rule hole :premises (t3.a0 t1))
(step t3.t1 (cl b b) :rule hole :premises (t3.t0))
(step t3.t2 (cl (or b b)) :rule hole :premises (t3.t1))
(step t3 (cl (not (not a)) (or b b)) :rule subproof :discharge (t3.a0))
(step t4 (cl a (or b b)) :rule hole :premises (t3))
(step t5 (cl) :rule hole :premises (t4 a0 t2))
</code></pre>
<p>Calling <code>carcara slice --from t1 -d 1</code> on it will result in the steps:</p>
<pre><code>(assume a0 a)
(step t0 (cl a b) :rule hole :premises (a0))
(step t1 (cl b a) :rule hole :premises (t0))
(step slice_end (cl) :rule hole :premises (t1) :args ("trust"))
</code></pre>
<p>Note that, to make sure the slice is still a valid proof, Carcara added a dummy <code>slice_end</code> step
that concludes the empty clause.</p>
<p>You can also slice from inside a subproof. Calling <code>carcara slice --from t3.t0</code> on the proof above
results in the slice:</p>
<pre><code>(step t1 (cl b a) :rule hole :args ("trust"))
(anchor :step t3)
(assume t3.a0 (not a))
(step t3.t0 (cl b) :rule hole :premises (t3.a0 t1))
(step t3.t2 (cl (or b b)) :rule hole :premises (t3.t0) :args ("trust"))
(step t3 (cl (not (not a)) (or b b)) :rule subproof :discharge (t3.a0))
(step slice_end (cl) :rule hole :premises (t3) :args ("trust"))
</code></pre>
<p>A few things of note:</p>
<ul>
<li>Since we did not pass <code>--max-distance</code>/<code>-d</code>, the slice only included the direct premises of
<code>t3.t2</code>, and no transitive premises. For example, <code>t0</code>, which is a transitive premise of <code>t3.t2</code> via
<code>t1</code>, was not included.</li>
<li>To keep any context that might be introduced in an <code>anchor</code>, the slice included all <code>anchor</code>s
surrounding the sliced step (in this case, <code>(anchor :step t3)</code>).</li>
<li>To ensure that the resulting proof is still valid, the slice has to include the <code>t3</code> step that
concludes the subproof, as well as the previous step (<code>t3.t2</code>) which is implicitly referenced by
<code>t3</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
