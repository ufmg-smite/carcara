require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Eq;
require open Stdlib.Nat;
require Stdlib.Bool;
require open Stdlib.Set;

require open lambdapi.Classic;
require open lambdapi.Alethe;
require open Stdlib.List;

inductive prop: TYPE â‰”
|pTrue: prop
| pFalse: prop
| pAnd: prop â†’ prop â†’ prop
| pOr: prop â†’ prop â†’ prop
| pImpl: prop â†’ prop â†’ prop
;

symbol propS: Set;

rule Ï„ propS â†ª prop;

print prop;

symbol ind_propá¶œ : Î  p0: (prop â†’ Prop), 
    Ï€á¶œ (p0 pTrue) â†’ 
    Ï€á¶œ (p0 pFalse) â†’
    (Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Î  x1: prop, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (pAnd x0 x1)))
    â†’ (Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Î  x1: prop, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (pOr x0 x1)))
    â†’ (Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Î  x1: prop, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (pImpl x0 x1)))
    â†’ Î  x: prop, Ï€á¶œ (p0 x);


symbol o: Set;
rule Ï„ o â†ª Prop;

symbol not_found: Prop; // Just a simple opaque definition to represent an error message.

// A denotation function converts our syntax into a semantic value
// The Ïƒ is the context which contains the mapping from variables to Props.
symbol propD (Ïƒ: ğ•ƒ o) (p: prop): Prop;
rule propD _ pTrue â†ª âŠ¤
with propD _ pFalse â†ª âŠ¥
with propD $ctx (pAnd $x $y) â†ª  (propD $ctx $x) âˆ§á¶œ (propD $ctx $y)
with propD $ctx (pOr $x $y) â†ª  (propD $ctx $x) âˆ¨á¶œ (propD $ctx $y)
with propD $ctx (pImpl $x $y) â†ª  (propD $ctx $x) â‡’á¶œ (propD $ctx $y)
;

open Stdlib.Bool;

symbol prop_eq (l r: prop): Ï„ bool;
rule prop_eq pTrue pTrue â†ª true
with prop_eq pTrue pFalse â†ª false
with prop_eq pTrue (pAnd _ _) â†ª false
with prop_eq pTrue (pOr _ _) â†ª false
with prop_eq pTrue (pImpl _ _) â†ª false
//with prop_eq pTrue (pOther _) â†ª false

with prop_eq pFalse pFalse â†ª true
with prop_eq pFalse pTrue â†ª false
with prop_eq pFalse (pAnd _ _) â†ª false
with prop_eq pFalse (pOr _ _) â†ª false
with prop_eq pFalse (pImpl _ _) â†ª false
//with prop_eq pFalse (pOther _) â†ª false

with prop_eq (pAnd $a $b) (pAnd $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pAnd _ _) pFalse â†ª false
with prop_eq (pAnd _ _) pTrue â†ª false
with prop_eq (pAnd _ _) (pOr _ _) â†ª false
with prop_eq (pAnd _ _) (pImpl _ _) â†ª false
//with prop_eq (pAnd _ _) (pOther _) â†ª false

with prop_eq (pOr $a $b) (pOr $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pOr _ _) pFalse â†ª false
with prop_eq (pOr _ _) pTrue â†ª false
with prop_eq (pOr _ _) (pAnd _ _) â†ª false
with prop_eq (pOr _ _) (pImpl _ _) â†ª false
//with prop_eq (pOr _ _) (pOther _) â†ª false

with prop_eq (pImpl $a $b) (pImpl $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pImpl _ _) pFalse â†ª false
with prop_eq (pImpl _ _) pTrue â†ª false
with prop_eq (pImpl _ _) (pAnd _ _) â†ª false
with prop_eq (pImpl _ _) (pOr _ _) â†ª false
with prop_eq (pImpl _ _) (pImpl _ _) â†ª false
//with prop_eq (pImpl _ _) (pOther _) â†ª false


// with prop_eq (pOther $i) (pOther $j) â†ª (eqn $i $j)
// with prop_eq (pOther $i) pFalse â†ª false
// with prop_eq (pOther $i) pTrue â†ª false
// with prop_eq (pOther $i) (pAnd _ _) â†ª false
// with prop_eq (pOther $i) (pOr _ _) â†ª false
// with prop_eq (pOther $i) (pImpl _ _) â†ª false
// with prop_eq (pOther $i) (pOther _) â†ª false
;

symbol knows (p: prop) (c: ğ•ƒ propS): ğ”¹ â‰” âˆˆ prop_eq p c;

sequential symbol learn (p: prop) (c: ğ•ƒ propS) : ğ•ƒ propS;
rule learn pTrue $c â†ª $c
with learn pFalse $c â†ª pFalse â¸¬ â–¡
with learn (pAnd $l $r) $c â†ª learn $l (learn $r $c)
with learn $p $c â†ª $p â¸¬ $c; //HACK: for simplicity

symbol provable (goal: prop) (known: ğ•ƒ propS) : ğ”¹;
rule provable pTrue _ â†ª true
with provable pFalse $known â†ª knows pFalse $known
with provable (pAnd $l $r) $known â†ª (provable $l $known) and (provable $r $known)
with provable (pOr $l $r) $known â†ª (provable $l $known) or (provable $r $known)
with provable (pImpl $l $r) $known â†ª provable $r (learn $l $known)
;

symbol foldr [a b: Set] : (Ï„ a â†’ Ï„ b â†’ Ï„ b) â†’ Ï„ b â†’ ğ•ƒ a â†’ Ï„ b;
rule foldr $f $z â–¡ â†ª $z
with foldr $f $z ($x â¸¬ $xs) â†ª $f $x (foldr $f $z $xs);

symbol All: ğ•ƒ propS â†’ prop â‰” foldr (pAnd) pTrue;

symbol I: Ï€ âŠ¤;

symbol prop_eq_sound [p q] : Ï€á¶œ (prop_eq p q) â†’ Ï€á¶œ (p = q);

opaque symbol learn_sound (ctx: ğ•ƒ o) (p: prop) (c: ğ•ƒ propS): Ï€á¶œ (propD ctx (All c)) â†’ Ï€á¶œ ( propD ctx p) â†’ Ï€á¶œ ( propD ctx (All (learn p c)))
â‰” begin
    admit
end;

print ğ•ƒ;

symbol ind_ğ•ƒá¶œ : Î  a0: Set, Î  p0: (ğ•ƒ a0 â†’ Prop), Ï€á¶œ (p0 â–¡) â†’ (Î  x0: Ï„ a0, Î  x1: ğ•ƒ a0, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (x0 â¸¬ x1))) â†’ Î  x: ğ•ƒ a0, Ï€á¶œ (p0 x);

symbol âˆ§á¶œ_istrue [p q : ğ”¹] : Ï€á¶œ(p and q) â†’ Ï€á¶œ(p âˆ§á¶œ q);

symbol âˆ¨á¶œ_istrue [p q : ğ”¹] : Ï€á¶œ(p or q) â†’ Ï€á¶œ(p âˆ¨á¶œ q);


opaque symbol knows_sound2 (Ïƒ: ğ•ƒ o) (c: ğ•ƒ propS) : Ï€á¶œ (`âˆ€á¶œ p, (knows p c) â‡’á¶œ propD Ïƒ (All c) â‡’á¶œ propD Ïƒ p) â‰”
begin 
    assume Ïƒ;
    refine ind_ğ•ƒá¶œ propS (Î» u, `âˆ€á¶œ p, istrue (âˆˆ prop_eq p u) â‡’á¶œ (propD Ïƒ (All u) â‡’á¶œ propD Ïƒ p)) _ _
    {
        apply âˆ€á¶œáµ¢; assume p;
        simplify;
        apply â‡’á¶œáµ¢;
        assume contra;
        apply âŠ¥á¶œâ‚‘ contra
    }
    {
        assume h tl IH; 
        apply âˆ€á¶œáµ¢; assume p;
        simplify;
        apply â‡’á¶œáµ¢;
        assume H;
        have g: Ï€á¶œ ((prop_eq p h) âˆ¨á¶œ (âˆˆ prop_eq p tl)) {
            refine âˆ¨á¶œ_istrue H
        };
        apply âˆ¨á¶œâ‚‘ g
        {
            assume H2; apply â‡’á¶œáµ¢; assume H3;
            have p=h: Ï€á¶œ (p = h) { refine prop_eq_sound H2 };
            rewrite p=h;
            apply âˆ§á¶œâ‚‘â‚ H3
        }
        {
            assume H2; apply â‡’á¶œáµ¢; assume H3;
            refine â‡’á¶œâ‚‘ (â‡’á¶œâ‚‘ (@âˆ€á¶œâ‚‘ propS _ p IH) H2) (âˆ§á¶œâ‚‘â‚‚ H3);
        }
    }
end;

opaque symbol knows_sound (Ïƒ: ğ•ƒ o) (c: ğ•ƒ propS) (p: prop) : Ï€á¶œ ((knows p c)) â†’ Ï€á¶œ (propD Ïƒ (All c))  â†’ Ï€á¶œ (propD Ïƒ p) â‰”
begin 
    assume Ïƒ ctx p H1 H2;
    refine â‡’á¶œâ‚‘ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ p (@knows_sound2 Ïƒ ctx)) H1) H2;
end;


opaque symbol provable_sound: Î  (goal: prop), Ï€á¶œ (`âˆ€á¶œ ( hyps: ğ•ƒ propS),
    (provable goal hyps) â‡’á¶œ
    (`âˆ€á¶œ  (ctx: ğ•ƒ o),  (propD ctx (All hyps)) â‡’á¶œ
     propD ctx goal)) â‰”
begin
    refine ind_propá¶œ (Î» u, `âˆ€á¶œ hyps, (provable u hyps) â‡’á¶œ (`âˆ€á¶œ ctx, propD ctx (All hyps) â‡’á¶œ propD ctx u))
    _ _ _ _ _
    {
        apply âˆ€á¶œáµ¢; assume ctx; apply â‡’á¶œáµ¢;  assume H; apply âˆ€á¶œáµ¢; assume Ïƒ;  apply â‡’á¶œáµ¢;  assume H2;
        apply trivial
    }
    {
        apply âˆ€á¶œáµ¢; assume ctx; apply â‡’á¶œáµ¢;  assume H; apply âˆ€á¶œáµ¢; assume Ïƒ;  apply â‡’á¶œáµ¢;  assume H2;
        apply (knows_sound Ïƒ ctx pFalse H);
        refine H2
    }
    {
        assume a IHa; assume b IHb;
        apply âˆ€á¶œáµ¢; assume ctx; apply â‡’á¶œáµ¢;  assume H; apply âˆ€á¶œáµ¢; assume Ïƒ;  apply â‡’á¶œáµ¢;  assume H2;
        have G: Ï€á¶œ ((provable a ctx) âˆ§á¶œ (provable b ctx) ) {
            refine (@âˆ§á¶œ_istrue (provable a ctx) (provable b ctx)) H; 
        };
        apply âˆ§á¶œáµ¢ 
        { refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ Ïƒ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ctx IHa) (âˆ§á¶œâ‚‘â‚ G))) H2; }
        { refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ Ïƒ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ctx IHb) (âˆ§á¶œâ‚‘â‚‚ G))) H2; }
    }
    {
        assume a IHa; assume b IHb;
        apply âˆ€á¶œáµ¢; assume ctx; apply â‡’á¶œáµ¢;  assume H; apply âˆ€á¶œáµ¢; assume Ïƒ;  apply â‡’á¶œáµ¢;  assume H2;
        have G: Ï€á¶œ ((provable a ctx) âˆ¨á¶œ (provable b ctx) ) {
            refine (@âˆ¨á¶œ_istrue (provable a ctx) (provable b ctx)) H; 
        };
        apply âˆ¨á¶œâ‚‘ G
        {
            assume Ha;
            apply âˆ¨á¶œáµ¢â‚;
            refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ Ïƒ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ctx IHa) Ha)) H2;
        }
        {
            assume Hb;
            apply âˆ¨á¶œáµ¢â‚‚;
            refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ Ïƒ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ctx IHb) Hb)) H2;
        }
    }
    {
        assume p IH1 q IH2;
        apply âˆ€á¶œáµ¢; assume ctx;
        apply â‡’á¶œáµ¢;  assume H;
        apply âˆ€á¶œáµ¢; assume Ïƒ;
        apply â‡’á¶œáµ¢;  assume H2;
        apply â‡’á¶œáµ¢;  assume Hp;
        refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ Ïƒ (â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ (p â¸¬ ctx) IH2) H)) _;
        apply âˆ§á¶œáµ¢
        { apply Hp }
        { refine H2 }
    }
end;
