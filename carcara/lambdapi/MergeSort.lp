require Stdlib.Nat as Nat;
open Stdlib.Nat;
require open Stdlib.Z;
require open lambdapi.Lia;

symbol compG : G â†’ G â†’ Comp;
rule compG (Var $i $k) (Var $j $k2) â†ª compN $i $j
with compG (Var _ _) (Cst _) â†ª Gt
with compG (Cst _) (Var _ _)  â†ª Lt
with compG (Cst $c1) (Cst $c2)  â†ª $c1 â‰ $c2;


symbol split [a: Set] (l : Ï„ (list a)): Ï„(list a Ã— list a);
rule split â–¡ â†ª (â–¡ â€š â–¡)
with split ($x â¸¬ â–¡) â†ª (($x â¸¬ â–¡) â€š â–¡)
with split ($x â¸¬ $y â¸¬ $l) â†ª  
    let res â‰”  (split $l) in
        ($x â¸¬ (res â‚)) â€š ($y â¸¬ (res â‚‚));


symbol list_ind2_principle [A : Set]  :
  Î  (P : Ï„ (list A) â†’ Prop),
    Ï€ (P â–¡) â†’
    (Î  (a: Ï„ A), Ï€ (P (a â¸¬ â–¡))) â†’
    (Î  (a b : Ï„ A) (l : Ï„ (list A)), Ï€ (P l) â†’  Ï€ (P (a â¸¬ b â¸¬ l))) â†’
    Î  (l : Ï„ (list A)), Ï€ (P l);

opaque symbol split_correct l gs : Ï€ (val (Add (sum (split gs â‚)) (sum (split gs â‚‚)) â€š l) = val (sum gs â€š l)) â‰”
begin
assume l;
refine list_ind2_principle (Î» u, (val (Add (sum (split u â‚)) (sum (split u â‚‚)) â€š l) = val (sum u â€š l))) _ _ _
{reflexivity}
{reflexivity}
{
  assume a b tl ih;
  simplify;
  rewrite left ih;
  simplify;
  rewrite +_assoc;
  rewrite left .[in x in (_ + x ) = _] +_assoc;
  rewrite +_com (val (sum (split tl â‚) â€š l)) (val (b â€š l));
  rewrite .[in x in (_ + x ) = _] +_assoc;
  reflexivity
}
end;


symbol merge  (l1 l2 : Ï„ (list grp)): Ï„ (list grp);
rule merge â–¡ â–¡ â†ª â–¡
with merge â–¡ $l2 â†ª $l2
with merge $l1 â–¡ â†ª $l1
with merge (Cst $c1 â¸¬ $l1') (Cst $c2 â¸¬ $l2') â†ª (Cst ($c1 + $c2) â¸¬ merge $l1' $l2')
with merge (Cst $c â¸¬ $l1') (Var $i $k â¸¬ $l2') â†ª (Cst $c â¸¬ merge $l1' (Var $i $k â¸¬ $l2'))
with merge (Var $i $k â¸¬ $l1') (Cst $c â¸¬ $l2') â†ª (Cst $c â¸¬ merge (Var $i $k â¸¬ $l1') $l2')
with merge ((Var $i $k1) â¸¬ $l1') ((Var $j $k2) â¸¬ $l2') â†ª
    case_Comp (compN $i $j)
        (Var $i ($k1 + $k2) â¸¬ merge $l1' $l2')
        ((Var $i $k1) â¸¬ merge $l1' (Var $j $k2 â¸¬ $l2'))
        ((Var $j $k2) â¸¬ merge (Var $i $k1 â¸¬ $l1') $l2')
;

opaque symbol merge_correct l g1 g2 : Ï€ (no_Add g1) â†’  Ï€ (no_Add g2) â†’  Ï€ (val ( sum (merge  g1 g2) â€š l ) = val (sum g1 â€š l) + val (sum g2 â€š l)) â‰”
begin
  assume l;
  induction
  { simplify; reflexivity }
  {
    induction
    {
      assume k g1' IH;
      induction
      {
        assume h_nodaddg1 h_nodaddg2;
        reflexivity;
      }
      {
        induction
        {
          assume k2 g2' IH2 h2 h3;
          simplify;
          rewrite left +_assoc;
          rewrite .[in x in _ = (x + _) ] +_assoc;
          rewrite .[in x in _ = ((_ + x) + _) ] +_com;
          rewrite left .[in x in _ = (x + _) ] +_assoc;
          rewrite IH (g2') _ _ { refine âˆ§â‚‘â‚‚ h2 } { refine âˆ§â‚‘â‚‚ h3 } { rewrite .[in x in _ = x] +_assoc; reflexivity };
        }
        {
          assume i c g2' IH2 hnoadd1 hnoadd2;
          simplify; rewrite IH (Var i c â¸¬ g2') _ _ { refine âˆ§â‚‘â‚‚ hnoadd1 } { refine hnoadd2 } { simplify; rewrite +_assoc; reflexivity };
        }
        {
          simplify; assume g1 ih1 g2 ih2 g2' h5 h6 contradiction;
          refine âŠ¥â‚‘ (âˆ§â‚‘â‚ contradiction);
        }
      }
    }
    {
      assume i k1 g1' ih1;
      induction
      { reflexivity; }
      {
        induction
        {
          assume c g2' ih2 hnoadd hnoadd2; simplify;
          rewrite ih2 hnoadd (âˆ§â‚‘â‚‚ hnoadd2);
          rewrite left .[in x in _ = x ] +_assoc;
          simplify;
          rewrite .[in x in _ = x + _ ] +_com;
          rewrite  .[in x in _ = x ] +_assoc;
          reflexivity
        }
        {
          assume j k2 g2' ih2 hnoadd1 hnoadd2;
          simplify;
          refine ind_Comp (Î» u, (compN i j) = u â‡’ val (sum (case_Comp u (Var i (k1 + k2) â¸¬ merge g1' g2') (Var i k1 â¸¬ merge g1' (Var j k2 â¸¬ g2')) (Var j k2 â¸¬ merge (Var i k1 â¸¬ g1') g2')) â€š l) = (((nth l i * k1) + val (sum g1' â€š l)) + ((nth l j * k2) + val (sum g2' â€š l)))) _ _ _ (compN i j) _
          {
            simplify; assume hieqj;
            rewrite compN_correct i j hieqj;
            rewrite distr*+; rewrite ih1 g2'  (âˆ§â‚‘â‚‚ hnoadd1) (âˆ§â‚‘â‚‚ hnoadd2);
            rewrite left .[in x in _ = x ] +_assoc;
            rewrite  .[in x in _ = (x + _) ] +_com;
            rewrite left .[in x in _ = (x + _) ] +_assoc;
            rewrite  +_com (nth l j * k2) (nth l j * k1);
            rewrite .[in x in _ = x ] +_assoc; reflexivity
          }
          {
            simplify; assume hieqj;
            rewrite ih1 (Var j k2 â¸¬ g2')  (âˆ§â‚‘â‚‚ hnoadd1) hnoadd2;
            simplify; rewrite  +_assoc; reflexivity
          }
          {
            assume hGt;
            simplify;  
            rewrite ih2 hnoadd1 (âˆ§â‚‘â‚‚ hnoadd2);
            simplify;
            rewrite left .[ in x in _ = x] +_assoc;
            rewrite .[ in x in _ = (x + _)] +_com;
            rewrite .[ in x in _ = x] +_assoc; reflexivity
          }
          { reflexivity }
        }
        {
          simplify;
          assume x1 ih x2 ih2 g2 h1 hnoadd1 hnoadd2;
          refine âŠ¥â‚‘ (âˆ§â‚‘â‚ hnoadd2 )
        }
      }
    }
    {
      assume g1 ih g2 ih2 g1' h g2' hnoadd1 hnoadd2;
      refine âŠ¥â‚‘ (âˆ§â‚‘â‚ hnoadd1)
    }
  }
end;


symbol mergesort:  Ï„ (list grp) â†’  Ï„ (list grp);
rule mergesort â–¡ â†ª â–¡
with mergesort ($x â¸¬ â–¡) â†ª ($x â¸¬ â–¡)
with mergesort ($x â¸¬ $y â¸¬ $l) â†ª 
    let s â‰” split ($x â¸¬ $y â¸¬ $l) in
    let l1 â‰” s â‚ in
    let l2 â‰” s â‚‚ in
        merge (mergesort l1) (mergesort l2);

print ğ•ƒ;

opaque symbol rec_ğ•ƒ : Î  [a: Set], Î  l: ğ•ƒ a, Î  p: (ğ•ƒ a â†’ Prop), Ï€ (p â–¡) â†’ (Î  x0: Ï„ a, Î  l': ğ•ƒ a, Ï€ (p (x0 â¸¬ l'))) â†’ Ï€ (p l) â‰” 
begin
  assume a l P H1 H2;
  refine @ind_ğ•ƒ a P H1 (Î» x l' ih, H2 x l') l
end;

opaque symbol case_l [a] x (l: ğ•ƒ a) n : Ï€ ((size (x â¸¬ l)) Nat.â‰¤ (n +1)) â†’ Ï€ (size l Nat.â‰¤ n) â‰”
begin
  assume a x l n;
  refine Î» x, x;
end;

opaque symbol size_split [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚) Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚) Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol size_split2 [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚‚) Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚‚) Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol mergesort_correct_aux n l g : Ï€ (size g Nat.â‰¤ n) â†’  Ï€ (no_Add g) â†’  Ï€ (val ( sum (mergesort g) â€š l ) = val (sum g â€š l)) â‰”
begin
  //assume n l;
  induction
  {
    assume l;
    assume g h inv;
    type â‰¤0 (size g) h;
    rewrite size0nil g (â‰¤0 (size g) h);
    reflexivity
  }
  {
    assume n;
    assume ihn l g;
    refine rec_ğ•ƒ g (Î» u, istrue (size u Nat.â‰¤ (n +1)) â‡’ (no_Add u â‡’ (val (sum (mergesort u) â€š l) = val (sum u â€š l)))) _ _
    {
      assume h1 h2; reflexivity
    }
    {
      assume x g';
      refine rec_ğ•ƒ g' (Î» u, istrue (size (x â¸¬ u) Nat.â‰¤ (n +1)) â‡’ (no_Add (x â¸¬ u) â‡’ (val (sum (mergesort (x â¸¬ u)) â€š l) = val (sum (x â¸¬ u) â€š l)))) _ _
      {
        assume h1 inv; reflexivity;
      }
      {
        assume y g'' inv1 inv2;
        simplify;
        have tmp: Ï€ (no_Add (mergesort (x â¸¬ (split g'' â‚)))) { admit};
        have tmp2: Ï€ (no_Add (mergesort (y â¸¬ (split g'' â‚‚)))) { admit};
        rewrite (merge_correct l (mergesort (x â¸¬ ((split g'') â‚))) (mergesort (y â¸¬ ((split g'') â‚‚)))) tmp tmp2;
        type ihn l (x â¸¬ (split g'' â‚)) ;
        have tmp3x: Ï€ (istrue (size (x â¸¬ (split g'' â‚)) Nat.â‰¤ n)) {
          generalize inv1;
          assume inv1 h1 h2 h3;
          apply @leq_trans
          (size (split g'' â‚) +1)
          (size g'' +1)
          n
          _
          inv1;
          apply size_split g''
        };
        have tmp4x: Ï€ (no_Add (x â¸¬ (split g'' â‚))) {admit};
        rewrite ihn l (x â¸¬ (split g'' â‚)) tmp3x tmp4x;
        have tmp3y: Ï€ (istrue (size (y â¸¬ (split g'' â‚‚)) Nat.â‰¤ n)) {
          generalize inv1;
          simplify;
          assume  inv1 h1 h2 h3 h4 h5;
          apply @leq_trans
          (size (split g'' â‚‚) +1)
          (size g'' +1)
          n
          _
          inv1;
          simplify;
          apply size_split2 g''
        };
        have tmp4y: Ï€ (no_Add (y â¸¬ (split g'' â‚‚))) {admit};
        rewrite ihn l (y â¸¬ (split g'' â‚‚)) tmp3y tmp4y;
        simplify;
        rewrite +_assoc;
        refine @feq2 int int int (+) (val (x â€š l)) (val (x â€š l)) (eq_refl (val (x â€š l)))
        (val (sum (split g'' â‚) â€š l) + (val (y â€š l) + val (sum (split g'' â‚‚) â€š l)))
        (val (y â€š l) + val (sum g'' â€š l)) _
        ;
        rewrite left +_assoc;
        rewrite .[in x in (x + _) = _ ] +_com;
        rewrite  +_assoc;
        refine @feq2 int int int (+) (val (y â€š l)) (val (y â€š l)) (eq_refl (val (y â€š l)))
        (val (sum (split g'' â‚) â€š l) + val (sum (split g'' â‚‚) â€š l))
        (val (sum g'' â€š l))
        _
        ;
        apply split_correct l g''     
      }
    };
  }
end;

symbol mergesort_correct l g â‰” mergesort_correct_aux (size g) l g (Nat.â‰¤_refl (size g));

compute mergesort ((Var Nat._3 2) â¸¬ (Var Nat._2 2) â¸¬ (Var Nat._1 2) â¸¬ Cst 10 â¸¬ â–¡);

symbol norm_speed x â‰” sum (remove0 (mergesort (aliens x)));


opaque symbol no_Add_mergesort xs : Ï€(no_Add xs) â†’ Ï€(no_Add (mergesort xs)) â‰”
begin
admitted;

opaque symbol norm_with_mergesort_correct (x: G) l :
  Ï€(varmax x Nat.â‰¤ size l) â†’ Ï€(val(norm_speed x â€š l) = val(x â€š l)) â‰”
begin
assume x l h; simplify; apply eq_trans (val (sum (remove0 (mergesort (aliens x))) â€š l)) (val (sum (mergesort (aliens x)) â€š l)) (val (x â€š l))
{ apply remove0_correct l (mergesort(aliens x));
  apply no_Add_mergesort (aliens x); apply no_Add_aliens x }
{ apply eq_trans (val (sum (mergesort (aliens x)) â€š l)) (val (sum (aliens x) â€š l)) (val (x â€š l))
  { apply mergesort_correct l (aliens x);
    apply no_Add_aliens x }
  { apply aliens_correct l x}
}
end;

symbol l1 x y : Ï€((x + y) - (x + y) â‰  1) â‰”
begin
  assume x y;
  refine â‰_decides_neq _;
  rewrite left .[z in z â‰ _] reify_correct;
  set e â‰” reify ((x + y) - (x + y));
  rewrite .[z in val z] eta_prod;
  rewrite left norm_with_mergesort_correct (e â‚) (e â‚‚) _ { refine âŠ¤áµ¢ } { refine Ltâ‰ Eq }
end;