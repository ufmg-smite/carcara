require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Eq;
require open Stdlib.Nat;
require Stdlib.Bool;
require open Stdlib.Set;
require open Stdlib.List;
require open lambdapi.Alethe;
require open lambdapi.Classic;
open Stdlib.Bool;

inductive prop: TYPE â‰”
| pTrue: prop
| pFalse: prop
| pAnd: prop â†’ prop â†’ prop
| pOr: prop â†’ prop â†’ prop
| pImpl: prop â†’ prop â†’ prop
// | pNeg: prop â†’ prop
;


symbol imp : ğ”¹ â†’ ğ”¹ â†’ ğ”¹;
notation imp infix left 20;
rule true imp true â†ª true
with true imp false â†ª false
with false imp true â†ª true
with false imp false â†ª true
;

symbol propS: Set;

rule Ï„ propS â†ª prop;
// 
print prop;
symbol ind_propá¶œ : Î  p0: (prop â†’ Prop), 
  Ï€á¶œ (p0 pTrue) â†’ 
  Ï€á¶œ (p0 pFalse) â†’ 
  (Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Î  x1: prop, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (pAnd x0 x1))) â†’ 
  (Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Î  x1: prop, Ï€á¶œ (p0 x1) â†’ Ï€á¶œ (p0 (pOr x0 x1)))  â†’
  //(Î  x0: prop, Ï€á¶œ (p0 x0) â†’ Ï€á¶œ (p0 (pNeg x0))) â†’
  Ï€á¶œ (`âˆ€á¶œ x: prop, p0 x);

// A denotation function converts our syntax into a semantic value
// The Ïƒ is the context which contains the mapping from variables to Props.
symbol prop_denote (p: prop): Prop;
rule prop_denote pTrue â†ª âŠ¤
with prop_denote pFalse â†ª âŠ¥
// with prop_denote (pNeg $x) â†ª Â¬ (prop_denote $x)
with prop_denote (pAnd $x $y) â†ª  (prop_denote $x) âˆ§á¶œ (prop_denote $y)
with prop_denote (pOr $x $y) â†ª  (prop_denote $x) âˆ¨á¶œ (prop_denote $y)
;

sequential symbol prop_reify: Prop â†’ prop;
rule prop_reify âŠ¤ â†ª pTrue
with prop_reify âŠ¥ â†ª pFalse
//with prop_reify (Â¬ $x) â†ª  pNeg (prop_reify $x)
with prop_reify ($x âˆ§á¶œ $y) â†ª  pAnd (prop_reify $x) (prop_reify $y)
with prop_reify ($x âˆ¨á¶œ $y) â†ª  pOr (prop_reify $x) (prop_reify $y)
;




symbol provable (goal: prop) : ğ”¹;
rule provable pTrue â†ª true
with provable pFalse  â†ª false
with provable (pAnd $l $r)  â†ª (provable $l ) and (provable $r )
with provable (pOr $l $r)  â†ª (provable $l ) or (provable $r )
//with provable (pNeg $x)  â†ª not (provable $x)
;



opaque symbol falseâ‰ true : Ï€á¶œ (false = true) â†’ Ï€á¶œ âŠ¥ â‰”
begin
  admit
end;

opaque symbol trueâ‰ false : Ï€á¶œ (true = false) â†’ Ï€á¶œ âŠ¥ â‰”
begin
  admit
end;

opaque symbol true=not_false : Ï€á¶œ (true = not false)  â‰”
begin
  reflexivity
end;

opaque symbol not_true=false : Ï€á¶œ (not true = false)  â‰”
begin
  reflexivity
end;


opaque symbol case_ğ”¹2 b : Ï€á¶œ ((b = true) âˆ¨á¶œ (b = false)) â‰”
begin
    admit
end;

opaque symbol ind_ğ”¹_eq p b:
 (Ï€á¶œ(b = true) â†’ Ï€á¶œ(p b)) â†’ (Ï€á¶œ(b = false) â†’ Ï€á¶œ(p b)) â†’ Ï€á¶œ(p b) â‰”
begin
  admit
end;

opaque symbol âˆ§á¶œ_istrue [p q : ğ”¹] : Ï€á¶œ(p and q) â†’ Ï€á¶œ(p âˆ§á¶œ q) â‰”
begin
  admit
end;

opaque symbol âˆ¨á¶œ_istrue [p q : ğ”¹] : Ï€á¶œ(p or q) â†’ Ï€á¶œ(p âˆ¨á¶œ q) â‰”
begin
  admit
end;

opaque symbol Â¬á¶œ_istrue [p: ğ”¹] : Ï€á¶œ (not p) â†’ Ï€á¶œ (Â¬ p) â‰”
begin
  admit
end;

symbol â‡’_istrue [p q : ğ”¹] : Ï€á¶œ (p imp q) â†’ Ï€á¶œ (p â‡’ q);

opaque symbol provable_sound2: Ï€á¶œ (`âˆ€á¶œ g, (provable g) â‡’á¶œ prop_denote g) â‰”
begin
refine ind_propá¶œ (Î» x, (provable x)  â‡’á¶œ prop_denote x) _ _ _ _
{
    simplify;
    apply â‡’á¶œáµ¢;
    refine (Î» x, x)
}
{
    apply â‡’á¶œáµ¢;
    refine (Î» x, x)
}
{
  assume x IHx;
  assume y IHy;
  apply â‡’á¶œáµ¢; assume g;
  have g2: Ï€á¶œ (provable x âˆ§á¶œ (provable y)) { refine âˆ§á¶œ_istrue g  };
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œâ‚‘ IHx;
    refine âˆ§á¶œâ‚‘â‚ g2
  }
  {
    apply â‡’á¶œâ‚‘ IHy;
    refine âˆ§á¶œâ‚‘â‚‚ g2
  }
}
{
  assume x IHx;
  assume y IHy;
  apply â‡’á¶œáµ¢; assume g;
  have g2: Ï€á¶œ (provable x âˆ¨á¶œ (provable y)) { refine âˆ¨á¶œ_istrue g  };
  apply âˆ¨á¶œâ‚‘ g2
  {
    assume gx;
    apply âˆ¨á¶œáµ¢â‚;
    apply â‡’á¶œâ‚‘ IHx gx; 
  }
  {
    assume gy;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply â‡’á¶œâ‚‘ IHy gy; 
  }
}
// {
//   simplify;
//   assume x IHx;
//   apply â‡’á¶œáµ¢; assume g;
//   have tmp: Ï€á¶œ (istrue (not (provable x))) { refine g };
//   have g2: Ï€á¶œ (Â¬ (provable x)) { refine  @Â¬á¶œ_istrue (provable x) g; };
//   have e: Ï€á¶œ (((provable x) = true) âˆ¨á¶œ ((provable x) = false)) {admit};
//   apply âˆ¨á¶œâ‚‘ e
//   {
//     assume Hv;
//     apply â‡’á¶œáµ¢'; assume h;
//     have g3: Ï€á¶œ (Â¬ (istrue true)) { rewrite left Hv; refine g2 };
//     apply â‡’á¶œâ‚‘' g3;
//     apply trivial
//   }
//   {
//     simplify;
//     assume Hv;
//     apply â‡’á¶œáµ¢'; assume h;
//     remove e;
//     remove tmp;
//      apply â‡’á¶œâ‚‘' g2;
//   }
// }
end;