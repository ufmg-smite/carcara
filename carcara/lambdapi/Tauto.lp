require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Eq;
require open Stdlib.Nat;
require Stdlib.Bool;
require open Stdlib.Set;
// require open lambdapi.Classic;
// require open lambdapi.Alethe;
require open Stdlib.List;

inductive prop: TYPE â‰”
|pTrue: prop
| pFalse: prop
| pAnd: prop â†’ prop â†’ prop
| pOr: prop â†’ prop â†’ prop
| pImpl: prop â†’ prop â†’ prop
//| pNot: prop â†’ prop
| pOther: â„• â†’ prop
;

symbol propS: Set;

rule Ï„ propS â†ª prop;


symbol o: Set;
rule Ï„ o â†ª Prop;

symbol not_found: Prop; // Just a simple opaque definition to represent an error message.

// A denotation function converts our syntax into a semantic value
// The Ïƒ is the context which contains the mapping from variables to Props.
symbol propD (Ïƒ: ğ•ƒ o) (p: prop): Prop;
rule propD _ pTrue â†ª âŠ¤
with propD _ pFalse â†ª âŠ¥
with propD $ctx (pAnd $x $y) â†ª  (propD $ctx $x) âˆ§ (propD $ctx $y)
with propD $ctx (pOr $x $y) â†ª  (propD $ctx $x) âˆ¨ (propD $ctx $y)
with propD $ctx (pImpl $x $y) â†ª  (propD $ctx $x) â‡’ (propD $ctx $y)
//with propD $ctx (pNot $x) â†ª  Â¬ (propD $ctx $x)
with propD $ctx (pOther $i) â†ª nth not_found $ctx $i;

private symbol a: Prop;
private symbol b: Prop;
private symbol f: Prop â†’ Prop;

type (a â¸¬ f b â¸¬ b â¸¬ â–¡);

private symbol ctx â‰” (a â¸¬ f b â¸¬ b â¸¬ â–¡);

assert âŠ¢ propD ctx (pOther 0) â‰¡ a;
assert âŠ¢ propD ctx (pOther 1) â‰¡ f b;
assert âŠ¢ propD ctx (pOther 2) â‰¡ b;
assert âŠ¢ propD ctx (pOther 3) â‰¡ not_found;

open Stdlib.Bool;

//FIXME: remove sequential by covering all the case
sequential symbol prop_eq (l r: prop): Ï„ bool;
rule prop_eq pTrue pTrue â†ª true
with prop_eq pFalse pFalse â†ª true
with prop_eq (pAnd $a $b) (pAnd $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pOr $a $b) (pOr $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pImpl $a $b) (pImpl $c $d) â†ª (prop_eq $a $c) and (prop_eq $b $d)
with prop_eq (pOther $i) (pOther $j) â†ª (eqn $i $j)
with prop_eq $x $y â†ª false;

assert âŠ¢ prop_eq (pOr (pOther 0) (pOther 1)) (pOr (pOther 0) (pOther 1)) â‰¡ true;
assert âŠ¢ prop_eq (pOr (pOther 0) (pOther 1)) (pOr (pOther 1) (pOther 0)) â‰¡ false;

// Decidable equality on terms
opaque symbol prop_eq_sound (a b: prop): Ï€ (istrue (prop_eq a b)) â†’ Ï€ (a = b)  â‰”
begin
    induction
    { induction { reflexivity } { assume H; apply âŠ¥â‚‘ H; } { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 }  { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 } { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 }  { assume idx H;  apply âŠ¥â‚‘ H } } 
    { induction { assume H; apply âŠ¥â‚‘ H; } { reflexivity }  { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 }  { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 } { assume b' H c' H2 H3; apply âŠ¥â‚‘ H3 }  { assume idx H;  apply âŠ¥â‚‘ H } } 
    {
        assume a' H b' H2;
        //assume c Hc;
        induction
        {assume H3; apply âŠ¥â‚‘ H3; }
        {assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2' H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        //{ assume x H3 H4; apply âŠ¥â‚‘ H4 }
        { assume i;  assume H3; apply âŠ¥â‚‘ H3; }
    }
    {
        assume a' H b' H2;
        induction
        {assume H3; apply âŠ¥â‚‘ H3; }
        {assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2' H3; apply âŠ¥â‚‘ H3 }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        //{ assume x H3 H4; apply âŠ¥â‚‘ H4 }
        { assume i;  assume H3; apply âŠ¥â‚‘ H3; }
    }
    {
        assume a' H b' H2;
        induction
        {assume H3; apply âŠ¥â‚‘ H3; }
        {assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
        { assume c' H' d' H2' H3; apply âŠ¥â‚‘ H3 }
        //{ assume x H3 H4; apply âŠ¥â‚‘ H4 }
        { assume i;  assume H3; apply âŠ¥â‚‘ H3; }
    }
    // {
    //     assume x H;
    //     induction
    //     { assume H2; apply âŠ¥â‚‘ H2 }
    //     { assume H2; apply âŠ¥â‚‘ H2 }
    //     { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
    //     { assume c' H' d' H2';  assume H3; apply âŠ¥â‚‘ H3; }
    //     { assume c' H' d' H2' H3; apply âŠ¥â‚‘ H3 }
    //     { assume x' H3 H4; apply âŠ¥â‚‘ H4  }
    //     { assume x' H2; apply âŠ¥â‚‘ H2 }
    // }
    {
        assume i;
        induction
        { assume H; apply âŠ¥â‚‘ H;  }
        { assume H; apply âŠ¥â‚‘ H;  }
        { assume x; assume H x' H2 Hbot; apply âŠ¥â‚‘ Hbot; }
        { assume x; assume H x' H2 Hbot; apply âŠ¥â‚‘ Hbot; }
        { assume x; assume H x' H2 Hbot; apply âŠ¥â‚‘ Hbot; }
        //{ assume x H3 H4; apply âŠ¥â‚‘ H4 }
        {
            assume j;
            assume H;
            rewrite (eqn_correct i j H);
            reflexivity  
        }
    }
end;

symbol knows (p: prop) (c: ğ•ƒ propS): ğ”¹ â‰” âˆˆ prop_eq p c;

sequential symbol learn (p: prop) (c: ğ•ƒ propS) : ğ•ƒ propS;
rule learn pTrue $c â†ª $c
with learn pFalse $c â†ª pFalse â¸¬ â–¡
with learn (pAnd $l $r) $c â†ª learn $l (learn $r $c)
with learn $p $c â†ª $p â¸¬ $c; //HACK: for simplicity

symbol provable (goal: prop) (known: ğ•ƒ propS) : ğ”¹;
rule provable pTrue _ â†ª true
with provable pFalse $known â†ª knows pFalse $known
// with provable (pNot pTrue) $known â†ª false
// with provable (pNot pFalse) $known â†ª true
// with provable (pNot (pAnd $l $r)) $known â†ª not ((provable $l $known) and (provable $r $known))
// with provable (pNot (pOr $l $r)) $known â†ª not (provable $l $known) or (provable $r $known)
// with provable (pNot (pImpl $l $r)) $known â†ª not (provable $r (learn $l $known))
// with provable (pNot (pNot $x)) $known â†ª not (not (provable $x $known))
// with provable (pNot (pOther $x)) $known â†ª not (provable (pOther $x) $known)
with provable (pAnd $l $r) $known â†ª (provable $l $known) and (provable $r $known)
with provable (pOr $l $r) $known â†ª (provable $l $known) or (provable $r $known)
with provable (pImpl $l $r) $known â†ª provable $r (learn $l $known)
with provable (pOther $i) $known â†ª (knows (pOther $i) $known) or (knows pFalse $known);

assertnot âŠ¢ provable (pAnd (pOther 0) pFalse) ((pOther 0) â¸¬ â–¡) â‰¡ true;
assert âŠ¢ provable (pAnd (pOther 0) pTrue) ((pOther 0) â¸¬ â–¡) â‰¡ true;

symbol foldr [a b: Set] : (Ï„ a â†’ Ï„ b â†’ Ï„ b) â†’ Ï„ b â†’ ğ•ƒ a â†’ Ï„ b;
rule foldr $f $z â–¡ â†ª $z
with foldr $f $z ($x â¸¬ $xs) â†ª $f $x (foldr $f $z $xs);

symbol All: ğ•ƒ propS â†’ prop â‰” foldr (pAnd) pTrue;

symbol I: Ï€ âŠ¤;

opaque symbol learn_sound (ctx: ğ•ƒ o) (p: prop) (c: ğ•ƒ propS): Ï€ (propD ctx (All c)) â†’ Ï€ ( propD ctx p) â†’ Ï€ ( propD ctx (All (learn p c)))
â‰” begin
    assume Ïƒ;
    induction
    { assume c; assume H; assume Htop; apply H }
    { assume c; assume H H2; refine âŠ¥â‚‘ H2  }
    { assume a IH b IH2 ctx H2 H3;
        apply âˆ§áµ¢ 
        { refine  âˆ§â‚‘â‚ H3 } 
        {  apply âˆ§áµ¢ { apply âˆ§â‚‘â‚‚ H3 } { refine H2 } }
    }
    { assume a IH b IH2 ctx H2 H3; 
        apply âˆ§áµ¢ 
        { apply âˆ¨â‚‘ H3 { assume H0; apply âˆ¨áµ¢â‚; refine H0 } { assume H0; apply âˆ¨áµ¢â‚‚; refine H0 }  }
        { refine H2 }
    }
    {
        assume a IH b IH2 ctx H2 H3;
        apply âˆ§áµ¢ 
        { refine H3 }
        { refine H2 }
    }
    // {
    //     simplify;
    //     assume p H H2 H3 HD;
    //     apply âˆ§áµ¢ 
    //     { refine HD }
    //     { refine H3 }
    // }
    {
        assume i Î“ H1 H2;
        apply âˆ§áµ¢ { refine H2 } { refine H1 }
    }
end;


opaque symbol knows_sound (Ïƒ: ğ•ƒ o) (c: ğ•ƒ propS) (p: prop) : Ï€ (((knows p c) = true) â‡’ (propD Ïƒ (All c)) â‡’  (propD Ïƒ p)) â‰”
begin 
    assume Ïƒ p c;
    admit
    //admit //induction on c
    // Case â–¡ we have knows p â–¡ = true that leads to a contradiction 
    // Case x::xs
    // Assume knows p (x::xs) = true and propD Ïƒ (All (x::xs)) show propD Ïƒ p
    // By using List.in_cons we have  beq x y or âˆˆ beq x l)
end;

opaque symbol andb_true_iff [p q] : Ï€((p and q) = true) â†’ Ï€(p = true âˆ§ q = true) â‰”
begin
  induction
  { induction
    { assume h; apply âˆ§áµ¢ { reflexivity } { reflexivity } }
    { assume h; apply âŠ¥â‚‘ (falseâ‰ true  h); }
  }
  {  assume q h;  apply âŠ¥â‚‘ (falseâ‰ true  h) }
end;

opaque symbol not_and_true_iff [p q] : Ï€(not (p and q) = true) â†’ Ï€(not p = true âˆ¨ not q = true) â‰”
begin
    admit
end;

opaque symbol not_true_iff [p] : Ï€(not p = true) â†’ Ï€(p = false) â‰”
begin
    admit
end;

opaque symbol or_true_iff [p q] : Ï€((p or q) = true) â†’ Ï€(p = true âˆ¨ q = true) â‰”
begin
    induction
    { assume p H; apply âˆ¨áµ¢â‚; reflexivity }
    { assume q h;  apply âˆ¨áµ¢â‚‚; apply h }
end;

// Main theorem
opaque symbol provable_sound: Î  (goal: prop), Î   (hyps: ğ•ƒ propS),
    Ï€ (provable goal hyps = true) â†’ 
    Î  (ctx: ğ•ƒ o), Ï€ (propD ctx (All hyps)) â†’
    Ï€ (propD ctx goal) â‰”
begin
    induction
    { assume ctx H Ïƒ H2; apply I }
    { assume ctx H Ïƒ H2; apply (knows_sound Ïƒ ctx pFalse H);  apply H2 }
    { assume a IH1 b IH2 ctx' H Ïƒ H2;
        have G: Ï€ ((provable a ctx' = true) âˆ§ (provable b ctx' = true) ) {
            refine (@andb_true_iff _ _ H); 
        };
        apply âˆ§áµ¢
        { refine (IH1 ctx' (âˆ§â‚‘â‚ G)) Ïƒ H2 }
        { refine (IH2 ctx' (âˆ§â‚‘â‚‚ G)) Ïƒ H2 };
    }
    {
        assume a IH1 b IH2 ctx' H Ïƒ H2;
        have G: Ï€ ((provable a ctx' = true) âˆ¨ (provable b ctx' = true) ) {
            refine (@or_true_iff _ _ H); 
        };
        apply âˆ¨â‚‘ G
        {  assume Ga; apply âˆ¨áµ¢â‚; refine (IH1 ctx' Ga Ïƒ H2) }
        { assume Gb; apply âˆ¨áµ¢â‚‚; refine (IH2 ctx' Gb Ïƒ H2) };
    }
    {
        assume a IH1 b IH2 ctx H Ïƒ H2 Ha;
        apply (IH2 (a â¸¬ ctx) H Ïƒ);
        apply âˆ§áµ¢
        { apply Ha }
        { apply H2 }
    }
    //{
        //admit
        // induction
        // { simplify; assume IH hyps Hrefl Ïƒ HÏƒ H1; apply âŠ¥â‚‘ (falseâ‰ true Hrefl) }
        // { simplify; assume IH hyps Hrefl Ïƒ HÏƒ H1; refine H1 }
        // {
        //     simplify; assume a IHa b IHb H ctx Hrefl Ïƒ H3 Haandb;
        //     have G: Ï€ (not (provable a ctx) = true âˆ¨ not (provable b ctx) = true)
        //     {
        //         refine (@not_and_true_iff (provable a ctx) (provable b ctx) Hrefl)
        //     };
        //     apply âˆ¨â‚‘ G
        //     {
        //         simplify;
        //         assume Ha;
        //         have G2: Ï€ (provable a ctx = false) {
        //             apply not_true_iff Ha
        //         };
        //         have G3: Ï€ ((provable a ctx and provable b ctx) = true) {

        //         };
        //     }
        //     { }
        // }
        // {admit}
        // {admit}
        // {admit}
        // {admit}       
    //}
    {
       assume i hyps IH Ïƒ H2;
       have G: Ï€ ((âˆˆ prop_eq (pOther i) hyps = true)  âˆ¨ (âˆˆ prop_eq pFalse hyps = true) ) {
        refine (@or_true_iff _ _ IH); 
       };
       apply âˆ¨â‚‘ G
       { assume Gl; apply (knows_sound Ïƒ hyps (pOther i) Gl H2); }
       { assume Gr; refine (@âŠ¥â‚‘ (nth not_found Ïƒ i) (knows_sound Ïƒ hyps (pFalse) Gr H2))  }
    }
end;

opaque symbol provable_apply:  Î  (goal: prop), Ï€ (provable goal â–¡ = true) â†’ Î  (Ïƒ: ğ•ƒ o), Ï€ (propD Ïƒ goal) â‰”
begin
    assume goal H Ïƒ;
    apply provable_sound goal â–¡ H Ïƒ; apply I
end;

//HACK: Refactor
sequential symbol peq: Prop â†’ Prop â†’ ğ”¹;
rule peq $x $x â†ª true
with peq $x $y â†ª false;

sequential symbol allVars : Ï„ (list o) â†’ Prop â†’  Ï„ (list o);
rule allVars $Ïƒ âŠ¤ â†ª $Ïƒ
with allVars $Ïƒ âŠ¥ â†ª $Ïƒ
with allVars $Ïƒ (Â¬ $x) â†ª (allVars $Ïƒ $x)
with allVars $Ïƒ ($l âˆ§ $r) â†ª
    let Ïƒ' â‰” (allVars $Ïƒ $l) in 
    (allVars Ïƒ' $r)
with allVars $Ïƒ ($l âˆ¨ $r) â†ª
    let Ïƒ' â‰” (allVars $Ïƒ $l) in 
    (allVars Ïƒ' $r)
with allVars $Ïƒ ($l â‡’ $r) â†ª
    let Ïƒ' â‰” (allVars $Ïƒ $l) in 
    (allVars Ïƒ' $r)
with allVars $Ïƒ $t â†ª if (âˆˆ (peq) $t $Ïƒ) $Ïƒ ($t â¸¬ $Ïƒ)
;

assert âŠ¢ (allVars â–¡ (a âˆ§ (Â¬ b ) âˆ§ âŠ¤ âˆ§ âŠ¥ âˆ§ a âˆ¨ b)) â‰¡ b â¸¬ a â¸¬ â–¡;

sequential symbol reifybis : ğ•ƒ o  â†’  Prop â†’ prop;
rule reifybis $Ïƒ âŠ¤ â†ª pTrue
with reifybis $Ïƒ âŠ¥ â†ª pFalse
with reifybis $Ïƒ ($a âˆ§ $b) â†ª if (âˆˆ (peq) $a $Ïƒ)
                                // then
                                (pAnd (pOther (index (peq) $a $Ïƒ)) (reifybis $Ïƒ $b))
                                // else
                                (pAnd (reifybis $Ïƒ $a) (reifybis $Ïƒ $b))
with reifybis $Ïƒ ($a âˆ¨ $b) â†ª if (âˆˆ (peq) $a $Ïƒ)
                                // then
                                (pOr (pOther (index (peq) $a $Ïƒ)) (reifybis $Ïƒ $b))
                                // else
                                (pOr (reifybis $Ïƒ $a) (reifybis $Ïƒ $b))
with reifybis $Ïƒ ($a â‡’ $b) â†ª if (âˆˆ (peq) $a $Ïƒ)
                                // then
                                (pImpl (pOther (index (peq) $a $Ïƒ)) (reifybis $Ïƒ $b))
                                // else
                                (pImpl (reifybis $Ïƒ $a) (reifybis $Ïƒ $b))
with reifybis $Ïƒ $t  â†ª  pOther (index (peq) $t $Ïƒ)
;

symbol reify: Prop â†’  Ï„ propS â‰” Î» p, reifybis (allVars â–¡ p) p;

assert âŠ¢ allVars â–¡ ((a âˆ¨ (f a)) âˆ§ (a â‡’ b)) â‰¡ b â¸¬ (f a) â¸¬ a â¸¬ â–¡;

assert âŠ¢ reify (âŠ¤ âˆ§ (âŠ¤ âˆ¨ âŠ¥)) â‰¡ pAnd pTrue (pOr pTrue pFalse);
assert a b f âŠ¢ reify ((a âˆ¨ (f a)) âˆ§ (a â‡’ b)) â‰¡ pAnd (pOr (pOther 2) (pOther 1)) (pImpl (pOther 2) (pOther 0));

symbol reify_coe: Prop â†’  Ï„ propS;
rule reify_coe $p â†ª reifybis (allVars â–¡ $p) $p;

coerce_rule coerce Prop (Ï„ propS) $p â†ª reify_coe $p;

symbol inj_propD p: Ï€ (propD (allVars â–¡ p) (reify p) = p) â‰” begin reflexivity end;    


//NOTE: We do not have the tactic change in Lambdapi
constant symbol apply_reify [goal: Prop] : Ï€ (propD (allVars â–¡ goal) (reify goal)) â†’ Ï€ goal;


opaque symbol tauto : Î  (goal: Prop), Ï€ (provable (reify goal) â–¡ = true) â†’  Ï€ goal â‰”
begin admit end;

symbol example1 : Ï€ (âŠ¤ âˆ§ âŠ¤ âˆ¨ âŠ¥) â‰”
begin
    rewrite left inj_propD;
    type (provable_apply (reify ((âŠ¤ âˆ§ âŠ¤) âˆ¨ âŠ¥)) (eq_refl true) â–¡);
    apply provable_apply (reify ((âŠ¤ âˆ§ âŠ¤) âˆ¨ âŠ¥)) (eq_refl true)  â–¡ ; 
end;

 
symbol example2 p q : Ï€ (p â‡’ p âˆ§ âŠ¤ âˆ§ p âˆ¨ q) â‰”
begin
    assume p q;
    rewrite left inj_propD;
    apply tauto;
    reflexivity
end;

symbol example3 p : Ï€ (p â‡’ (p âˆ§ âŠ¥)) â‰”
begin
    assume p;
    rewrite left inj_propD;
    apply tauto;
    admit
end;
