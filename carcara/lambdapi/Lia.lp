require Stdlib.Nat as Nat;
open Stdlib.Nat;
require open Stdlib.Z Stdlib.List Stdlib.propExt;

// type for arithmetic expressions

symbol pos2nat : â„™ â†’ â„•;
rule pos2nat H â†ª  Stdlib.Nat._1
with pos2nat (O $p) â†ª Stdlib.Nat.double (pos2nat $p)
with pos2nat (I $p)  â†ª (Stdlib.Nat.double (pos2nat $p)) Stdlib.Nat.+ Stdlib.Nat._1;

symbol int2nat n : Ï€ (0 < (n + 1)) â†’ â„•;
rule int2nat Z0 _  â†ª Stdlib.Nat._0
with int2nat (Zpos $n) _  â†ª pos2nat $n;

inductive G: TYPE â‰”
| Cst: â„¤ â†’ G
| Var: â„• â†’ â„¤ â†’ G
| Add: G â†’ G â†’ G
; 

constant symbol grp : Set;
rule Ï„ grp â†ª G;

// multiplication by a constant

symbol mul: â„¤ â†’ G â†’ G;

rule mul $k (Cst $l) â†ª Cst ($k * $l)
with mul $k (Var $i $l) â†ª Var $i ($k * $l)
with mul $k (Add $x $y) â†ª Add (mul $k $x) (mul $k $y);

// opposite

symbol opp â‰” mul (â€” 1);

// highest variable index in a term

symbol varmax : G â†’ â„•;

rule varmax (Cst _) â†ª _0
with varmax (Var $k _) â†ª $k
with varmax (Add $x $y) â†ª max (varmax $x) (varmax $y);

/* evaluation of an arithmetic expression wrt a list of values for variables

variables with indexes not in the list are interpreted by 0 */

symbol nth â‰” Stdlib.List.nth 0;

symbol val: Ï„(grp Ã— list int) â†’ â„¤;

rule val (Cst $k â€š _) â†ª $k
with val (Var $i $k â€š $l) â†ª (nth $l $i) * $k
with val (Add $x $y â€š $l) â†ª val ($x â€š $l) + val ($y â€š $l);

symbol va l x â‰” val (x â€š l);

// some useful type (use inductive instead?)

constant symbol R : TYPE;
constant symbol Index : â„• â†’ R;
constant symbol New : â„• â†’ R;

symbol case [a] : R â†’ (â„• â†’ Ï„ a) â†’ (â„• â†’ Ï„ a) â†’ Ï„ a;

rule case (Index $i) $f _ â†ª $f $i
with case (New $i) _ $g â†ª $g $i;

/* index of a value in a list: returns New if the value is not
definitionally equivalent to some element of the list */

sequential symbol index: â„• â†’ Î  [a], Ï„ a â†’ Ï„(list a) â†’ R;

rule index $k _ â–¡ â†ª New $k
with index $k $x ($x â¸¬ _) â†ª Index $k
with index $k $x ($y â¸¬ $l) â†ª index ($k +1) $x $l;

/* reification: given a Lambdapi term x of type â„¤, compute an
expression in G and a list of values whose evaluation is equal to
x. WARNING: rfy is sequential. */

sequential symbol rfy: Ï„(list int) â†’ â„¤ â†’ Ï„(grp Ã— list int);

// addition
rule rfy $l ($x + $y) â†ª
  let x â‰” rfy $l $x in let y â‰” rfy (x â‚‚) $y in Add (x â‚) (y â‚) â€š (y â‚‚)

// opposite
with rfy $l (â€” $x) â†ª let x â‰” rfy $l $x in opp (x â‚) â€š (x â‚‚)

// substraction
with rfy $l ($x - $y) â†ª rfy $l ($x + â€” $y)

// constants
with rfy $l 0 â†ª Cst 0 â€š $l
with rfy $l (Zpos $k) â†ª Cst (Zpos $k) â€š $l
with rfy $l (Zneg $k) â†ª Cst (Zneg $k) â€š $l

// multiplication by a constant
with rfy $l (0 * _) â†ª Cst 0 â€š $l
with rfy $l (Zpos $k * $x) â†ª let x â‰” rfy $l $x in mul (Zpos $k) (x â‚) â€š (x â‚‚)
with rfy $l (Zneg $k * $x) â†ª let x â‰” rfy $l $x in mul (Zneg $k) (x â‚) â€š (x â‚‚)
with rfy $l ($x * Zpos $k) â†ª let x â‰” rfy $l $x in mul (Zpos $k) (x â‚) â€š (x â‚‚)
with rfy $l ($x * Zneg $k) â†ª let x â‰” rfy $l $x in mul (Zneg $k) (x â‚) â€š (x â‚‚)

// other cases are abstracted by a variable
with rfy $l $x â†ª
  case (index _0 $x $l) (Î» i, Var i 1 â€š $l) (Î» i, Var i 1 â€š ($x â¸¬ $l))
;

symbol reify â‰” rfy â–¡;

opaque symbol reify_correct x: Ï€(val(reify x) = x) â‰”
begin
induction
{reflexivity}
{reflexivity}
{reflexivity}
end;

// aliens (constants and variables) of an arithmetic expression

symbol aliens: G â†’ Ï„(list grp);

rule aliens (Cst $k) â†ª Cst $k â¸¬ â–¡
with aliens (Var $i $k) â†ª Var $i $k â¸¬ â–¡
with aliens (Add $x $y) â†ª aliens $x ++ aliens $y;

symbol isNotAdd: Ï„ grp â†’ Prop; //FIXME: replace Prop by ğ”¹

rule isNotAdd (Cst _) â†ª âŠ¤
with isNotAdd (Var _ _ ) â†ª âŠ¤
with isNotAdd (Add _ _ ) â†ª âŠ¥;

symbol no_Add : Ï„(list grp) â†’ Prop;

rule no_Add â–¡ â†ª âŠ¤
with no_Add ($g â¸¬ $gs) â†ª  isNotAdd $g âˆ§ no_Add $gs;

opaque symbol no_Add_++ ys xs : Ï€(no_Add xs â‡’ no_Add ys â‡’ no_Add(xs ++ ys)) â‰”
begin
assume ys; induction
{assume h1 h2; refine h2}
{assume x xs IH h1 h2; simplify; apply âˆ§áµ¢ {refine âˆ§â‚‘â‚ h1} {apply IH {refine âˆ§â‚‘â‚‚ h1} {refine h2}}}
end;

opaque symbol no_Add_aliens x : Ï€(no_Add (aliens x)) â‰”
begin
induction
{assume k; simplify; apply âˆ§áµ¢ âŠ¤áµ¢ âŠ¤áµ¢}
{assume i ki; simplify; apply âˆ§áµ¢ âŠ¤áµ¢ âŠ¤áµ¢}
{assume x hx y hy; simplify; apply no_Add_++ (aliens y) (aliens x) hx hy; }
end;

// ordering of natural numbers
// move to Nat
symbol compN : â„• â†’ â„• â†’ Comp;

rule compN _0 _0 â†ª Eq
with compN _0 (_ +1) â†ª Lt
with compN (_ +1) _0 â†ª Gt
with compN ($x +1) ($y +1) â†ª compN $x $y;

opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
begin
induction
{ induction
  {assume h; reflexivity}
  {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
}
{ assume x hx; induction
  {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
  {assume y hy h; apply feq (+1); apply hx y h }
}
end;

// normalization of arithmetic expressions

/*
symbol merge : Ï„(list grp) â†’ Ï„(list grp);

rule merge â–¡ â†ª â–¡
with merge ($x â¸¬ â–¡) â†ª $x â¸¬ â–¡
with merge (Cst $k â¸¬ Cst $k' â¸¬ $l) â†ª merge (Cst ($k + $k') â¸¬ $l)
with merge (Cst $k â¸¬ Var $i $ki â¸¬ $l) â†ª Cst $k â¸¬ merge (Var $i $ki â¸¬ $l)
with merge (Var $i $ki â¸¬ Var $j $kj â¸¬ $l) â†ª
  case_Comp (compN $i $j)
            (merge (Var $i ($ki + $kj) â¸¬ $l))
            (Var $i $ki â¸¬ merge (Var $j $kj â¸¬ $l))
            (Var $i $ki â¸¬ merge (Var $j $kj â¸¬ $l))
;
*/

symbol remove0 : Ï„(list grp) â†’ Ï„(list grp);

rule remove0 â–¡ â†ª â–¡
with remove0 (Cst 0 â¸¬ $l) â†ª remove0 $l
with remove0 (Cst (Zpos $k) â¸¬ $l) â†ª Cst (Zpos $k) â¸¬ remove0 $l
with remove0 (Cst (Zneg $k) â¸¬ $l) â†ª Cst (Zneg $k) â¸¬ remove0 $l
with remove0 (Var _ 0 â¸¬ $l) â†ª remove0 $l
with remove0 (Var $i (Zpos $k) â¸¬ $l) â†ª Var $i (Zpos $k) â¸¬ remove0 $l
with remove0 (Var $i (Zneg $k) â¸¬ $l) â†ª Var $i (Zneg $k) â¸¬ remove0 $l
;

symbol sum: Ï„(list grp) â†’ Ï„ grp;

rule sum â–¡ â†ª Cst 0
with sum ($x â¸¬ $l) â†ª Add $x (sum $l);

symbol vas l xs â‰” va l (sum xs);

opaque symbol remove0_correct l gs : Ï€ (no_Add gs) â†’  Ï€ (val (sum (remove0 gs) â€š l) = val (sum gs â€š l)) â‰”
begin
  assume l;
  induction // on l
  {
    reflexivity
  }
  {
    induction // on g
    {
      // Case Cst k
      induction 
      // Case Z0
      { assume gs IH H;  apply IH;  refine (âˆ§â‚‘â‚‚ H) }
      // Case Zpos
      { assume c gs IH H; simplify; rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity }
      // Case Zneg
      { assume c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity }
    }
    {
      // Case Var i k
      assume i;
      induction // on k
      {assume gs IH H;  apply IH; refine (âˆ§â‚‘â‚‚ H)} // Case Z0
      { assume c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity } // Case Zpos
      { assume c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity } // Case Zneg
    }
    {
      // Case Add g1 g2
      // That violate the invariant: no_Add gs
      simplify;
      assume g1 IHg1 g2 IHg2 gs IHg H;
      refine âŠ¥â‚‘ (âˆ§â‚‘â‚ H)
    }
  }
end;

opaque symbol case_Comp_prop [a] (p:Ï„ a â†’ Prop) eq lt gt c :
  Ï€(p eq â‡’ p lt â‡’ p gt â‡’ p (case_Comp c eq lt gt)) â‰”
begin
assume a p eq lt gt; induction
{assume peq plt pgt; refine peq}
{assume peq plt pgt; refine plt}
{assume peq plt pgt; refine pgt}
end;

symbol insert: G â†’ Ï„(list grp) â†’ Ï„(list grp);

/*
rule insert (Cst $k) (Cst $k' â¸¬ $l) â†ª Cst $k â¸¬ Cst $k' â¸¬ $l
with insert (Cst $k) (Var $i $k' â¸¬ $l) â†ª Cst $k â¸¬ Var $i $k' â¸¬ $l
with insert (Var $i $k) (Cst $k' â¸¬ $l) â†ª Cst $k' â¸¬ insert (Var $i $k) $l
with insert (Var $i $ki) (Var $j $kj â¸¬ $l) â†ª
     case_Comp (compN $i $j)
            (Var $i $ki â¸¬ Var $j $kj â¸¬ $l)
            (Var $i $ki â¸¬ Var $j $kj â¸¬ $l)
            (Var $j $kj â¸¬ insert (Var $i $ki) $l);
*/

rule insert $x â–¡ â†ª $x â¸¬ â–¡
with insert (Cst $k) (Cst $k' â¸¬ $l) â†ª Cst ($k + $k') â¸¬ $l
with insert (Cst $k) (Var $i $k' â¸¬ $l) â†ª Cst $k â¸¬ Var $i $k' â¸¬ $l
with insert (Var $i $k) (Cst $k' â¸¬ $l) â†ª Cst $k' â¸¬ insert (Var $i $k) $l
with insert (Var $i $ki) (Var $j $kj â¸¬ $l) â†ª
     case_Comp (compN $i $j)
            (Var $i ($ki + $kj) â¸¬ $l) // Eq
            (Var $i $ki â¸¬ Var $j $kj â¸¬ $l) // Lt
            (Var $j $kj â¸¬ insert (Var $i $ki) $l); // i > j

opaque symbol no_Add_insert xs y : Ï€(isNotAdd y) â†’ Ï€(no_Add xs) â†’ Ï€(no_Add(insert y xs)) â‰”
begin
induction
{ assume x h i; simplify; apply âˆ§áµ¢ { refine h } { apply âŠ¤áµ¢ } }
{ induction
  { assume k xs IH; induction
    { assume k' h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2} }
    { assume ki i h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢}
      {apply IH (Var ki i) {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}} }
    { assume x1 H1 x2 H2 h1 h2; apply âŠ¥â‚‘; refine h1}
  }
  { assume j kj xs IH; induction
    { assume k h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}}}
    { assume i ki h1 h2; simplify;
      apply case_Comp_prop no_Add (Var i (ki + kj) â¸¬ xs) (Var i ki â¸¬ (Var j kj â¸¬ xs)) (Var j kj â¸¬ insert (Var i ki) xs) (compN i j)
         {refine h2}
         {simplify; apply âˆ§áµ¢ {refine âŠ¤áµ¢}{refine h2}}
         {simplify; apply âˆ§áµ¢{apply âŠ¤áµ¢}{apply IH (Var i ki) {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}}}
    }
    { assume x1 H1 x2 H2 h1 h2; apply âŠ¥â‚‘; refine h1}
  }
  { assume x1 H1 x2 H2 xs IH y h i; apply âŠ¥â‚‘; refine âˆ§â‚‘â‚ i}
}
end;

// to be moved to Nat
opaque symbol distr*+ x y z : Ï€(x * (y + z) = x * y + x * z) â‰”
begin
admitted;

symbol insert_correct l gs g : Ï€ (no_Add (g â¸¬ gs)) â†’ Ï€ (val (sum (insert g gs) â€š l) =  val (g â€š l) +  val (sum gs â€š l)) â‰”
begin
assume l;
induction
{ reflexivity }
{
  // /assume g' gs IH g Haliens;
  induction
  {
    // Cst k
    assume k gs IH;
    induction
    // Cst k
    { assume k2 H; simplify; rewrite +_assoc; reflexivity }
    // Var i j
    {
      assume i c H;
      simplify;
      have g: Ï€ (no_Add (Var i c â¸¬ gs)) { 
        apply âˆ§áµ¢
        { refine âˆ§â‚‘â‚ H; }
        { refine âˆ§â‚‘â‚‚ (âˆ§â‚‘â‚‚ H); }
       };
      rewrite IH (Var i c) g;
      rewrite left +_assoc k (val (Var i c â€š l)) (val (sum gs â€š l));
      rewrite +_com k;
      rewrite +_assoc;
      reflexivity
    }
    // Case Add
    { assume g1 h2 g2 h4 contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ contradiction) }
  }
  {
    // Case Var i k
    assume i k gs IH;
    induction
    { assume c H; reflexivity }
    {
      assume j k2 Haliens;
      simplify insert;
      refine ind_Comp (Î» u, (compN j i) = u â‡’ val (sum (case_Comp u (Var j (k2 + k) â¸¬ gs) (Var j k2 â¸¬ (Var i k â¸¬ gs)) (Var i k â¸¬ insert (Var j k2) gs)) â€š l) = (val (Var j k2 â€š l) + val (sum (Var i k â¸¬ gs) â€š l))) _ _ _ (compN j i) _
      {
        assume Hi_eq_j;
        simplify case_Comp;
        rewrite compN_correct j i Hi_eq_j;
        simplify; rewrite distr*+; rewrite +_assoc; reflexivity
      }
      {
        assume Hcomp;
        simplify case_Comp;
        reflexivity
      }
      {
        assume Hcomp;
        simplify case_Comp;
        simplify;
        type IH (Var j k2);
        have g: Ï€ (no_Add (Var j k2 â¸¬ gs)) {
          simplify;
          apply âˆ§áµ¢
          { refine âˆ§â‚‘â‚ Haliens }
          { refine âˆ§â‚‘â‚‚ (âˆ§â‚‘â‚‚ Haliens) }
        };
        rewrite IH (Var j k2) g;
        simplify;
        set GS â‰” val (sum gs â€š l);
        rewrite left +_assoc;
        // rewrite left +_assoc (nth l i * k) (nth l j * k2) (val (sum gs â€š l));
        rewrite .[x in (x + _) = _] +_com;
        rewrite +_assoc;
        reflexivity
      }
      {reflexivity}
    }
    { assume g IH1 g' IH2 contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ contradiction) }
  }
  { assume g1  IH g2 IH2 gs H g contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ (âˆ§â‚‘â‚‚ contradiction)); }
}
end;

// to be moved to List
symbol sort: Ï„(list grp) â†’ Ï„(list grp);

rule sort â–¡ â†ª â–¡
with sort ($x â¸¬ $xs) â†ª insert $x (sort $xs);

opaque symbol no_Add_sort xs : Ï€(no_Add xs) â†’ Ï€(no_Add (sort xs)) â‰”
begin
induction
{ assume h; apply âŠ¤áµ¢ }
{ assume x xs IH h; simplify; apply no_Add_insert (sort xs) x
  {refine âˆ§â‚‘â‚ h}
  {apply IH; refine âˆ§â‚‘â‚‚ h}
}
end;

opaque symbol sort_correct l gs : Ï€(no_Add gs) â†’ Ï€ (val (sum (sort gs) â€š l) =  val (sum gs â€š l)) â‰”
begin
assume l;
induction
{ assume h; reflexivity }
{ assume g gs IH h;
  have e: Ï€(val (sum (sort gs) â€š l) = val (sum gs â€š l))
    { apply IH; apply âˆ§â‚‘â‚‚ h };
  simplify; rewrite left e; apply insert_correct l (sort gs) g;
  simplify; apply âˆ§áµ¢ { apply âˆ§â‚‘â‚ h } { apply no_Add_sort gs; apply âˆ§â‚‘â‚‚ h }
}
end;

symbol norm x â‰” sum (remove0 (sort (aliens x)));

// to be moved to Nat
opaque symbol max_leq m n1 n2 :
  Ï€ (max n1 n2 Nat.â‰¤ m â‡’ n1 Nat.â‰¤ m âˆ§ n2 Nat.â‰¤ m) â‰”
begin
assume m n1 n2 h; apply âˆ§áµ¢
{ refine @leq_trans n1 (max n1 n2) m _ _ { apply leq_maxl n1 n2 } { refine h } }
{ refine @leq_trans n2 (max n1 n2) m _ _ { apply leq_maxr n1 n2 } { refine h } }
end;

// moved to Eq
opaque symbol eq_trans [a] (x y z:Ï„ a) : Ï€(x = y â‡’ y = z â‡’ x = z) â‰”
begin
assume a x y z xy yz; rewrite xy; refine yz
end;

opaque symbol sum++ l ys xs : Ï€(val(sum(xs ++ ys) â€š l) = val(sum xs â€š l) + val(sum ys â€š l)) â‰”
begin
assume l ys; induction
{ reflexivity }
{ assume x xs IH; simplify; rewrite IH; rewrite +_assoc; reflexivity }
end;

opaque symbol aliens_correct l x : Ï€ (val (sum (aliens x) â€š l) = val (x â€š l)) â‰”
begin
assume l; induction
{assume k; reflexivity }
{assume i ki; reflexivity}
{assume x hx y hy; simplify; rewrite sum++; rewrite hx; rewrite hy; reflexivity}
end;

opaque symbol norm_correct (x: G) l :
  Ï€(varmax x Nat.â‰¤ size l) â†’ Ï€(val(norm x â€š l) = val(x â€š l)) â‰”
begin
assume x l h; simplify; apply eq_trans (val (sum (remove0 (sort (aliens x))) â€š l)) (val (sum (sort (aliens x)) â€š l)) (val (x â€š l))
{ apply remove0_correct l (sort(aliens x));
  apply no_Add_sort (aliens x); apply no_Add_aliens x }
{ apply eq_trans (val (sum (sort (aliens x)) â€š l)) (val (sum (aliens x) â€š l)) (val (x â€š l))
  { apply sort_correct l (aliens x); apply no_Add_aliens x }
  { apply aliens_correct l x}
}
end;

// move to Prod ?
symbol eta_prod [a b] (x:Ï„(a Ã— b)): Ï€(x = (x â‚) â€š (x â‚‚));

// to be moved to Comp
symbol â‰_decides_neq [x y] : Ï€ (x â‰ y â‰  Eq â‡’ x â‰  y) â‰”
begin
admitted;

symbol l1 x y : Ï€((x + y) - (x + y) â‰  1) â‰”
begin
  assume x y;
  refine â‰_decides_neq _;
  rewrite left .[z in z â‰ _] reify_correct;
  set e â‰” reify ((x + y) - (x + y));
  rewrite .[z in val z] eta_prod;
  compute e;
  rewrite left norm_correct (e â‚) (e â‚‚) _ { refine âŠ¤áµ¢ } { refine Ltâ‰ Eq }
end;

symbol â‰± : Ï„ int â†’ Ï„ int â†’ Prop â‰” Î» x y, Â¬ (x â‰¥ y);
notation â‰± infix 10;

symbol â‰_decides_ngeq [x y] : Ï€ (x â‰ y â‰  Gt âˆ§ x â‰ y â‰  Eq â‡’ x â‰± y) â‰”
begin
admitted;

require open Stdlib.propExt;

symbol Zle_not_gt n m:  Ï€ ((n â‰¤ m) = Â¬ (n > m)) â‰”
begin
assume n m;
rewrite left iff_equiv_eq;
apply âˆ§áµ¢
{
  simplify;
  assume h;
  change Ï€ (Â¬ Â¬ Â¬ istrue (isGt (n â‰ m)));
  rewrite Â¬Â¬â‚‘_eq;
  refine h
}
{
  simplify;
  assume h1 h2;
  apply h1;
  change Ï€ (Â¬ Â¬ istrue (isGt (n â‰ m)));
  rewrite Â¬Â¬â‚‘_eq;
  refine h2
}
end;

symbol Zlt_not_ge n m:  Ï€ ((n < m) = Â¬ (n â‰¥ m));
symbol Zge_not_lt : Î  n: â„¤, Î  m: â„¤, Ï€ ((n â‰¥ m) = Â¬ (n < m));
symbol Zgt_not_le : Î  n: â„¤, Î  m: â„¤, Ï€ ((n > m) = Â¬ (n â‰¤ m));
symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c * a > c * b) ;
symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c * a â‰¥ c * b);
symbol Zgt_le_succ_r a b: Ï€ (a > b) â†’ Ï€ (a â‰¥ b + 1);
symbol Zinv_lt a b: Ï€ (a < b) â†’ Ï€ (â€” a > â€” b);
symbol Zsum_geq_s a b c d : Ï€ (a â‰¥ b) â†’ Ï€ (c â‰¥ d) â†’ Ï€ (a + c â‰¥ b + d);
symbol Z_diff_geq_Z0 a b: Ï€ (a â‰¥ b) â†’ Ï€ (a - b â‰¥ 0);
symbol Z_diff_gt_Z0 a b: Ï€ (a > b) â†’ Ï€ (a - b > 0);
symbol Zgt_le_succ_r_eq a b: Ï€ ((a > b) = (a â‰¥ b + 1));
symbol Zinv_lt_eq a b: Ï€ ((a < b) = (â€” a > â€” b));
symbol Zinv_le_eq a b: Ï€ ((a â‰¤ b) = (â€” a â‰¥ â€” b));
symbol Z_diff_geq_Z0_eq a b: Ï€ ((a â‰¥ b) = (a - b â‰¥ 0));
symbol Z_diff_gt_Z0_eq a b: Ï€ ((a > b) = (a - b > 0));
symbol Z_diff_eq_Z0_eq a b: Ï€ ((a = b) = (a - b = 0));
symbol Z_eq_antisym (a b: Ï„ int):  Ï€ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));
symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€ ((Â¬ (a = b)) = Â¬ (c * a = c * b));
symbol Zmult_gt_compat_eq c a b : Ï€ (Â¬ (a > b) = Â¬ (c * a > c * b)) ;
symbol Zmult_ge_compat_eq c a b : Ï€ (Â¬ (a â‰¥ b) = Â¬ (c * a â‰¥ c * b)) ;
symbol la_mult_neg_eq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 = t3) â‡’ (t1 * t2) = (t1 * t3));
symbol la_mult_neg_lt t1 t2 t3 : Ï€ (t1 < 0) â†’ Ï€ (t2 < t3) â†’ Ï€ ((t1 * t2) > (t1 * t3));
symbol la_mult_neg_leq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 â‰¤ t3) â‡’ (t1 * t2) â‰¥ (t1 * t3));
symbol la_mult_neg_gt [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 > t3) â‡’ (t1 * t2) < (t1 * t3));
symbol la_mult_neg_ge [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 â‰¥ t3) â‡’ (t1 * t2) â‰¤ (t1 * t3));
