require Stdlib.Nat as Nat;
open Stdlib.Nat;
require open Stdlib.Z;
require open Stdlib.List;

symbol pos2nat : â„™ â†’ â„•;
rule pos2nat H â†ª  Stdlib.Nat._1
with pos2nat (O $p) â†ª Stdlib.Nat.double (pos2nat $p)
with pos2nat (I $p)  â†ª (Stdlib.Nat.double (pos2nat $p)) Stdlib.Nat.+ Stdlib.Nat._1;

symbol int2nat n : Ï€ (0 < (n + 1)) â†’ â„•;
rule int2nat Z0 _  â†ª Stdlib.Nat._0
with int2nat (Zpos $n) _  â†ª pos2nat $n;

inductive G: TYPE â‰”
| Cst: â„¤ â†’ G
| Var: â„• â†’ â„¤ â†’ G
;

symbol rec_G : Î  p0: (G â†’ Prop), (Î  x0: â„¤, Ï€ (p0 (Cst x0))) â†’ (Î  x0: â„•, Î  x2: â„¤, Ï€ (p0 (Var x0 x2))) â†’ Î  x: G, Ï€ (p0 x);

constant symbol grp : Set;
rule Ï„ grp â†ª G;

// multiplication by a constant

symbol mul: â„¤ â†’ ğ•ƒ grp â†’ ğ•ƒ grp;

rule mul $k ((Cst $l) â¸¬ $xs) â†ª Cst ($k * $l) â¸¬ (mul $k $xs)
with mul $k ((Var $i $l) â¸¬ $xs) â†ª Var $i ($k * $l) â¸¬ (mul $k $xs)
with mul _ â–¡ â†ª â–¡;

// opposite

symbol opp â‰” mul (â€” 1);


/* evaluation of an arithmetic expression wrt a list of values for variables

variables with indexes not in the list are interpreted by 0 */

symbol nth â‰” nth 0;

symbol val_grp: Ï„ grp â†’  ğ•ƒ int â†’ â„¤;
rule val_grp (Cst $k) _ â†ª $k
with val_grp (Var $i $k) $l â†ª (nth $l $i) * $k
;

symbol val: Ï„(list grp Ã— list int) â†’ â„¤;

rule val (â–¡ â€š _) â†ª 0
with val (($x â¸¬ $xs) â€š $l) â†ª (val_grp $x $l) + (val ($xs â€š $l));

symbol va l x â‰” val (x â€š l);

// some useful type (use inductive instead?)

constant symbol R : TYPE;
constant symbol Index : â„• â†’ R;
constant symbol New : â„• â†’ R;

symbol case [a] : R â†’ (â„• â†’ Ï„ a) â†’ (â„• â†’ Ï„ a) â†’ Ï„ a;

rule case (Index $i) $f _ â†ª $f $i
with case (New $i) _ $g â†ª $g $i;

/* index of a value in a list: returns New if the value is not
definitionally equivalent to some element of the list */

sequential symbol index: â„• â†’ Î  [a], Ï„ a â†’ Ï„(list a) â†’ R;

rule index $k _ â–¡ â†ª New $k
with index $k $x ($x â¸¬ _) â†ª Index $k
with index $k $x ($y â¸¬ $l) â†ª index ($k +1) $x $l;

/* reification: given a Lambdapi term x of type â„¤, compute an
expression in G and a list of values whose evaluation is equal to
x. WARNING: rfy is sequential. */

sequential symbol rfy: Ï„(list int) â†’ â„¤ â†’ Ï„(list grp Ã— list int);

// addition
rule rfy $l ($x + $y) â†ª
  let x â‰” rfy $l $x in let y â‰” rfy (x â‚‚) $y in ((x â‚) ++ (y â‚)) â€š (y â‚‚)

// opposite
with rfy $l (â€” $x) â†ª let x â‰” rfy $l $x in opp (x â‚) â€š (x â‚‚)

// substraction
with rfy $l ($x - $y) â†ª rfy $l ($x + â€” $y)

// constants
with rfy $l 0 â†ª (Cst 0 â¸¬ â–¡) â€š $l
with rfy $l (Zpos $k) â†ª (Cst (Zpos $k) â¸¬ â–¡) â€š $l
with rfy $l (Zneg $k) â†ª (Cst (Zneg $k) â¸¬ â–¡) â€š $l

// multiplication by a constant
with rfy $l (0 * _) â†ª (Cst 0 â¸¬ â–¡) â€š $l
with rfy $l (Zpos $k * $x) â†ª let x â‰” rfy $l $x in (mul (Zpos $k) (x â‚)) â€š (x â‚‚)
with rfy $l (Zneg $k * $x) â†ª let x â‰” rfy $l $x in (mul (Zneg $k) (x â‚)) â€š (x â‚‚)
with rfy $l ($x * Zpos $k) â†ª let x â‰” rfy $l $x in (mul (Zpos $k) (x â‚)) â€š (x â‚‚)
with rfy $l ($x * Zneg $k) â†ª let x â‰” rfy $l $x in (mul (Zneg $k) (x â‚)) â€š (x â‚‚)

//other cases are abstracted by a variable
with rfy $l $x â†ª
  case (index _0 $x $l) (Î» i, (Var i 1 â¸¬ â–¡) â€š $l) (Î» i, (Var i 1 â¸¬ â–¡) â€š ($l ++ ($x â¸¬ â–¡)))
;

symbol reify â‰” rfy â–¡;

symbol compN : â„• â†’ â„• â†’ Comp;

rule compN _0 _0 â†ª Eq
with compN _0 (_ +1) â†ª Lt
with compN (_ +1) _0 â†ª Gt
with compN ($x +1) ($y +1) â†ª compN $x $y;

symbol compG : G â†’ G â†’ Comp;
rule compG (Var $i $k) (Var $j $k2) â†ª compN $i $j
with compG (Var _ _) (Cst _) â†ª Gt
with compG (Cst _) (Var _ _)  â†ª Lt
with compG (Cst $c1) (Cst $c2)  â†ª $c1 â‰ $c2;


symbol split [a: Set] (l : Ï„ (list a)): Ï„(list a Ã— list a);
rule split â–¡ â†ª (â–¡ â€š â–¡)
with split ($x â¸¬ â–¡) â†ª (($x â¸¬ â–¡) â€š â–¡)
with split ($x â¸¬ $y â¸¬ $l) â†ª  
    let res â‰”  (split $l) in
        ($x â¸¬ (res â‚)) â€š ($y â¸¬ (res â‚‚));

symbol list_ind2_principle [A : Set]  :
  Î  (P : Ï„ (list A) â†’ Prop),
    Ï€ (P â–¡) â†’
    (Î  (a: Ï„ A), Ï€ (P (a â¸¬ â–¡))) â†’
    (Î  (a b : Ï„ A) (l : Ï„ (list A)), Ï€ (P l) â†’  Ï€ (P (a â¸¬ b â¸¬ l))) â†’
    Î  (l : Ï„ (list A)), Ï€ (P l);

opaque symbol ++_eq_+ l x y : Ï€ (val ((x ++ y) â€š l) =  val (x â€š l) + val (y â€š l)) â‰”
begin
assume l;
induction
{
  assume y;
  reflexivity
}
{
  assume x xs ih;
  simplify;
  assume y;
  rewrite ih y;
  rewrite +_assoc;
  reflexivity
}
end;

opaque symbol split_correct l gs : Ï€ (val (((split gs â‚) ++ (split gs â‚‚)) â€š l) = val (gs â€š l)) â‰”
begin
assume l;
refine list_ind2_principle (Î» u, (val (((split u â‚) ++ (split u â‚‚)) â€š l) = val (u â€š l))) _ _ _
{reflexivity}
{reflexivity}
{
  assume a b tl ih;
  simplify;
  rewrite left ih;
  rewrite ++_eq_+;
  rewrite ++_eq_+;
  simplify;
  rewrite left .[in x in (_ + x ) = _] +_assoc;
  rewrite  .[in x in (_ + (x + _) ) = _] +_com;
  rewrite .[in x in (_ + x ) = _] +_assoc;
  reflexivity
}
end;


symbol merge  (l1 l2 : Ï„ (list grp)): Ï„ (list grp);
rule merge â–¡ â–¡ â†ª â–¡
with merge â–¡ $l2 â†ª $l2
with merge $l1 â–¡ â†ª $l1
with merge (Cst $c1 â¸¬ $l1') (Cst $c2 â¸¬ $l2') â†ª (Cst ($c1 + $c2) â¸¬ merge $l1' $l2')
with merge (Cst $c â¸¬ $l1') (Var $i $k â¸¬ $l2') â†ª (Cst $c â¸¬ merge $l1' (Var $i $k â¸¬ $l2'))
with merge (Var $i $k â¸¬ $l1') (Cst $c â¸¬ $l2') â†ª (Cst $c â¸¬ merge (Var $i $k â¸¬ $l1') $l2')
with merge ((Var $i $k1) â¸¬ $l1') ((Var $j $k2) â¸¬ $l2') â†ª
    case_Comp (compN $i $j)
        (Var $i ($k1 + $k2) â¸¬ merge $l1' $l2')
        ((Var $i $k1) â¸¬ merge $l1' (Var $j $k2 â¸¬ $l2'))
        ((Var $j $k2) â¸¬ merge (Var $i $k1 â¸¬ $l1') $l2')
;

// to be moved to Nat
opaque symbol distr*+ x y z : Ï€(x * (y + z) = x * y + x * z) â‰”
begin
admitted;

opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
begin
induction
{ induction
  {assume h; reflexivity}
  {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
}
{ assume x hx; induction
  {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
  {assume y hy h; apply feq (+1); apply hx y h }
}
end;

opaque symbol merge_correct l g1 g2 : Ï€ (val ((merge  g1 g2) â€š l ) = val (g1 â€š l) + val (g2 â€š l)) â‰”
begin
    assume l;
    induction
    { simplify; reflexivity }
    {
      induction
      {
        assume k1 xs ih1;
        induction
        {
          reflexivity
        }
        {
          induction
          {
            assume k2 ys ih2;
            simplify; rewrite ih1;
            rewrite +_assoc;
            rewrite  left .[x in _ + x = _] +_assoc;
            rewrite +_com k2;
            rewrite  .[x in _ + x = _] +_assoc;
            rewrite left +_assoc;
            reflexivity
          }
          {
            assume i k2 ys ih2;
            simplify; rewrite ih1;
            simplify;
            rewrite left +_assoc;
            reflexivity
          }
        }
      }
      {
        assume i k1 xs ih1;
        induction
        {reflexivity}
        {
          induction
          {
            assume K ys ih2;
            simplify;
            rewrite ih2;
            simplify;
            rewrite +_com;
            rewrite +_assoc;
            rewrite +_com K;
            reflexivity
          }
          {
            assume j k2 ys ih2;
            simplify;
            refine ind_Comp (Î» u, (compN i j) = u â‡’ val (case_Comp (compN i j) (Var i (k1 + k2) â¸¬ merge xs ys) (Var i k1 â¸¬ merge xs (Var j k2 â¸¬ ys)) (Var j k2 â¸¬ merge (Var i k1 â¸¬ xs) ys) â€š l) = (((nth l i * k1) + val (xs â€š l)) + ((nth l j * k2) + val (ys â€š l)))) _ _ _ (compN i j) _
            {
              simplify;
              assume heq;
              rewrite heq;
              simplify;
              rewrite compN_correct i j heq;
              rewrite distr*+;
              rewrite ih1;
              rewrite +_assoc;              
              set XS â‰” val (xs â€š l);
              set YS â‰” val (ys â€š l);
              rewrite  left .[x in _ + x = _] +_assoc;
              rewrite .[x in _ + (x + _) = _] +_com; 
              rewrite .[x in _ + x = _] +_assoc;
              rewrite left .[x in x = _] +_assoc;
              reflexivity
            }
            {
              simplify;
              assume hlt;
              rewrite hlt;
              simplify;
              rewrite ih1;
              simplify;
              rewrite +_assoc;
              rewrite left +_assoc;
              reflexivity
            }
            {
              assume hgt;
              rewrite hgt;
              simplify;
              rewrite ih2;
              simplify;
              rewrite +_com;
              rewrite +_assoc;
              rewrite +_com (val (ys â€š l));
              reflexivity
            }
            {reflexivity}
          }
        }
      }  
  }
end;


symbol mergesort:  Ï„ (list grp) â†’  Ï„ (list grp);
rule mergesort â–¡ â†ª â–¡
with mergesort ($x â¸¬ â–¡) â†ª ($x â¸¬ â–¡)
with mergesort ($x â¸¬ $y â¸¬ $l) â†ª 
    let s â‰” split ($x â¸¬ $y â¸¬ $l) in
    let l1 â‰” s â‚ in
    let l2 â‰” s â‚‚ in
        merge (mergesort l1) (mergesort l2);


      

// print ğ•ƒ;

opaque symbol rec_ğ•ƒ : Î  [a: Set], Î  l: ğ•ƒ a, Î  p: (ğ•ƒ a â†’ Prop), Ï€ (p â–¡) â†’ (Î  x0: Ï„ a, Î  l': ğ•ƒ a, Ï€ (p (x0 â¸¬ l'))) â†’ Ï€ (p l) â‰” 
begin
  assume a l P H1 H2;
  refine @ind_ğ•ƒ a P H1 (Î» x l' ih, H2 x l') l
end;

opaque symbol case_l [a] x (l: ğ•ƒ a) n : Ï€ ((size (x â¸¬ l)) Nat.â‰¤ (n +1)) â†’ Ï€ (size l Nat.â‰¤ n) â‰”
begin
  assume a x l n;
  refine Î» x, x;
end;

opaque symbol size_split [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚) Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚) Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol size_split2 [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚‚) Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚‚) Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol mergesort_correct_aux n l g : Ï€ (size g Nat.â‰¤ n)  â†’  Ï€ (val ((mergesort g) â€š l ) = val ( g â€š l)) â‰”
begin
    induction
    {
        assume l;
        assume g h;
        type â‰¤0 (size g) h;
        rewrite size0nil g (â‰¤0 (size g) h);
        reflexivity
    }
    {
      assume n ihn l g;
      refine rec_ğ•ƒ g (Î» u, (size u Nat.â‰¤ (n +1)) â‡’ ((val ( (mergesort u) â€š l) = val ( u â€š l)))) _ _
      {
        simplify;
        reflexivity
      }
      {
        assume x g';
        refine rec_ğ•ƒ g' (Î» u, (size (x â¸¬ u) Nat.â‰¤ (n +1)) â‡’ ((val ( (mergesort (x â¸¬ u)) â€š l) = val ( (x â¸¬ u) â€š l)))) _ _
        {reflexivity}
        {
          assume y g'' inv1;
          simplify;
          rewrite (merge_correct l (mergesort (x â¸¬ ((split g'') â‚))) (mergesort (y â¸¬ ((split g'') â‚‚))));
          have tmp3x: Ï€ (istrue (size (x â¸¬ (split g'' â‚)) Nat.â‰¤ n)) {
            apply @leq_trans
            (size (split g'' â‚) +1)
            (size g'' +1)
            n
            _
            inv1;
            apply size_split g''
          };
          rewrite ihn l (x â¸¬ (split g'' â‚)) tmp3x;
          have tmp3y: Ï€ (istrue (size (y â¸¬ (split g'' â‚‚)) Nat.â‰¤ n)) {
            simplify;
            apply @leq_trans
            (size (split g'' â‚‚) +1)
            (size g'' +1)
            n
            _
            inv1;
            simplify;
            apply size_split2 g''
          };
          rewrite ihn l (y â¸¬ (split g'' â‚‚)) tmp3y;
          simplify;
          rewrite +_assoc;
          rewrite left .[x in (_ + x) = _] +_assoc;
          rewrite +_com  (val ((split g'' â‚) â€š l)) (val_grp y l);
          rewrite  +_assoc;
          rewrite left ++_eq_+ l (split g'' â‚) (split g'' â‚‚);
          rewrite split_correct;
          reflexivity
        }
      }
    }
end;

symbol mergesort_correct l g â‰” mergesort_correct_aux (size g) l g (Nat.â‰¤_refl (size g));

symbol remove0 : Ï„(list grp) â†’ Ï„(list grp);

rule remove0 â–¡ â†ª â–¡
with remove0 (Cst 0 â¸¬ $l) â†ª remove0 $l
with remove0 (Cst (Zpos $k) â¸¬ $l) â†ª Cst (Zpos $k) â¸¬ remove0 $l
with remove0 (Cst (Zneg $k) â¸¬ $l) â†ª Cst (Zneg $k) â¸¬ remove0 $l
with remove0 (Var _ 0 â¸¬ $l) â†ª remove0 $l
with remove0 (Var $i (Zpos $k) â¸¬ $l) â†ª Var $i (Zpos $k) â¸¬ remove0 $l
with remove0 (Var $i (Zneg $k) â¸¬ $l) â†ª Var $i (Zneg $k) â¸¬ remove0 $l
;

opaque symbol remove0_correct l gs : Ï€ (val ((remove0 gs) â€š l) = val (gs â€š l)) â‰”
begin
  assume l;
  induction // on l
  {
    reflexivity
  }
  {
    induction // on g
    {
      // Case Cst k
      induction 
      // Case Z0
      { assume  gs ih;  simplify; apply ih }
      // Case Zpos
      { assume c gs ih; simplify; rewrite ih; reflexivity }
      // Case Zneg
      { assume c gs ih; simplify;  rewrite ih; reflexivity }
    }
    {
      // Case Var i k
      assume i;
      induction // on k
      {assume gs ih; simplify; rewrite ih; reflexivity} // Case Z0
      { assume c gs ih; simplify; rewrite ih; reflexivity } // Case Zpos
      { assume c gs ih; simplify; rewrite ih; reflexivity } // Case Zneg
    }
  }
end;

//compute mergesort ((Var Nat._3 2) â¸¬ (Var Nat._2 2) â¸¬ (Var Nat._1 2) â¸¬ Cst 10 â¸¬ â–¡);

symbol norm_speed x â‰” (remove0 (mergesort x));

symbol varmax : ğ•ƒ grp â†’ â„•;

rule varmax ((Cst _) â¸¬ $xs) â†ª (varmax $xs)
with varmax ((Var $k _) â¸¬ $xs) â†ª max $k (varmax $xs)
with varmax â–¡ â†ª _0;

opaque symbol eq_trans [a] (x y z:Ï„ a) : Ï€(x = y â‡’ y = z â‡’ x = z) â‰”
begin
assume a x y z xy yz; rewrite xy; refine yz
end;

opaque symbol norm_correct (x: ğ•ƒ grp) l : Ï€(val((norm_speed x) â€š l) = val(x â€š l)) â‰”
begin
  assume x l; simplify; apply eq_trans (val (remove0 (mergesort x) â€š l)) (val (mergesort x â€š l)) (val (x â€š l))
  { apply remove0_correct l (mergesort x) }
  {
    apply eq_trans (val ((mergesort (x)) â€š l)) (val (( x) â€š l)) (val (x â€š l))
    {apply mergesort_correct l x}
    {reflexivity}
  }
end;

symbol â‰_decides_neq [x y] : Ï€ (x â‰ y â‰  Eq â‡’ x â‰  y) â‰”
begin
assume x y h h2;
apply h;
rewrite h2;
remove h; remove h2; remove x;
generalize y;
induction
{reflexivity}
{
  induction
  {assume x ih; simplify; rewrite left .[x in _ = x] ih; simplify; reflexivity }
  {assume x ih; simplify; rewrite left .[x in _ = x] ih; simplify; reflexivity }
  {reflexivity}
}
{
  induction
  {assume x ih; simplify; rewrite left .[x in _ = x] ih; simplify; reflexivity }
  {assume x ih; simplify; rewrite left .[x in _ = x] ih; simplify; reflexivity }
  {reflexivity}
}
end;

opaque symbol reify_correct x: Ï€(val(reify x) = x) â‰”
begin
induction
{reflexivity}
{reflexivity}
{reflexivity}
end;

opaque symbol reify_correct_withenv l x: Ï€(val(rfy l x) = x) â‰”
begin
assume l;
induction
{reflexivity}
{reflexivity}
{reflexivity}
end;

symbol eta_prod [a b] (x:Ï„(a Ã— b)): Ï€(x = (x â‚) â€š (x â‚‚));

// symbol l1 x y : Ï€(((2 * x) + y) - ((2 * x) + y) â‰  1) â‰”
// begin
//   assume x y;
//   refine â‰_decides_neq _;
//   rewrite left .[z in z â‰ _] reify_correct;
//   set e â‰” reify (((2 * x) + y) - ((2 * x) + y));
//   rewrite .[z in val z] eta_prod;
//   rewrite left norm_correct (e â‚) (e â‚‚);
//   refine Ltâ‰ Eq
// end;


require open Stdlib.PropExt;

symbol Zle_not_gt n m:  Ï€ ((n â‰¤ m) = Â¬ (n > m)) â‰”
begin
assume n m;
rewrite left iff_equiv_eq;
apply âˆ§áµ¢
{
  simplify;
  assume h;
  change Ï€ (Â¬ Â¬ Â¬ istrue (isGt (n â‰ m)));
  rewrite Â¬Â¬â‚‘_eq;
  refine h
}
{
  simplify;
  assume h1 h2;
  apply h1;
  change Ï€ (Â¬ Â¬ istrue (isGt (n â‰ m)));
  rewrite Â¬Â¬â‚‘_eq;
  refine h2
}
end;

symbol Zlt_not_ge n m:  Ï€ ((n < m) = Â¬ (n â‰¥ m)) â‰”
begin
  assume n m;
  simplify â‰¥;
  simplify rule off;
  rewrite Â¬Â¬â‚‘_eq;
  reflexivity
end;

symbol Zge_not_lt : Î  n: â„¤, Î  m: â„¤, Ï€ ((n â‰¥ m) = Â¬ (n < m)) â‰”
begin
  assume n m;
  simplify â‰¥;
  simplify rule off;
  reflexivity
end;

symbol Zgt_not_le : Î  n: â„¤, Î  m: â„¤, Ï€ ((n > m) = Â¬ (n â‰¤ m)) â‰”
begin
  assume n m;
  simplify â‰¤;
  simplify rule off;
  reflexivity
end;

symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c * a > c * b) ;

symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c * a â‰¥ c * b);

symbol Zsum_geq_s a b c d : Ï€ (a â‰¥ b) â†’ Ï€ (c â‰¥ d) â†’ Ï€ (a + c â‰¥ b + d) â‰”
begin
  assume a b c d hab hcd;
  admit
end;

symbol Zgt_le_succ_r_eq a b: Ï€ ((a > b) = (a â‰¥ b + 1)) â‰”
begin
  assume a b;
  simplify >;
  simplify rule off;
  simplify â‰¥;
  simplify rule off;
  refine feq (Â¬) _;
  rewrite left iff_equiv_eq;
  apply âˆ§áµ¢
  { admit}
  { admit }
end;


symbol Zinv_lt_eq a b: Ï€ ((a < b) = (â€” a > â€” b)) â‰”
begin
  assume a b; rewrite left iff_equiv_eq; generalize a;
  admit
end;


symbol Zinv_le_eq a b: Ï€ ((a â‰¤ b) = (â€” a â‰¥ â€” b));
symbol Z_diff_geq_Z0_eq a b: Ï€ ((a â‰¥ b) = (a - b â‰¥ 0));
symbol Z_diff_gt_Z0_eq a b: Ï€ ((a > b) = (a - b > 0));

symbol Z_diff_eq_Z0_eq a b: Ï€ ((a = b) = (a - b = 0)) â‰”
begin
  assume a b;
  rewrite left iff_equiv_eq;
  apply âˆ§áµ¢
  {
    assume h; rewrite h; simplify;
    apply -_same b;
  }
  {
      assume h;
      have g: Ï€ (((a - b) + b) = (0 + b)) { refine =_add_compat (a - b) 0 b h };
      have g2: Ï€ ((a + (â€” b + b)) = b) { rewrite left +_assoc; refine g };
      have g3: Ï€ ((a + 0) = b) { rewrite left -_same b; rewrite +_com b (â€” b); refine g2 };
      refine g3
    }
end;

//FIXME:
symbol Z_eq_antisym (a b: Ï„ int):  Ï€ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));

symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€ ((Â¬ (a = b)) = Â¬ (c * a = c * b)) â‰”
begin
 assume c a b;
 apply feq (Â¬);
 rewrite left iff_equiv_eq;
 apply âˆ§áµ¢
  { assume heq; rewrite heq; reflexivity }
  {
    assume h;
    have g2: Ï€ ((c * a) - (c * b) = 0) { rewrite h; simplify;  rewrite -_same (c * b); reflexivity };
    have g3: Ï€ (c * (a - b) = 0) { simplify;  rewrite *_distr_+; rewrite left neg_mul_r; refine g2 };
    admit
  }
end;

symbol Zmult_gt_compat_eq c a b : Ï€ (Â¬ (a > b) = Â¬ (c * a > c * b)) ;
symbol Zmult_ge_compat_eq c a b : Ï€ (Â¬ (a â‰¥ b) = Â¬ (c * a â‰¥ c * b)) ;

// symbol la_mult_neg_eq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 = t3) â‡’ (t1 * t2) = (t1 * t3));
// symbol la_mult_neg_lt t1 t2 t3 : Ï€ (t1 < 0) â†’ Ï€ (t2 < t3) â†’ Ï€ ((t1 * t2) > (t1 * t3));
// symbol la_mult_neg_leq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 â‰¤ t3) â‡’ (t1 * t2) â‰¥ (t1 * t3));
// symbol la_mult_neg_gt [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 > t3) â‡’ (t1 * t2) < (t1 * t3));
// symbol la_mult_neg_ge [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 â‰¥ t3) â‡’ (t1 * t2) â‰¤ (t1 * t3));

symbol foo (X : Ï„ int) :  Ï€ ((â€” _1 * (â€” _1 + X)) = (_1 + (â€” _1 * X))) â‰”
begin
  assume X;
  rewrite left  .[x in x = _] reify_correct;
  rewrite left  .[x in _ = x] reify_correct;
  set l â‰” (reify ((â€” 1) * ((â€” 1) + (X))));
  set r â‰” (reify (1 + ((â€” 1) * (X))));
  rewrite .[x in val x = _] eta_prod;
  rewrite .[x in _ = val x] eta_prod;
  rewrite left  norm_correct ((l â‚)) ((l â‚‚));
  rewrite left  norm_correct ((r â‚)) ((r â‚‚));
  reflexivity
end;
