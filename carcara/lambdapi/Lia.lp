require open Stdlib.Bool;
require open Stdlib.Eq;
require open Stdlib.Set;
require open Stdlib.Pos;
require open Stdlib.Prop;
require open Stdlib.Comp;
require open Stdlib.Z;
require open lambdapi.Classic;
require open lambdapi.Alethe;

symbol â‰_decides [x y: â„¤] : Ï€á¶œ ((x â‰ y)= Eq) â†’  Ï€á¶œ (x = y);

constant symbol Ring : TYPE;
symbol ring : Set;
rule Ï„ ring â†ª Ring;

associative commutative symbol add : Ring â†’ Ring â†’ Ring;
constant symbol Z : Ring;
//symbol opp : Ring â†’ Ring;
symbol const: â„¤ â†’ Ring;

symbol mul [a] : â„¤ â†’ Ï„ a â†’ Ring;

rule add Z $x â†ª $x
with add $x Z â†ª $x

// with add (opp $x) $x â†ª Z
// with add $x (opp $x) â†ª Z
// with add (opp $x) (add $x $y) â†ª $y
// with add $x (add (opp $x) $y) â†ª $y

with add (mul $k $x) (mul $l $x) â†ª mul ($k + $l) $x
with add (mul $k $x) (add (mul $l $x) $y) â†ª add (mul ($k + $l) $x) $y

with add (const $x) (const $y) â†ª (const ($x + $y))

// with opp Z â†ª Z
// with opp (opp $x) â†ª $x
// with opp (add $x $y) â†ª add (opp $x) (opp $y)

//with opp (mul $k $x) â†ª mul (~ $k) $x

with mul 0 _ â†ª Z
with mul (~ ~ $k) $a â†ª mul $k $a

with mul (Zpos H) (Zpos $x) â†ª const (Zpos $x)
with mul (Zpos H) (Zneg $x) â†ª const (Zneg $x)

with mul $c (Zpos $d Ã— $x) â†ª mul ($c Ã— Zpos $d) $x
with mul $c (Zneg $d Ã— $x) â†ª mul ($c Ã— Zneg $d) $x
with mul $c (~ $x) â†ª mul (~ $c) $x
with mul $c ($x + $y) â†ª add (mul $c $x) (mul $c $y)
;



// ====================

symbol f: Ï„ (int â¤³ int);

symbol â‰¥? : Ï„ ring â†’ Ï„ ring â†’ ğ”¹; notation â‰¥? infix 10;
symbol >? : Ï„ ring â†’ Ï„ ring â†’ ğ”¹; notation >? infix 10;

rule const $x â‰¥? const $y â†ª isGt ($x â‰ $y) Stdlib.Bool.or (isEq ($x â‰ $y));
rule const $x >? const $y â†ª isGt ($x â‰ $y);

//symbol f: Ï„ int;

// (not (= (* -1 (f 0)) (* -1 10)))
// (not (< (f 0) 5)) 
// (< (+ (* -1 (f 0)) (f 0)) (+ (* -1 10) 5))

// (not (< F 1))
// (<= F 0)


// (not (< F 1)) (<= F 0)
symbol F: Ï„ int;

sequential symbol reify [a] : Ï„ a â†’ Ring;
rule @reify int Z0 â†ª Z
with @reify int ($x + $y) â†ª add (reify $x) (reify $y)
with reify $a â†ª mul 1 $a
;

compute (reify (((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12)))) + (~ 1 Ã— F)));
compute (reify (((~ 1) Ã— F)));
compute (reify ((0 Ã— F)));
compute (reify (~ 1 Ã— (~ 1 Ã— F)));
compute (reify (~  F));
compute (reify (3 Ã— F));
compute (reify (3 Ã— 12));

symbol x: Ï„ int;
symbol y: Ï„ int;
symbol z: Ï„ int;

compute (reify (((2 Ã— x) - y + z) + ((~ x) + y - z) + (~ y + z)));


notation â‰¥ infix 10;

// Lemma Zle_not_gt n m : n <= m -> ~ n > m.
symbol Zle_not_gt n m:  Ï€á¶œ ((n â‰¤ m) = Â¬ (n > m));

symbol Zlt_not_ge n m:  Ï€á¶œ ((n < m) = Â¬ (n â‰¥ m));

// Lemma Zmult_gt_compat_r n m p : p > 0 -> n > m -> n * p > m * p.
symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c Ã— a > c Ã— b) ;

// Lemma Zmult_ge_compat_r n m p : n >= m -> p >= 0 -> n * p >= m * p.
symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c Ã— a â‰¥ c Ã— b);


symbol Zgt_le_succ_r a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a â‰¥ b + 1);

symbol Zinv_lt a b: Ï€á¶œ (a < b) â†’ Ï€á¶œ (~ a > ~ b);

symbol Zsum_geq_s [a b c d]: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (c â‰¥ d) â†’ Ï€á¶œ (a + c â‰¥ b + d);

symbol Z_diff_geq_Z0 a b: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (a - b â‰¥ 0);
symbol Z_diff_gt_Z0 a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a - b > 0);

symbol completude_lia [a b]: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (istrue ((reify a) â‰¥? (reify b)));

symbol Zgt_le_succ_r_eq a b: Ï€á¶œ ((a > b) = (a â‰¥ b + 1));

symbol Zinv_lt_eq a b: Ï€á¶œ ((a < b) = (~ a > ~ b));

symbol Z_diff_geq_Z0_eq a b: Ï€á¶œ ((a â‰¥ b) = (a - b â‰¥ 0));

symbol Z_diff_gt_Z0_eq a b: Ï€á¶œ ((a > b) = (a - b > 0));

//symbol Z_eq_antisym [a b: Ï„ int]: Ï€á¶œ (a = b) â†’ Ï€á¶œ ((a â‰¤ b) âˆ§á¶œ (a â‰¥ b));

//Axioms
symbol Z_eq_antisym (a b: Ï„ int):  Ï€á¶œ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));

symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€á¶œ ((Â¬ (a = b)) = Â¬ (c Ã— a = c Ã— b));
symbol Zmult_gt_compat_eq c [a b] : Ï€á¶œ (Â¬ (a > b) = Â¬ (c Ã— a > c Ã— b)) ;
symbol Zmult_ge_compat_eq c [a b] : Ï€á¶œ (Â¬ (a â‰¥ b) = Â¬ (c Ã— a â‰¥ c Ã— b)) ;

// symbol la : Ï€á¶œ ( Â¬ (F < 1) âˆ¨á¶œ (F â‰¤ 0)) â‰”
// begin
// // Step 1
// rewrite Zle_not_gt F 0;
// // Step 2
// rewrite imp_eq_or;
// apply â‡’á¶œáµ¢; assume H1;
// apply Â¬á¶œáµ¢; assume H2;
// // Step 2 bis - change x < y for -x > -y if x y âˆˆ Z
// have H1': Ï€á¶œ (~ F > ~ 1) { refine Zinv_lt F 1 H1; };
// remove H1;
// // step 3
// have H1'': Ï€á¶œ (~ F - (~ 1) > 0) { refine Z_diff_gt_Z0 (~ F) (~ 1) H1' };
// remove H1';
// // step 4
// have H1''': Ï€á¶œ ((~ F - ~ 1) â‰¥ 1) { refine Zgt_le_succ_r (~ F - ~ 1) 0 H1''; };
// remove H1'';
// have H2': Ï€á¶œ (F â‰¥ 1) { refine Zgt_le_succ_r F 0 H2; };
// // step 5
// have H: Ï€á¶œ ((~ F - ~ 1) + F â‰¥ 1 + 1) {
//     apply Zsum_geq_s (~ F - ~ 1) 1 F 1  H1''' H2';
// };
// refine completude_lia  ((~ F - ~ 1) + F) (1 + 1) H;
// end;


// // (not (< (f 5) 5))
// // (not (= (* -1 (f 5)) (* -1 12)))
// // (< (+ (f 5) (* -1 (f 5))) (+ 5 (* -1 12)))


// symbol Zgt_le_succ_r_eq a b: Ï€á¶œ ((a > b) = (a â‰¥ b + 1));

// symbol Zinv_lt_eq a b: Ï€á¶œ ((a < b) = (~ a > ~ b));


// symbol Z_diff_geq_Z0_eq a b: Ï€á¶œ ((a â‰¥ b) = (a - b â‰¥ 0));
// symbol Z_diff_gt_Z0_eq a b: Ï€á¶œ ((a > b) = (a - b > 0));


// symbol la2 : Ï€á¶œ (Â¬ (F < 5) âˆ¨á¶œ Â¬ (~ 1 Ã— F = (~ 1 Ã— 12)) âˆ¨á¶œ (F + (~ 1 Ã— F) < 5 + (~ 1 Ã— 12)) ) â‰”
// begin
// // Step 1
// rewrite .[x in _ âˆ¨á¶œ _ âˆ¨á¶œ x ] Zlt_not_ge ;
// // step 2 bis
// rewrite Zinv_lt_eq;
// // step 3
// rewrite Z_diff_geq_Z0_eq;
// rewrite Z_diff_gt_Z0_eq;
// // step 4
// rewrite Zgt_le_succ_r_eq;
// // step 2
// rewrite imp_eq_or;
// apply â‡’á¶œáµ¢; assume H1;
// rewrite imp_eq_or;
// apply â‡’á¶œáµ¢; assume H2;
// apply Â¬á¶œáµ¢; assume H3;
// have H2': Ï€á¶œ ((~ 1) Ã— (~ 1 Ã— F) = (~ 1) Ã— (~ 1 Ã— 12)) { apply feqá¶œ (Î» u, (~ 1) Ã— u) H2 }; 
// remove H2;
// have H2'': Ï€á¶œ ((~ 1) Ã— (~ 1 Ã— F) â‰¥ (~ 1) Ã— (~ 1 Ã— 12)) { apply âˆ§á¶œâ‚‘â‚‚ (Z_eq_antisym H2') };
// remove H2';
// have H: Ï€á¶œ ((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12))) â‰¥ (0 + 1) + 0) {
//     apply Zsum_geq_s (~ F - ~ 5) (0 + 1) ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12))) 0  H1 H3;
// };
// have H': Ï€á¶œ ((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12))) + ((~ 1) Ã— (~ 1 Ã— F)) â‰¥ (0 + 1) + 0 + ((~ 1) Ã— (~ 1 Ã— 12))) {
//     apply Zsum_geq_s  ((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12)))) ((0 + 1) + 0) ((~ 1) Ã— (~ 1 Ã— F)) ((~ 1) Ã— (~ 1 Ã— 12)) H H2'';
// };
// refine completude_lia  (((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12)))) + (~ 1 Ã— (~ 1 Ã— F))) (((0 + 1) + 0) + (~ 1 Ã— (~ 1 Ã— 12))) H';
// end;


// // (not (= (* -1 (f 0)) (* -1 10)))
// // (not (< (f 0) 5)) 
// // (< (+ (* -1 (f 0)) (f 0)) (+ (* -1 10) 5))
// symbol la3 : Ï€á¶œ (Â¬ ((~ 1) Ã— F = (~ 1 Ã— 10)) âˆ¨á¶œ Â¬ (F < 5) âˆ¨á¶œ ((~ 1 Ã— F) + F < (~ 1 Ã— 10) + 5)) â‰”
// begin
// // step 1
// rewrite .[x in _ âˆ¨á¶œ _ âˆ¨á¶œ x ] Zlt_not_ge ;
// // step 2
// rewrite Zinv_lt_eq;
// // step 3
// rewrite Z_diff_geq_Z0_eq;
// rewrite Z_diff_gt_Z0_eq;
// // step 4
// rewrite Zgt_le_succ_r_eq;
// rewrite imp_eq_or;
// apply â‡’á¶œáµ¢; assume H1;
// rewrite imp_eq_or;
// apply â‡’á¶œáµ¢; assume H2;
// apply Â¬á¶œáµ¢; assume H3;
// have H1': Ï€á¶œ ((~ 1) Ã— (~ 1 Ã— F) = (~ 1) Ã— (~ 1 Ã— 10)) { apply feqá¶œ (Î» u, (~ 1) Ã— u) H1 };
// remove H1;
// have H1'': Ï€á¶œ ((~ 1) Ã— (~ 1 Ã— F) â‰¥ (~ 1) Ã— (~ 1 Ã— 10)) { apply âˆ§á¶œâ‚‘â‚‚ (Z_eq_antisym H1') };
// remove H1';
// set foo â‰” (~ F - ~ 5) + (((~ 1 Ã— F) + F) - ((~ 
// 1 Ã— 10) + 5));
// have Hsum: Ï€á¶œ (foo â‰¥ 1) {
//     apply Zsum_geq_s (~ F - ~ 5) (0 + 1) (((~ 1 Ã— F) + F) - ((~ 1 Ã— 10) + 5)) 0  H2 H3;
// };
// have Hsum2: Ï€á¶œ (foo + (~ 1 Ã— (~ 1 Ã— F)) â‰¥ 1 + (~ 1 Ã— (~ 1 Ã— 10))) {
//     apply Zsum_geq_s foo 1 (~ 1 Ã— (~ 1 Ã— F)) (~ 1 Ã— (~ 1 Ã— 10))  Hsum H1'';
// };
// refine completude_lia  (foo + (~ 1 Ã— (~ 1 Ã— F))) (1 + (~ 1 Ã— (~ 1 Ã— 10))) Hsum2;
// end;

opaque >;
opaque <;

symbol la4 : Ï€á¶œ (Â¬ ((~ 1) Ã— F = (~ 1 Ã— 10)) âˆ¨á¶œ Â¬ (F < 5) âˆ¨á¶œ ((~ 1 Ã— F) + F < (~ 1 Ã— 10) + 5)) â‰”
begin
// step 1
rewrite .[x in _ âˆ¨á¶œ _ âˆ¨á¶œ x ] Zlt_not_ge ;
// step 2
rewrite Zinv_lt_eq;
// step 3
rewrite Z_diff_geq_Z0_eq;
rewrite Z_diff_gt_Z0_eq;
// step 4
rewrite Zgt_le_succ_r_eq;
// step 5
rewrite .[x in x âˆ¨á¶œ _ âˆ¨á¶œ _ ]  (Zmult_eq_compat_eq (~ 1) (~ 1 Ã— F) (~ 1 Ã— 10));
rewrite .[x in _ âˆ¨á¶œ x âˆ¨á¶œ _ ]  (@Zmult_ge_compat_eq 1 (~ F - ~ 5) (0 + 1));
rewrite .[x in _ âˆ¨á¶œ _ âˆ¨á¶œ x ]  (@Zmult_ge_compat_eq 1 (((~ 1 Ã— F) + F) - ((~ 1 Ã— 10) + 5)) 0);
rewrite Z_eq_antisym;
//step 2
rewrite imp_eq_or;
apply â‡’á¶œáµ¢; assume H1;
rewrite imp_eq_or;
apply â‡’á¶œáµ¢; assume H2;
apply Â¬á¶œáµ¢; assume H3;
set H1l â‰” (~ 1 Ã— (~ 1 Ã— F));
set H1r â‰” (~ 1 Ã— (~ 1 Ã— 10));
set H2l â‰” (1 Ã— (~ F - ~ 5));
set H2r â‰” ((0 + 1));
set H3l â‰” (1 Ã— (((~ 1 Ã— F) + F) - ((~ 1 Ã— 10) + 5)));
set H3r â‰” (0);
//step 5
have Hsum: Ï€á¶œ (H1l + H2l + H3l â‰¥ H1r + H2r + H3r) {
    apply Zsum_geq_s (Zsum_geq_s H1 H2) H3;
};
refine @completude_lia (H1l + H2l + H3l) (H1r + H2r + H3r)  Hsum;
end;


compute reify (1 Ã— (~ F - ~ 5));