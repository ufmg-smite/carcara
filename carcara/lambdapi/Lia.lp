require open Stdlib.Bool;
require open Stdlib.Eq;
require open Stdlib.Set;
require open Stdlib.Pos;
require open Stdlib.Prop;
require open Stdlib.Comp;
require open Stdlib.Z;
require open lambdapi.Classic;
require open lambdapi.Alethe;

symbol â‰_decides [x y: â„¤] : Ï€á¶œ ((x â‰ y)= Eq) â†’  Ï€á¶œ (x = y);

constant symbol Ring : TYPE;
symbol ring : Set;
rule Ï„ ring â†ª Ring;

associative commutative symbol add : Ring â†’ Ring â†’ Ring;
constant symbol Z : Ring;
//symbol opp : Ring â†’ Ring;
symbol const: â„¤ â†’ Ring;

symbol mul [a] : â„¤ â†’ Ï„ a â†’ Ring;

rule add Z $x â†ª $x
with add $x Z â†ª $x

// with add (opp $x) $x â†ª Z
// with add $x (opp $x) â†ª Z
// with add (opp $x) (add $x $y) â†ª $y
// with add $x (add (opp $x) $y) â†ª $y

with add (mul $k $x) (mul $l $x) â†ª mul ($k + $l) $x
with add (mul $k $x) (add (mul $l $x) $y) â†ª add (mul ($k + $l) $x) $y

with add (const $x) (const $y) â†ª (const ($x + $y))

// with opp Z â†ª Z
// with opp (opp $x) â†ª $x
// with opp (add $x $y) â†ª add (opp $x) (opp $y)

//with opp (mul $k $x) â†ª mul (~ $k) $x

with mul 0 _ â†ª Z
with mul (~ ~ $k) $a â†ª mul $k $a

with mul (Zpos $x) (Zpos $y) â†ª const ((Zpos $x) Ã— (Zpos $y))
with mul (Zpos $x) (Zneg $y) â†ª const ((Zpos $x) Ã— (Zneg $y))
with mul (Zneg $x) (Zpos $y) â†ª const ((Zneg $x) Ã— (Zpos $y))
with mul (Zneg $x) (Zneg $y) â†ª const ((Zneg $x) Ã— (Zneg $y))


with mul $c (Zpos $d Ã— $x) â†ª mul ($c Ã— Zpos $d) $x
with mul $c (Zneg $d Ã— $x) â†ª mul ($c Ã— Zneg $d) $x
with mul $c (~ $x) â†ª mul (~ $c) $x
with mul $c ($x + $y) â†ª add (mul $c $x) (mul $c $y)
;



// ====================

symbol f: Ï„ (int â¤³ int);

symbol â‰¥? : Ï„ ring â†’ Ï„ ring â†’ ğ”¹; notation â‰¥? infix 10;
symbol >? : Ï„ ring â†’ Ï„ ring â†’ ğ”¹; notation >? infix 10;

rule const $x â‰¥? const $y â†ª isGt ($x â‰ $y) Stdlib.Bool.or (isEq ($x â‰ $y));
rule const $x >? const $y â†ª isGt ($x â‰ $y);

//symbol f: Ï„ int;

// (not (= (* -1 (f 0)) (* -1 10)))
// (not (< (f 0) 5)) 
// (< (+ (* -1 (f 0)) (f 0)) (+ (* -1 10) 5))

// (not (< F 1))
// (<= F 0)


// (not (< F 1)) (<= F 0)
symbol F: Ï„ int;

sequential symbol reify [a] : Ï„ a â†’ Ring;
rule @reify int Z0 â†ª Z
with @reify int ($x + $y) â†ª add (reify $x) (reify $y)
with reify $a â†ª mul 1 $a
;

compute (reify (((~ F - ~ 5) + ((F + (~ 1 Ã— F)) - (5 + (~ 1 Ã— 12)))) + (~ 1 Ã— F)));
compute (reify (((~ 1) Ã— F)));
compute (reify ((0 Ã— F)));
compute (reify (~ 1 Ã— (~ 1 Ã— F)));
compute (reify (~  F));
compute (reify (3 Ã— F));
compute (reify (3 Ã— 12));

symbol x: Ï„ int;
symbol y: Ï„ int;
symbol z: Ï„ int;

compute (reify (((2 Ã— x) - y + z) + ((~ x) + y - z) + (~ y + z)));


notation â‰¥ infix 10;

// Lemma Zle_not_gt n m : n <= m -> ~ n > m.
symbol Zle_not_gt n m:  Ï€á¶œ ((n â‰¤ m) = Â¬ (n > m));

symbol Zlt_not_ge n m:  Ï€á¶œ ((n < m) = Â¬ (n â‰¥ m));

symbol Zge_not_lt : Î  n: â„¤, Î  m: â„¤, Ï€á¶œ ((n â‰¥ m) = Â¬ (n < m));

symbol Zgt_not_le : Î  n: â„¤, Î  m: â„¤, Ï€á¶œ ((n > m) = Â¬ (n â‰¤ m));

// Lemma Zmult_gt_compat_r n m p : p > 0 -> n > m -> n * p > m * p.
symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c Ã— a > c Ã— b) ;

// Lemma Zmult_ge_compat_r n m p : n >= m -> p >= 0 -> n * p >= m * p.
symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c Ã— a â‰¥ c Ã— b);

symbol Zgt_le_succ_r a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a â‰¥ b + 1);

symbol Zinv_lt a b: Ï€á¶œ (a < b) â†’ Ï€á¶œ (~ a > ~ b);

symbol Zsum_geq_s [a b c d]: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (c â‰¥ d) â†’ Ï€á¶œ (a + c â‰¥ b + d);

symbol Z_diff_geq_Z0 a b: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (a - b â‰¥ 0);
symbol Z_diff_gt_Z0 a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a - b > 0);

symbol completude_lia a b: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (istrue ((reify a) â‰¥? (reify b)));

symbol Zgt_le_succ_r_eq a b: Ï€á¶œ ((a > b) = (a â‰¥ b + 1));

symbol Zinv_lt_eq a b: Ï€á¶œ ((a < b) = (~ a > ~ b));

symbol Zinv_le_eq a b: Ï€á¶œ ((a â‰¤ b) = (~ a â‰¥ ~ b));

symbol Z_diff_geq_Z0_eq a b: Ï€á¶œ ((a â‰¥ b) = (a - b â‰¥ 0));

symbol Z_diff_gt_Z0_eq a b: Ï€á¶œ ((a > b) = (a - b > 0));

symbol Z_diff_eq_Z0_eq a b: Ï€á¶œ ((a = b) = (a - b = 0));


//symbol Z_eq_antisym [a b: Ï„ int]: Ï€á¶œ (a = b) â†’ Ï€á¶œ ((a â‰¤ b) âˆ§á¶œ (a â‰¥ b));

//Axioms
symbol Z_eq_antisym (a b: Ï„ int):  Ï€á¶œ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));

symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€á¶œ ((Â¬ (a = b)) = Â¬ (c Ã— a = c Ã— b));
symbol Zmult_gt_compat_eq c a b : Ï€á¶œ (Â¬ (a > b) = Â¬ (c Ã— a > c Ã— b)) ;
symbol Zmult_ge_compat_eq c a b : Ï€á¶œ (Â¬ (a â‰¥ b) = Â¬ (c Ã— a â‰¥ c Ã— b)) ;

opaque >;
opaque <;

symbol la4 : Ï€á¶œ (Â¬ ((~ 1) Ã— F = (~ 1 Ã— 10)) âˆ¨á¶œ Â¬ (F < 5) âˆ¨á¶œ ((~ 1 Ã— F) + F < (~ 1 Ã— 10) + 5)) â‰”
begin
// step 1
rewrite .[x in _ âˆ¨á¶œ _ âˆ¨á¶œ x ] Zlt_not_ge ;
// step 2
rewrite Zinv_lt_eq;
// step 3
rewrite Z_diff_geq_Z0_eq;
rewrite Z_diff_gt_Z0_eq;
// step 4
rewrite Zgt_le_succ_r_eq;
// step 5
rewrite (Zmult_eq_compat_eq (~ 1) (~ 1 Ã— F) (~ 1 Ã— 10));
rewrite (Zmult_ge_compat_eq 1 (~ F - ~ 5) (0 + 1));
rewrite (Zmult_ge_compat_eq 1 (((~ 1 Ã— F) + F) - ((~ 1 Ã— 10) + 5)) 0);
rewrite Z_eq_antisym;
//step 2
rewrite imp_eq_or;
apply â‡’á¶œáµ¢; assume H1;
rewrite imp_eq_or;
apply â‡’á¶œáµ¢; assume H2;
apply Â¬á¶œáµ¢; assume H3;
set H1l â‰” (~ 1 Ã— (~ 1 Ã— F));
set H1r â‰” (~ 1 Ã— (~ 1 Ã— 10));
set H2l â‰” (1 Ã— (~ F - ~ 5));
set H2r â‰” ((0 + 1));
set H3l â‰” (1 Ã— (((~ 1 Ã— F) + F) - ((~ 1 Ã— 10) + 5)));
set H3r â‰” (0);
//step 5
have Hsum: Ï€á¶œ (H1l + H2l + H3l â‰¥ H1r + H2r + H3r) {
    apply Zsum_geq_s (Zsum_geq_s H1 H2) H3;
};
refine @completude_lia (H1l + H2l + H3l) (H1r + H2r + H3r)  Hsum;
end;


compute reify (1 Ã— (~ F - ~ 5));