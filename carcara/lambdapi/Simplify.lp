require open lambdapi.Alethe;
require open lambdapi.Tactic;
require open Stdlib.List;

// Rule 71: equiv_simplify

symbol equiv_simplify1 p q : Ï€ (((Â¬ p) = Â¬ q) = (p = q)) â‰”
begin
    assume p q;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        assume Heq;
        apply prop_ext; 
        apply âˆ§áµ¢
        {
            rewrite left imp_eq_or;
            rewrite Heq;
            rewrite âˆ¨_com;
            apply em
        }
        {
            rewrite left imp_eq_or;
            rewrite left Heq;
            rewrite âˆ¨_com;
            apply em
        }
    }
    {
        assume Heq;
        rewrite Heq;
        reflexivity
    }
end;

symbol equiv_simplify2  (p : Ï„ o) : Ï€ ((p = p) = âŠ¤) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; remove H; apply âŠ¤áµ¢  }
    { assume HâŠ¤; remove HâŠ¤; reflexivity }
end;

// (ğœ‘ â‰ˆ Â¬ ğœ‘) â‡’ âŠ¥
symbol equiv_simplify3 p : Ï€ ((p = (Â¬ p)) = âŠ¥) â‰”
begin
    assume p;
    apply prop_ext;
    rewrite left iff_equiv_eq;
    simplify;
    rewrite left imp_eq_or;
    rewrite left imp_eq_or;
    rewrite left imp_eq_or;
    rewrite left imp_eq_or;
    apply âˆ§áµ¢
    {
        rewrite or_identity_r;
        rewrite or_identity_r;
        rewrite morgan1;
        rewrite .[Â¬ ((Â¬ (Â¬ p)) âˆ¨ p)] morgan2;
        rewrite distributive_or;
        rewrite or_idempotent;
        apply âˆ§áµ¢
        {
            apply em
        }
        {
            rewrite âˆ¨_com;
            apply em
        };
    }
    {   
        assume contra;
        refine âŠ¥â‚‘ contra
    }
end;

// (Â¬ ğœ‘ â‰ˆ ğœ‘) â‡’ âŠ¥
symbol equiv_simplify4 p : Ï€ (((Â¬ p) = p) = âŠ¥) â‰”
begin
    assume p;
    rewrite =_sym (Â¬ p) p;
    apply equiv_simplify3
end;

//(âŠ¤ â‰ˆ ğœ‘) â‡’ ğœ‘
symbol equiv_simplify5 p : Ï€ ((âŠ¤ = p) = p) â‰”
begin
    assume p;
    apply prop_ext;
    rewrite left iff_equiv_eq;
    apply âˆ§áµ¢
    {
        assume H;
        have H2: Ï€ (âŠ¤ â‡’ p) { apply âˆ§â‚‘â‚ H };
        apply H2;
        apply âŠ¤áµ¢
    }
    {
        assume Hp;
        apply âˆ§áµ¢
        { assume Htop; apply Hp }
        { assume Hp'; apply âŠ¤áµ¢ }
    }
end;


// (ğœ‘ â‰ˆ âŠ¤) â‡’ ğœ‘
symbol equiv_simplify6 p : Ï€ ((p = âŠ¤) = p) â‰”
begin
    assume p;
    rewrite =_sym p âŠ¤;
    apply equiv_simplify5
end;

// (âŠ¥ â‰ˆ ğœ‘) â‡’ Â¬ ğœ‘
symbol equiv_simplify7 p : Ï€ ((âŠ¥ = p) = Â¬ p) â‰”
begin
    assume p;
    apply prop_ext;
    rewrite left iff_equiv_eq;
    simplify;
    apply âˆ§áµ¢
    { assume h; refine âˆ§â‚‘â‚‚ h }
    { assume h; apply âˆ§áµ¢ { assume contra; refine âŠ¥â‚‘ contra } { refine h } }
end;

// (ğœ‘ â‰ˆ âŠ¥) â‡’ Â¬ ğœ‘
symbol equiv_simplify8 p : Ï€ ((p = âŠ¥) = Â¬ p) â‰”
begin
    assume p;
    rewrite =_sym  p âŠ¥;
    apply equiv_simplify7
end;

symbol all_equiv_simplify â‰” 
    (#rewrite equiv_simplify1) â¸¬ (#rewrite equiv_simplify2) â¸¬ (#rewrite equiv_simplify3)
    â¸¬ (#rewrite equiv_simplify4) â¸¬(#rewrite equiv_simplify5) â¸¬ (#rewrite equiv_simplify6) â¸¬ (#rewrite equiv_simplify7) â¸¬  (#rewrite equiv_simplify8) â¸¬  â–¡;

symbol equiv_simplify â‰” #repeat (applyAny all_equiv_simplify) and #try (#reflexivity #orelse (#apply âŠ¤áµ¢));


// Rule 69: not_simplify

opaque symbol not_simplify1 t : Ï€ ((Â¬ Â¬ t) = t) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        rewrite nnpp_eq;
        assume Ht;
        apply Ht
    }
    {
        rewrite nnpp_eq;
        assume Ht;
        apply Ht
    }
end;

opaque symbol not_simplify2 : Ï€ (Â¬ âŠ¥ = âŠ¤) â‰”
begin
    simplify;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; apply âŠ¤áµ¢ }
    { assume Htop Hbot; refine Hbot }
end;

opaque symbol not_simplify3 : Ï€ (Â¬ âŠ¤ = âŠ¥) â‰”
begin
    simplify;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; apply fold_â‡’ H; apply âŠ¤áµ¢ }
    { assume Hbot; apply âŠ¥â‚‘; refine Hbot }
end;

symbol all_not_simplify â‰” (#rewrite not_simplify1) â¸¬ (#rewrite not_simplify2) â¸¬ (#rewrite not_simplify3) â¸¬ â–¡;

symbol not_simplify â‰” #repeat (applyAny all_not_simplify) and #try (#reflexivity #orelse (#apply âŠ¤áµ¢));

private symbol not_simplify_test : Ï€ ((Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ âŠ¤) = (Â¬ âŠ¥)) â‰” begin
eval not_simplify;
end;

// Rule 70: implies_simplify

opaque symbol implies_simplify1 p q : Ï€ ((Â¬ p â‡’ Â¬ q) = (q â‡’ p)) â‰”
begin
    assume p q;
    apply prop_ext;
    apply âˆ§áµ¢
    { 
        assume H; rewrite left imp_eq_or;
        have H1: Ï€ ((Â¬ Â¬ p) âˆ¨ Â¬ q) { rewrite imp_eq_or; refine H };
        apply âˆ¨â‚‘ H1
        { assume Hnnp;  apply âˆ¨áµ¢â‚‚; apply Â¬Â¬â‚‘; refine Hnnp }
        { assume Hnq;  apply âˆ¨áµ¢â‚; refine Hnq }
    }
    {
        assume H; rewrite left imp_eq_or;
        have H1: Ï€ ((Â¬ q) âˆ¨ p) { rewrite imp_eq_or; refine H };
        apply âˆ¨â‚‘ H1
        { assume Hnq;  apply âˆ¨áµ¢â‚‚; refine Hnq }
        { assume Hp;  apply âˆ¨áµ¢â‚; rewrite not_simplify1; refine Hp }
    }
end;

opaque symbol implies_simplify2 p : Ï€ ((âŠ¥ â‡’ p) = âŠ¤) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; apply âŠ¤áµ¢ }
    { assume H; rewrite left imp_eq_or; apply âˆ¨áµ¢â‚; refine neg_âŠ¥ }
end;

opaque symbol implies_simplify3 p : Ï€ ((p â‡’ âŠ¤) = âŠ¤) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; apply âŠ¤áµ¢ }
    { assume H H2; apply âŠ¤áµ¢  }
end;

opaque symbol implies_simplify4 p : Ï€ ((âŠ¤ â‡’ p) = p) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { 
        assume H;
        have H1: Ï€ âŠ¤ â†’ Ï€ p {
            refine H
        };
        apply H1;
        apply âŠ¤áµ¢
    }
    { assume H H2; apply H }
end;

opaque symbol implies_simplify5 p : Ï€ ((p â‡’ âŠ¥) = Â¬ p) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { 
        assume H;
        have H1: Ï€ p â†’ Ï€ âŠ¥ {
            refine H
        };
        refine H1
    }
    { assume H H2; apply (fold_â‡’ H) H2  }
end;

opaque symbol implies_simplify6 p : Ï€ ((p â‡’ p) = âŠ¤) â‰”
begin
    assume p;
    apply prop_ext;
    apply âˆ§áµ¢
    { 
        assume H;
        apply âŠ¤áµ¢
    }
    { assume H H2; apply H2  }
end;

opaque symbol implies_simplify7 p : Ï€ ((Â¬ p â‡’ p) = p) â‰”
begin
    assume p;
    apply prop_ext;
    rewrite left imp_eq_or;
    apply âˆ§áµ¢
    { 
        assume H;
        apply âˆ¨â‚‘ H
        { assume Hnnp; apply Â¬Â¬â‚‘; refine Hnnp }
        { assume Hp; refine Hp }
    }
    { assume Hp; apply âˆ¨áµ¢â‚‚; apply Hp }
end;

opaque symbol implies_simplify8 p : Ï€ ((p â‡’ Â¬ p) = Â¬ p) â‰”
begin
    assume p;
    apply prop_ext;
    rewrite left imp_eq_or;
    apply âˆ§áµ¢
    { 
        assume H;
        apply âˆ¨â‚‘ H
        { assume Hnp; refine Hnp }
        { assume Hnp; refine Hnp }
    }
    { assume Hnp; apply âˆ¨áµ¢â‚‚; refine Hnp }
end;

symbol all_implies_simplify â‰” 
    (#rewrite implies_simplify1) â¸¬ (#rewrite implies_simplify2) â¸¬ (#rewrite implies_simplify3)
    â¸¬ (#rewrite implies_simplify4) â¸¬(#rewrite implies_simplify5) â¸¬ (#rewrite implies_simplify6) â¸¬ (#rewrite implies_simplify7) â¸¬  (#rewrite implies_simplify8) â¸¬  â–¡;

symbol implies_simplify â‰” #repeat (applyAny all_implies_simplify) and #try (#reflexivity #orelse (#apply âŠ¤áµ¢));



// Rule 74. ite_simplify
opaque symbol ite_simplify1 a (t1 t2: Ï„ a) : Ï€ (ite âŠ¤ t1 t2 = t1) â‰”
begin
    assume a t1 t2;
    refine ite_ind âŠ¤ t1 t2 (Î» u, u = t1) _ _
    {assume h; reflexivity}
    {assume contra; refine âŠ¥â‚‘ (contra âŠ¤áµ¢)}
end;

opaque symbol ite_simplify2 a (t1 t2: Ï„ a) : Ï€ (ite âŠ¥ t1 t2 = t2) â‰”
begin
    assume a t1 t2;
    refine ite_ind âŠ¥ t1 t2 (Î» u, u = t2) _ _
    {assume h; refine âŠ¥â‚‘ h }
    {assume h; reflexivity }
end;

opaque symbol ite_simplify3 c : Ï€ ((@ite o c âŠ¤ âŠ¤) = âŠ¤) â‰”
begin
    assume c;
    refine ite_ind c âŠ¤ âŠ¤ (Î» u, u = âŠ¤) _ _
    {reflexivity}
    {reflexivity}
end;

opaque symbol ite_simplify4 a c (t1 t2: Ï„ a) : Ï€ ((ite (Â¬ c) t1 t2) = (ite c t2 t1)) â‰”
begin
    assume a c t1 t2;
    refine ite_ind (Â¬ c) t1 t2 (Î» u, u = (ite c t2 t1)) _ _
    {
        assume hnc;
        refine ite_ind (c) t2 t1 (Î» u, t1 = u) _ _
        { assume hc; refine âŠ¥â‚‘ (hnc hc) }
        { assume h; reflexivity }
    }
    {
        assume hnnc;
        refine ite_ind (c) t2 t1 (Î» u, t2 = u) _ _
        { assume hc; reflexivity }
        { assume h; refine âŠ¥â‚‘ (hnnc h) }
    }
end;

opaque symbol ite_then [a] c (t1 t2: Ï„ a) : Ï€ c â†’ Ï€ (t1 = ite c t1 t2) â‰”
begin
    assume a c t1 t2;
    assume hc;
    refine ite_ind c t1 t2 (Î» u, t1 = u) _ _
    {  reflexivity }
    { assume hnc;  refine âŠ¥â‚‘ (hnc hc) }
end;

opaque symbol ite_else [a] c (t1 t2: Ï„ a) : Ï€ (Â¬ c) â†’ Ï€ (t2 = ite c t1 t2) â‰”
begin
    assume a c t1 t2;
    assume hnc;
    refine ite_ind c t1 t2 (Î» u, t2 = u) _ _
    { assume hc;  refine âŠ¥â‚‘ (hnc hc) }
    {  reflexivity }
end;

opaque symbol ite_simplify5 a c (t1 t2 t3: Ï„ a) : Ï€ (ite c (ite c t1 t2) t3 = ite c t1 t3) â‰”
begin
    assume a c t1 t2 t3;
    refine ite_ind (c) (ite c t1 t2) t3 (Î» u, u = ite c t1 t3) _ _
    {
        assume hc;
        rewrite left ite_then c t1 t2 hc;
        rewrite left ite_then c t1 t3 hc;
        reflexivity
    }
    {
        assume hnc;
        rewrite left ite_else c t1 t3 hnc;
        reflexivity
    }
end;

opaque symbol ite_simplify6 a c (t1 t2 t3: Ï„ a) : Ï€ (ite c t1 (ite c t2 t3) = ite c t1 t3) â‰”
begin
    assume a c t1 t2 t3;
    refine ite_ind c t1 (ite c t2 t3) (Î» u, u = ite c t1 t3) _ _
    {
        assume hc;
        rewrite left ite_then c t1 t3 hc;
        reflexivity
    }
    {
        assume hnc;
        rewrite left ite_else c t1 t3 hnc;
        rewrite left ite_else c t2 t3 hnc;
        reflexivity
    }
end;

opaque symbol ite_simplify7 c : Ï€ (ite c âŠ¤ âŠ¥ = c) â‰”
begin
    assume c;
    refine ite_ind c âŠ¤ âŠ¥ (Î» u, u = c) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { simplify; assume h; refine hc }
        { assume hcc; apply âŠ¤áµ¢ }
    }
    {
        assume hnc;
        apply prop_ext;
        apply âˆ§áµ¢
        { simplify; assume h; refine âŠ¥â‚‘ h }
        { assume hc; refine hnc hc }
    }
end;

opaque symbol ite_simplify8 c : Ï€ (ite c âŠ¥ âŠ¤ = Â¬ c) â‰”
begin
    assume c;
    refine ite_ind c âŠ¥ âŠ¤ (Î» u, u = Â¬ c) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { simplify; assume h; refine âŠ¥â‚‘ h }
        { simplify; assume hnc; refine hnc hc }
    }
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { simplify; assume h; refine hc }
        { assume hcc; apply âŠ¤áµ¢ }
    }
end;

opaque symbol ite_simplify9 c t : Ï€ (ite c âŠ¤ t = (c âˆ¨ t)) â‰”
begin
    assume c t;
    refine ite_ind c âŠ¤ t (Î» u, u = (c âˆ¨ t)) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        {assume h; apply âˆ¨áµ¢â‚; refine hc }
        {assume h; apply âŠ¤áµ¢}
    }
    {
        assume hnc;
        apply prop_ext;
        apply âˆ§áµ¢
        {assume h; apply âˆ¨áµ¢â‚‚; refine h }
        {assume h; apply âˆ¨â‚‘ h { assume hc; refine âŠ¥â‚‘ (hnc hc) } { refine Î» x, x }}
    }
end;

opaque symbol ite_simplify10 c t : Ï€ ((ite c t âŠ¥) = (c âˆ§ t)) â‰”
begin
    assume c t;
    refine ite_ind c t âŠ¥ (Î» u, u = (c âˆ§ t)) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume ht; apply âˆ§áµ¢ { refine hc } { refine ht }  }
        { assume h; apply âˆ§â‚‘â‚‚ h }
    }
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume contra; refine âŠ¥â‚‘ contra }
        { assume h; refine hc _; refine âˆ§â‚‘â‚ h }
    }
end;

opaque symbol ite_simplify11 c t : Ï€ (ite c âŠ¥ t = ((Â¬ c) âˆ§ t)) â‰”
begin
    assume c t;
    refine ite_ind c âŠ¥ t (Î» u, u = ((Â¬ c) âˆ§ t)) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume hcontra; refine âŠ¥â‚‘ hcontra }
        { assume h; refine âˆ§â‚‘â‚ h _; refine hc }
    }
    {
        assume hnc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume ht; apply âˆ§áµ¢ { refine hnc } { refine ht } }
        { assume h; refine âˆ§â‚‘â‚‚ h }
    }
end;

opaque symbol ite_simplify12 c t : Ï€ (ite c t âŠ¤ = ((Â¬ c) âˆ¨ t)) â‰”
begin
    assume c t;
    refine ite_ind c t âŠ¤ (Î» u, u = ((Â¬ c) âˆ¨ t)) _ _
    {
        assume hc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume ht; apply âˆ¨áµ¢â‚‚; refine ht }
        { assume h; apply âˆ¨â‚‘ h { assume hnc; refine âŠ¥â‚‘ (hnc hc) } { refine Î» x, x } }
    }
    {
        assume hnc;
        apply prop_ext;
        apply âˆ§áµ¢
        { assume h; apply âˆ¨áµ¢â‚; refine hnc }
        {
            assume h;
            apply âˆ¨â‚‘ h
            { assume h2; apply âŠ¤áµ¢ }
            { assume h2; apply âŠ¤áµ¢ }
        }
    }
end;

symbol all_ite_simplify a â‰” 
    (#rewrite (ite_simplify1 a))
    â¸¬ (#rewrite (ite_simplify2 a))
    â¸¬ (#rewrite ite_simplify3)
    â¸¬ (#rewrite (ite_simplify4 a)) 
    â¸¬ (#rewrite (ite_simplify5 a)) 
    â¸¬ (#rewrite (ite_simplify6 a)) 
    â¸¬ (#rewrite ite_simplify7) 
    â¸¬ (#rewrite ite_simplify8) 
    â¸¬ (#rewrite ite_simplify9) 
    â¸¬ (#rewrite ite_simplify10)
    â¸¬ (#rewrite ite_simplify11)
    â¸¬  (#rewrite ite_simplify12)
    â¸¬ â–¡;

symbol ite_simplify [a] â‰” #repeat (applyAny (all_ite_simplify a)) and #try (#reflexivity #orelse (#apply âŠ¤áµ¢));

// Rule 73: ac_simp
symbol ac_simp_and â‰” #repeat (#rewrite_gen "left" "" âˆ§_assoc) and #repeat (#rewrite âˆ§_idem) and #reflexivity;
symbol ac_simp_or â‰” #repeat (#rewrite_gen "left" "" âˆ¨_assoc) and #repeat (#rewrite âˆ¨_idem) and #reflexivity;

opaque symbol eq_symm [a] [x y: Ï„ a] : Ï€Ì‡ ((x = y) = ((y = x)) âŸ‡ â–©) â‰”
begin
  assume a x y;
  apply âˆ¨áµ¢â‚;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume H; symmetry; apply H }
  { assume H; symmetry; apply H }
end;