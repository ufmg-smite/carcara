require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Set;
require open Stdlib.Eq;
require open Stdlib.Bool;
require open Stdlib.Nat;
require open lambdapi.Classic;

notation Â¬ prefix 35;

// SMT use congruence of â‡”/= so we set `=` as infix right notation
// to be able to parse term such as `a = b = c`.
notation = infix right 10;

constant symbol eq_reflá¶œ [a] (x:Ï„ a) : Ï€á¶œ (x = x);
constant symbol ind_eqá¶œ [a] [x y:Ï„ a] : Ï€á¶œ (x = y) â†’ Î  p, Ï€á¶œ (p y) â†’ Ï€á¶œ (p x);



//FIXME:
constant symbol meta-arr [p q]: (Ï€á¶œ p â†’ Ï€á¶œ q) â†’ Ï€á¶œ (p â‡’ q);

constant symbol fold_â‡’á¶œ [p q] : Ï€á¶œ (p â‡’ q) â†’ Ï€á¶œ p â†’ Ï€á¶œ q;

builtin "P"     â‰” Ï€á¶œ; // : Prop â†’ TYPE
builtin "refl"  â‰” eq_reflá¶œ; // : Î  [a] (x:T a), P(x = x)
builtin "eqind" â‰” ind_eqá¶œ; // : Î  [a] x y, P(x = y) â†’ Î  p:T a â†’ Prop, P(p y) â†’ P(p x)

opaque symbol eq_symá¶œ  [a] (x y:Ï„ a) :  Ï€á¶œ (x = y) â†’ Ï€á¶œ (y = x) â‰”
begin
  assume a x y h; symmetry; apply h
end;

symbol â¤³: Set â†’ Set â†’ Set; notation â¤³ infix right 20;
rule Ï„ ($a â¤³ $b) â†ª Ï„ $a â†’  Ï„ $b;

// testing symbols
private symbol a: Prop;
private symbol b: Prop;
private symbol c: Prop;
private symbol d: Prop;
private symbol e: Prop;

symbol o: Set;
rule Ï„ o â†ª Prop;

symbol Bool â‰” o;

// Index symbol for having a total equality function
injective symbol ğ‘° [a]: â„• â†’ Ï„ a;

symbol trivial : Ï€á¶œ âŠ¤;

symbol neg_âŠ¥ : Ï€á¶œ (Â¬ âŠ¥);

// # Clause
// Clauses are encoded with list Ã  la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

constant symbol clause: Set;
rule Ï„ clause â†ª Clause;

// Nil
symbol â–© : Clause;
// Cons
injective symbol âŸ‡: Prop â†’ Clause â†’ Clause;
notation âŸ‡ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause â†’ Clause â†’ Clause; notation ++ infix right 3;

rule â–© ++ $m â†ª $m
with ($x âŸ‡ $l) ++ $m â†ª $x âŸ‡ ($l ++ $m);

// Version similar to the one generated by Lambdapi induction tactic.
symbol ind_â„‚ : Î  p: (Clause â†’ Prop), Ï€á¶œ (p â–©) â†’ (Î  x0: Ï„ o, Î  x1: Clause, Ï€á¶œ (p x1) â†’ Ï€á¶œ (p (x0 âŸ‡ x1))) â†’ Ï€á¶œ (`âˆ€á¶œ (x: Clause), p x);

symbol ind_â„‚2 : Î  p: (Clause â†’ Prop), Ï€á¶œ (p â–©) â†’ (Î  x0: Ï„ o, Î  x1: Clause, Ï€á¶œ (p x1) â†’ Ï€á¶œ (p (x0 âŸ‡ x1))) â†’ Î  (x: Clause), Ï€á¶œ (p x);

constant symbol Clause_ind:  Î  P: (Clause â†’ Prop), Î  l,
  Ï€á¶œ (P â–©) â†’
  (Î  x: Prop, Î  l: Clause, Ï€á¶œ (P l) â†’ Ï€á¶œ (P (x âŸ‡ l))) â†’
  Ï€á¶œ (P l);

// some sanity checks
assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x âŸ‡ l ++ m â‰¡ x âŸ‡ (l ++ m);


sequential symbol âˆ¨á¶œ_to_âŸ‡_rw: Prop â†’ Clause;
rule âˆ¨á¶œ_to_âŸ‡_rw ($x âˆ¨á¶œ $y) â†ª $x âŸ‡ (âˆ¨á¶œ_to_âŸ‡_rw $y)
with âˆ¨á¶œ_to_âŸ‡_rw âŠ¥ â†ª  â–©;

sequential symbol âŸ‡_to_âˆ¨á¶œ_rw: Clause â†’ Prop;
rule âŸ‡_to_âˆ¨á¶œ_rw ($x âŸ‡ $y) â†ª $x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw $y)
with âŸ‡_to_âˆ¨á¶œ_rw â–© â†ª âŠ¥;

assert âŠ¢ âŸ‡_to_âˆ¨á¶œ_rw (a âŸ‡ b âŸ‡ â–©) â‰¡ a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥;
assert âŠ¢ âˆ¨á¶œ_to_âŸ‡_rw (a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥ âˆ¨á¶œ c âˆ¨á¶œ âŠ¥) â‰¡ (a âŸ‡ b âŸ‡ âŠ¥ âŸ‡ c âŸ‡ â–©);

injective symbol Ï€Ì‡ c: TYPE â‰” Ï€á¶œ (âŸ‡_to_âˆ¨á¶œ_rw c);

opaque symbol Ï€Ì‡â‚— [a] : Ï€Ì‡ (a âŸ‡ â–©)  â†’ Ï€á¶œ a â‰”
begin
  assume a Hcl_a;
  apply @âˆ¨á¶œâ‚‘ a âŠ¥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply âŠ¥á¶œâ‚‘ False; };
end;

// opaque injective symbol Ï€á¶œ p : TYPE â‰” Ï€á¶œ (Â¬ (Â¬ p));

// Introduction rule for Clause
// construct `p âŸ‡ q` from a clause with only `p`
opaque symbol âŸ‡áµ¢â‚ [p q] : Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp;
  apply âˆ¨á¶œâ‚‘ Hp
  { assume Hpi_p; apply âˆ¨á¶œáµ¢â‚;  apply Hpi_p }
  { assume Hbot; apply âŠ¥á¶œâ‚‘; apply Hbot }
end;

// construct `p âŸ‡ q` from a proof of `p`
opaque symbol âŸ‡áµ¢â‚' [p q] : Ï€á¶œ p â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp; apply âˆ¨á¶œáµ¢â‚; apply Hp
end;

opaque symbol âŸ‡áµ¢â‚‚ [p q] : Ï€Ì‡ q â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hq; apply âˆ¨á¶œáµ¢â‚‚; apply Hq
end;

// Elimination rule for clause
opaque symbol âŸ‡â‚‘ [p q r] : Ï€Ì‡ (p âŸ‡ q) â†’ (Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ r) â†’ (Ï€Ì‡ q â†’ Ï€Ì‡ r) â†’ Ï€Ì‡ r â‰”
begin
  assume p q r Hpq Hpr Hqr;
  apply âˆ¨á¶œâ‚‘ Hpq
  { assume Hp; apply Hpr (âˆ¨á¶œáµ¢â‚ Hp) }
  { assume Hq; apply Hqr Hq }
end;


opaque symbol ++_to_âˆ¨á¶œ a b : Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) â‡”á¶œ  ((âŸ‡_to_âˆ¨á¶œ_rw a) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) â‰”
begin
  assume a b;
  apply Clause_ind (Î» u, (âŸ‡_to_âˆ¨á¶œ_rw (u ++ b)) â‡”á¶œ  ((âŸ‡_to_âˆ¨á¶œ_rw u) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) a
    {
      apply âˆ§á¶œáµ¢
        { apply â‡’á¶œáµ¢; assume H; apply âˆ¨á¶œáµ¢â‚‚; apply H }
        {
          apply â‡’á¶œáµ¢; assume H;
          apply âˆ¨á¶œâ‚‘ H { assume HâŠ¥; apply âŠ¥á¶œâ‚‘; apply HâŠ¥ } { assume H1;  apply H1}
        }
    }
    {
      assume x l Hir;
      apply âˆ§á¶œáµ¢
      { apply â‡’á¶œáµ¢; assume H;   apply âˆ¨á¶œâ‚‘ H
        {
          assume Hx;
          apply âˆ¨á¶œáµ¢â‚;
          apply âˆ¨á¶œáµ¢â‚;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: Ï€á¶œ ((x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) â‡’á¶œ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) {

            refine âˆ§á¶œâ‚‘â‚ âˆ¨á¶œ_assoc;  //((x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) â‡’á¶œ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))
          };
          apply â‡’á¶œâ‚‘ tmp;
          apply âˆ¨á¶œâ‚‘ H
          {
            assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply Hx
          }
          {
            assume Hl_or_b;
            apply âˆ¨á¶œáµ¢â‚‚;
            have HirLeft: Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw (l ++ b) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))) {
                refine (âˆ§á¶œâ‚‘â‚ Hir);
            };
            apply â‡’á¶œâ‚‘ HirLeft;
            apply Hl++b
          }
        }
      }
      {
        apply â‡’á¶œáµ¢;
        assume H;
        apply âˆ¨á¶œâ‚‘ H {
            assume H1;
            apply âˆ¨á¶œâ‚‘ H1 {
              assume Hx;
              apply âˆ¨á¶œáµ¢â‚;
              apply Hx;
            } {
              assume H2;
              apply âˆ¨á¶œáµ¢â‚‚;
              have tmp: Ï€á¶œ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§á¶œâ‚‘â‚‚ Hir);
              };
              apply â‡’á¶œâ‚‘ tmp;
              apply âˆ¨á¶œáµ¢â‚;
              apply H2
            }
        } {
          assume H1;
          apply âˆ¨á¶œáµ¢â‚‚;
          have tmp: Ï€á¶œ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§á¶œâ‚‘â‚‚ Hir);
              };
              apply â‡’á¶œâ‚‘ tmp;
              apply âˆ¨á¶œáµ¢â‚‚;
              apply H1
        }
      }
    }
end;

constant symbol nnpp_eq p : Ï€á¶œ ((Â¬ Â¬ p) = p);

// Axiom propositional_extensionality: forall (P Q : Prop), (P <-> Q) -> P = Q.
// Ï„ o â†ª Prop
constant symbol prop_ext [p: Prop] [q: Prop]: Ï€á¶œ (p â‡”á¶œ q) â†’ Ï€á¶œ (p = q);

opaque symbol âŸº_ext [p: Prop] [q: Prop]:  Ï€á¶œ (p = q) â†’ Ï€á¶œ (p â‡”á¶œ q) â‰”
begin
  assume p q Heq;  rewrite Heq; apply â‡”á¶œ_refl
end;

opaque symbol iff_equiv_eq p q: Ï€á¶œ ((p â‡”á¶œ q) = (p = q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hiff; apply prop_ext Hiff }
  { apply â‡’á¶œáµ¢; assume Heq; rewrite Heq; apply â‡”á¶œ_refl }
end;

opaque  symbol âˆ¨á¶œ_assoc_eq x y z : Ï€á¶œ ((x âˆ¨á¶œ (y âˆ¨á¶œ z)) = ((x âˆ¨á¶œ y) âˆ¨á¶œ z)) â‰”
begin
  assume x y z;
  apply prop_ext;
  apply âˆ¨á¶œ_assoc
end;

opaque  symbol âˆ§á¶œ_assoc_eq x y z : Ï€á¶œ ((x âˆ§á¶œ (y âˆ§á¶œ z)) = ((x âˆ§á¶œ y) âˆ§á¶œ z)) â‰”
begin
  assume x y z;
  apply prop_ext;
  apply âˆ§á¶œ_assoc
end;

opaque symbol morganâ‚ p q : Ï€á¶œ ((Â¬ (p âˆ§á¶œ q)) = ((Â¬ p) âˆ¨á¶œ (Â¬ q))) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    apply  not_and_or H
  }
  {
    apply â‡’á¶œáµ¢;
    assume H;
    refine or_not_and H
  }
end;

opaque symbol morganâ‚‚ p q : Ï€á¶œ ((Â¬ (p âˆ¨á¶œ q)) = ((Â¬ p) âˆ§á¶œ (Â¬ q))) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    refine not_or_and H
  }
  {
    apply â‡’á¶œáµ¢;
    assume H;
    refine and_not_or H
  }
end;

opaque symbol distributive_or p q r : Ï€á¶œ ((p âˆ¨á¶œ (q âˆ§á¶œ r)) = ((p âˆ¨á¶œ q) âˆ§á¶œ (p âˆ¨á¶œ r))) â‰”
begin
  assume p q r;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    apply âˆ§á¶œáµ¢
    {
      apply âˆ¨á¶œâ‚‘ H
      { assume Hp; apply âˆ¨á¶œáµ¢â‚; refine Hp }
      { assume Hqr; apply âˆ¨á¶œáµ¢â‚‚; refine âˆ§á¶œâ‚‘â‚ Hqr }
    }
    {
      apply âˆ¨á¶œâ‚‘ H
      { assume Hp; apply âˆ¨á¶œáµ¢â‚; refine Hp }
      { assume Hqr; apply âˆ¨á¶œáµ¢â‚‚; refine âˆ§á¶œâ‚‘â‚‚ Hqr }
    }
  }
  {
    apply â‡’á¶œáµ¢;
    assume H;
    have H1: Ï€á¶œ (p âˆ¨á¶œ q) { apply âˆ§á¶œâ‚‘â‚ H  };
    have H2: Ï€á¶œ (p âˆ¨á¶œ r) { apply âˆ§á¶œâ‚‘â‚‚ H  };
    apply âˆ¨á¶œâ‚‘ H1
    {
        assume Hp;
        apply âˆ¨á¶œâ‚‘ H2
        {
          assume Hp';
          apply âˆ¨á¶œáµ¢â‚;
          apply Hp';
        }
        {
          assume Hr;
          apply âˆ¨á¶œáµ¢â‚;
          apply Hp;
        }
    }
    {
      assume Hq;
      apply âˆ¨á¶œâ‚‘ H2
        {
          assume Hp';
          apply âˆ¨á¶œáµ¢â‚;
          apply Hp';
        }
        {
          assume Hr;
          apply âˆ¨á¶œáµ¢â‚‚;
          apply âˆ§á¶œáµ¢
          { refine Hq }
          { refine Hr }
        }
    };
  }
end;

opaque symbol distributive_and p q r : Ï€á¶œ ((p âˆ§á¶œ (q âˆ¨á¶œ r)) = ((p âˆ§á¶œ q) âˆ¨á¶œ (p âˆ§á¶œ r))) â‰”
begin
  assume p q r;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    have Hp: Ï€á¶œ p { apply âˆ§á¶œâ‚‘â‚ H };
    have Hqorr: Ï€á¶œ (q âˆ¨á¶œ r) { apply âˆ§á¶œâ‚‘â‚‚ H };
    apply âˆ¨á¶œâ‚‘ Hqorr
    {
      assume Hq;
      apply âˆ¨á¶œáµ¢â‚;
      apply âˆ§á¶œáµ¢ { refine Hp } { refine Hq }
    }
    {
      assume Hr;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply âˆ§á¶œáµ¢ { refine Hp } { refine Hr  }
    }
  }
  {
    apply â‡’á¶œáµ¢;
    assume H;
    apply âˆ¨á¶œâ‚‘ H
    {
      assume Hpandq;
      apply âˆ§á¶œáµ¢ { refine âˆ§á¶œâ‚‘â‚ Hpandq  } { apply âˆ¨á¶œáµ¢â‚; refine âˆ§á¶œâ‚‘â‚‚ Hpandq }
    }
    {
      assume Hpandr;
      apply âˆ§á¶œáµ¢ { refine âˆ§á¶œâ‚‘â‚ Hpandr  } { apply âˆ¨á¶œáµ¢â‚‚; refine âˆ§á¶œâ‚‘â‚‚ Hpandr }
    }
  }
end;

opaque symbol and_com p q : Ï€á¶œ ((p âˆ§á¶œ q) = (q âˆ§á¶œ p)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hpq; apply âˆ§á¶œ_com Hpq }
  { apply â‡’á¶œáµ¢; assume Hqp; apply âˆ§á¶œ_com Hqp }
end;

opaque symbol or_com p q : Ï€á¶œ ((p âˆ¨á¶œ q) = (q âˆ¨á¶œ p)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hpq; apply âˆ¨á¶œ_com Hpq }
  { apply â‡’á¶œáµ¢; assume Hpq; apply âˆ¨á¶œ_com Hpq }
end;

opaque symbol or_idempotent p : Ï€á¶œ ((p âˆ¨á¶œ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume Hporp;
    apply âˆ¨á¶œâ‚‘ Hporp
    { assume Hp; refine Hp }
    { assume Hp; refine Hp }
  }
  {
    apply â‡’á¶œáµ¢;
    assume Hp;
    apply âˆ¨á¶œáµ¢â‚;
    refine Hp
  }
end;

opaque symbol and_idempotent p : Ï€á¶œ ((p âˆ§á¶œ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hpandp; apply âˆ§á¶œâ‚‘â‚ Hpandp; }
  {
    apply â‡’á¶œáµ¢;
    assume Hp;
    apply âˆ§á¶œáµ¢ { refine Hp } { refine Hp }
  }
end;

opaque symbol imp_eq_or p q: Ï€á¶œ (((Â¬ p) âˆ¨á¶œ q) =  (p â‡’á¶œ q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hor; apply or_to_imply Hor }
  { apply â‡’á¶œáµ¢; assume Himp; apply imply_to_or Himp }
end;

opaque symbol contrapos [p q] : Ï€á¶œ (p â‡’á¶œ q  â‡”á¶œ (Â¬ q â‡’á¶œ Â¬ p)) â‰”
begin
  assume p q;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume Himp;
    apply â‡’á¶œáµ¢;
    assume Hnq;
    apply Â¬á¶œáµ¢;
    assume Hp;
    have Hq: Ï€á¶œ q
    {  apply â‡’á¶œâ‚‘ Himp Hp };
    apply Â¬á¶œâ‚‘ Hnq Hq
  }
  {
    apply â‡’á¶œáµ¢;
    assume Himp;
    apply â‡’á¶œáµ¢;
    assume Hp;
    have Hor: Ï€á¶œ ((Â¬ Â¬ q) âˆ¨á¶œ Â¬ p) {
      rewrite imp_eq_or;
      apply Himp
    };
    apply âˆ¨á¶œâ‚‘ Hor
    { assume Hnnq; rewrite left  nnpp_eq; apply Hnnq }
    { assume Hnp; apply  Â¬á¶œâ‚‘ Hnp Hp }
  };
end;

opaque symbol contradiction p : (Ï€á¶œ (Â¬ p) â†’ Ï€á¶œ âŠ¥) â†’ Ï€á¶œ p â‰”
begin
  assume p Hnp;
  admit
end;

// // Hilbert epsilon operator/choice
symbol Ïµ  [a]: (Ï„ a â†’ Prop) â†’ Ï„ a; notation Ïµ quantifier;

constant symbol Ïµáµ¢ [a] x (p: Ï„ a â†’ Prop) : Ï€á¶œ (p x) â†’ Ï€á¶œ (p (Ïµ p));
constant symbol Ïµ_det [a p q]: Î  (x: Ï„ a), Ï€á¶œ ((p x) â‡”á¶œ (q x)) â†’ Ï€á¶œ (Ïµ p = Ïµ q);

opaque symbol Ïµ_to_âˆƒ [a] p: Ï€á¶œ ((`âˆƒá¶œ (x : Ï„ a),  p x) = p (`Ïµ (x : Ï„ a), p x)) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    apply âˆƒá¶œâ‚‘ _ H;
    assume x H1;
    apply Ïµáµ¢ x (Î» u, (p u)) H1;
  }
  {
    apply â‡’á¶œâ‚‘ (âˆ§á¶œâ‚‘â‚‚ (@contrapos (p (`Ïµ x, p x) ) (`âˆƒá¶œ x, p x)));
    apply â‡’á¶œáµ¢;
    assume H;
    have H1: Ï€á¶œ (`âˆ€á¶œ x, Â¬ p x) { apply (â‡’á¶œâ‚‘ (âˆ§á¶œâ‚‘â‚ (nex_forall p)) H) };
    admit
    //type âˆ€á¶œâ‚‘ (Î» u, Â¬ (p u)) H1
  }
end;

opaque symbol Ïµ_to_âˆ€ [a] p: Ï€á¶œ ((`âˆ€á¶œ (x : Ï„ a), p x) = p (`Ïµ (x : Ï„ a), (Â¬ p x))) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H;
    apply âˆ€á¶œâ‚‘ (`Ïµ x, Â¬ (p x)) H
  }
  {
    apply â‡’á¶œâ‚‘ (âˆ§á¶œâ‚‘â‚‚ (@contrapos (p (`Ïµ x, Â¬ (p x)) ) (`âˆ€á¶œ x, p x)));
    apply â‡’á¶œáµ¢;
    assume H;
    have H1: Ï€á¶œ (`âˆƒá¶œ x, Â¬ p x) { refine (â‡’á¶œâ‚‘ (âˆ§á¶œâ‚‘â‚ (nforall_ex p)) H) };
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hnpx;
    apply Ïµáµ¢ x (Î» u, Â¬ (p u)) Hnpx;
  }
end;

opaque  symbol and_identity_r x : Ï€á¶œ ((x âˆ§á¶œ âŠ¤) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hand; apply âˆ§á¶œâ‚‘â‚ Hand  }
  { apply â‡’á¶œáµ¢; assume Hx; apply âˆ§á¶œáµ¢ { refine Hx } { refine trivial } }
end;

opaque  symbol and_identity_l x : Ï€á¶œ ((âŠ¤ âˆ§á¶œ x) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hand; apply âˆ§á¶œâ‚‘â‚‚ Hand  }
  { apply â‡’á¶œáµ¢; assume Hx; apply âˆ§á¶œáµ¢ { refine trivial } { refine Hx } }
end;

opaque  symbol and_domination x : Ï€á¶œ ((x âˆ§á¶œ âŠ¥) = âŠ¥) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hand; apply âˆ§á¶œâ‚‘â‚‚ Hand  }
  { apply â‡’á¶œáµ¢; assume Hx; apply âŠ¥á¶œâ‚‘ Hx }
end;

opaque  symbol or_identity_l x : Ï€á¶œ ((âŠ¥ âˆ¨á¶œ x) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hor; apply âˆ¨á¶œâ‚‘ Hor { assume Hbot; apply âŠ¥á¶œâ‚‘; refine Hbot } { assume Hx; refine Hx }  }
  { apply â‡’á¶œáµ¢; assume Hx; apply âˆ¨á¶œáµ¢â‚‚; refine Hx }
end;

opaque  symbol or_identity_r x : Ï€á¶œ ((x âˆ¨á¶œ âŠ¥) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hor; apply âˆ¨á¶œâ‚‘ Hor { assume Hx; refine Hx } { assume Hbot; apply âŠ¥á¶œâ‚‘; refine Hbot } }
  { apply â‡’á¶œáµ¢; assume Hx; apply âˆ¨á¶œáµ¢â‚; refine Hx }
end;

opaque symbol Ïµ_equiv_âˆƒá¶œ' [a p] : Ï€á¶œ ((`âˆƒá¶œ (x: Ï„ a), p x) = (p (`Ïµ x, p x))) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume Hexist;
    apply âˆƒá¶œâ‚‘ _ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    apply â‡’á¶œáµ¢;
    assume Heps;
    apply âˆƒá¶œáµ¢ _ (`Ïµ x, p x);
    apply Heps
  }
end;

opaque symbol Ïµ_equiv_âˆƒá¶œ [a p] : Ï€á¶œ ((`âˆƒá¶œ x: Ï„ a, p x) â‡”á¶œ (p (`Ïµ x, p x))) â‰”
begin
  assume a p;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume Hexist;
    apply âˆƒá¶œâ‚‘ _ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    apply â‡’á¶œáµ¢;
    assume Heps;
    apply âˆƒá¶œáµ¢ _ (`Ïµ x, p x);
    apply Heps
  }
end;

constant symbol ite [a] (c: Ï„ o) (t e: Ï„ a): Ï„ a;

constant symbol iteI [a] : Î  (c: Ï„ o) (t e: Ï„ a) p,
  (Ï€á¶œ c â†’ Ï€á¶œ (p t))
  â†’ ((Ï€á¶œ c â†’ Ï€á¶œ âŠ¥) â†’ Ï€á¶œ (p e))
  â†’ Ï€á¶œ (p (ite c t e));
// symbol ite (c t e: Ï„ o) â‰” (c â‡’á¶œ t) âˆ§á¶œ ((Â¬ c) â‡’á¶œ e);
// constant symbol iteI : Î  c t e p,
//                            (Ï€á¶œ c â†’ Ï€á¶œ (p t))
//                          â†’ ((Ï€á¶œ c â†’ Ï€á¶œ âŠ¥) â†’ Ï€á¶œ (p e))
//                          â†’ Ï€á¶œ (p (ite c t e));

opaque symbol âˆ¨á¶œ_to_âŸ‡ a b: Ï€á¶œ (a âˆ¨á¶œ b) â†’ Ï€Ì‡ (a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b Haorb;
  apply âˆ¨á¶œâ‚‘ Haorb
  { assume Ha;  apply âˆ¨á¶œáµ¢â‚; apply Ha }
  {  assume Hb; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply Hb }
end;

opaque symbol cong [a b] (f:Ï„ a â†’ Ï„ b) [x x':Ï„ a] : Ï€á¶œ(x = x') â†’ Ï€á¶œ(f x = f x') â‰”
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol cong2 [a b c] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c):
  Î  [x x':Ï„ a], Ï€á¶œ (x = x') â†’ Î  [y y':Ï„ b], Ï€á¶œ (y = y') â†’ Ï€á¶œ (f x y = f x' y') â‰”
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol cong3 [a b c d] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c â†’ Ï„ d):
  Î  [x x':Ï„ a], Ï€á¶œ (x = x') â†’ Î  [y y':Ï„ b], Ï€á¶œ (y = y') â†’ Î  [z z':Ï„ c], Ï€á¶œ (z = z') â†’ Ï€á¶œ (f x y z = f x' y' z') â‰”
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;

opaque symbol cong4 [a1 a2 a3 a4 a5] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5):
  Î  [x1 x1':Ï„ a1], Ï€á¶œ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€á¶œ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€á¶œ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€á¶œ (x4 = x4') â†’
  Ï€á¶œ (f x1 x2 x3 x4 = f x1' x2' x3' x4') â‰”
begin
  assume a1 a2 a3 a4 a5 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  reflexivity
end;

opaque symbol cong5 [a1 a2 a3 a4 a5 a6] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6):
  Î  [x1 x1':Ï„ a1], Ï€á¶œ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€á¶œ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€á¶œ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€á¶œ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€á¶œ (x5 = x5') â†’
  Ï€á¶œ (f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  reflexivity
end;

opaque symbol cong6 [a1 a2 a3 a4 a5 a6 a7] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7):
  Î  [x1 x1':Ï„ a1], Ï€á¶œ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€á¶œ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€á¶œ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€á¶œ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€á¶œ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€á¶œ (x6 = x6') â†’
  Ï€á¶œ (f x1 x2 x3 x4 x5 x6 = f x1' x2' x3' x4' x5' x6') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  reflexivity
end;

opaque symbol cong7 [a1 a2 a3 a4 a5 a6 a7 a8] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7 â†’ Ï„ a8):
  Î  [x1 x1':Ï„ a1], Ï€á¶œ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€á¶œ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€á¶œ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€á¶œ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€á¶œ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€á¶œ (x6 = x6') â†’
  Î  [x7 x7':Ï„ a7], Ï€á¶œ (x7 = x7') â†’
  Ï€á¶œ (f x1 x2 x3 x4 x5 x6 x7 = f x1' x2' x3' x4' x5' x6' x7') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 a8 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  assume x7 x7' H7;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  rewrite H7;
  reflexivity
end;

opaque symbol cong8 [a1 a2 a3 a4 a5 a6 a7 a8 a9] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7 â†’ Ï„ a8 â†’ Ï„ a9):
  Î  [x1 x1':Ï„ a1], Ï€á¶œ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€á¶œ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€á¶œ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€á¶œ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€á¶œ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€á¶œ (x6 = x6') â†’
  Î  [x7 x7':Ï„ a7], Ï€á¶œ (x7 = x7') â†’
  Î  [x8 x8':Ï„ a8], Ï€á¶œ (x8 = x8') â†’
  Ï€á¶œ (f x1 x2 x3 x4 x5 x6 x7 x8 = f x1' x2' x3' x4' x5' x6' x7' x8') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 a8 a9 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  assume x7 x7' H7;
  assume x8 x8' H8;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  rewrite H7;
  rewrite H8;
  reflexivity
end;

opaque symbol ite1' [c t e] : Ï€á¶œ (ite c t e â‡’á¶œ c âˆ¨á¶œ e) â‰”
begin
  assume c t e;
  apply iteI c t e (Î» u, u â‡’á¶œ (c âˆ¨á¶œ e))
  {
    assume Hc;
    apply â‡’á¶œáµ¢;
    assume Ht;
    apply âˆ¨á¶œáµ¢â‚;
    apply Hc
  }
  {
    assume Hnc;
    apply â‡’á¶œáµ¢;
    assume He;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply He
  }
end;

opaque symbol ite1 (c t e: Ï„ o) : Ï€á¶œ (ite c t e) â†’ Ï€Ì‡ (c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@ite1' c t e)) H;
end;

opaque symbol ite2' [c t e] : Ï€á¶œ (ite c t e â‡’á¶œ ((Â¬ c) âˆ¨á¶œ t)) â‰”
begin
  assume c t e;
  apply iteI c t e (Î» u, u â‡’á¶œ (Â¬ c âˆ¨á¶œ t))
  {
    assume Hc;
    apply â‡’á¶œáµ¢;
    assume Ht;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Ht
  }
  {
    assume Hc;
    apply â‡’á¶œáµ¢;
    assume He;
    remove He;
    apply âˆ¨á¶œáµ¢â‚;
    simplify;
    apply â‡’á¶œáµ¢';
    refine Hc
  };
end;

opaque symbol ite2 (c t e: Ï„ o) : Ï€á¶œ (ite c t e) â†’ Ï€Ì‡ ((Â¬ c) âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@ite2' c t e)) H;
end;

// Use it to unfold the definition of `Â¬`.
// The tactic simplify is to agressive.
opaque symbol negdef p : Ï€á¶œ ((p â‡’ âŠ¥) = Â¬ p) â‰”
begin
  simplify; reflexivity
end;

opaque symbol ite_pos1 [c t e] : Ï€Ì‡ ((Â¬ (ite c t e)) âŸ‡ c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@ite1' c t e)) H;
end;

opaque symbol ite_pos2 [c t e] : Ï€Ì‡ (Â¬ (ite c t e) âŸ‡ Â¬ c âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@ite2' c t e)) H;
end;

opaque symbol ite_neg1 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  apply iteI c t e (Î» u, u âˆ¨á¶œ (c âˆ¨á¶œ (e â‡’ âŠ¥)))
  {
    assume Hc; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; refine Hc
  }
  {
    assume Hnc; rewrite or_com;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    apply classic;
  };
end;

opaque symbol ite_neg2 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  apply iteI c t e (Î» u, u âˆ¨á¶œ ((c â‡’ âŠ¥)âˆ¨á¶œ (t â‡’ âŠ¥)))
  {
    assume Hnc; rewrite or_com;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    apply classic;
  }
  {
    assume Hc; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply â‡’á¶œáµ¢'; refine Hc
  }
end;

opaque symbol not_ite1' [c t e] : Ï€á¶œ (Â¬ (ite c t e) â‡’á¶œ c âˆ¨á¶œ Â¬ e) â‰”
begin
  assume c t e;
  apply iteI c t e (Î» u, Â¬ u â‡’á¶œ c âˆ¨á¶œ Â¬ e)
  {
    assume Hc;
    apply â‡’á¶œáµ¢;
    assume Hnt;
    apply âˆ¨á¶œáµ¢â‚;
    refine Hc;
  }
  {
    assume Hcimpbot;
    apply â‡’á¶œáµ¢;
    assume Hne;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hne
  }
end;

opaque symbol not_ite1 [c t e] : Ï€á¶œ (Â¬ (ite c t e)) â†’ Ï€Ì‡( c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@not_ite1' c t e) H);
end;

opaque symbol not_ite2' [c t e] : Ï€á¶œ (Â¬ (ite c t e) â‡’á¶œ Â¬ c  âˆ¨á¶œ Â¬ t) â‰”
begin
  assume c t e;
  apply iteI c t e (Î» u, Â¬ u â‡’á¶œ Â¬ c  âˆ¨á¶œ Â¬ t)
  { assume Hc; apply â‡’á¶œáµ¢; assume Hnt; apply âˆ¨á¶œáµ¢â‚‚; refine Hnt }
  { assume Hcimpbot; apply â‡’á¶œáµ¢; assume Hne; apply âˆ¨á¶œáµ¢â‚; simplify; apply â‡’á¶œáµ¢'; refine Hcimpbot; }
end;

opaque symbol not_ite2 [c t e] : Ï€á¶œ (Â¬ (ite c t e)) â†’ Ï€Ì‡(Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply (â‡’á¶œâ‚‘ (@not_ite2' c t e) H);
end;

opaque symbol ite_cong [a] [c c': Ï„ o] [t t' e e': Ï„ a] : Ï€á¶œ (c = c') â†’ Ï€á¶œ (t = t') â†’ Ï€á¶œ (e = e') â†’ Ï€Ì‡(ite c t e = ite c' t' e' âŸ‡ â–©) â‰”
begin
  assume a c c' t t' e e' Hcc' Htt' Hee';
  simplify;
  rewrite or_identity_r;
  rewrite Hcc';
  rewrite Htt';
  rewrite Hee';
  reflexivity
end;

symbol xor a b â‰” ((Â¬ a) âˆ§á¶œ b) âˆ¨á¶œ (a âˆ§á¶œ (Â¬ b));

opaque symbol xor_pos1 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
end;

opaque symbol xor_pos2 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ Â¬ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
end;

opaque symbol xor_neg1 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨á¶œ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite or_identity_r;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite or_com;
    apply classic
  }
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
end;

opaque symbol xor_neg2 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ Â¬ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨á¶œ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply âˆ§á¶œáµ¢
    {
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      rewrite or_com;
      apply classic
    }
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite or_com;
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      rewrite or_identity_r;
      apply classic
    }
  }
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply âˆ§á¶œáµ¢
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      apply classic
    }
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      rewrite or_identity_r;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite or_com;
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply classic
    }
  }
end;

// // i â–· ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘n
// // j â–· ğœ‘1 , â‹¯ , ğœ‘n
constant symbol or [a b] : Ï€Ì‡ ((a âˆ¨á¶œ b) âŸ‡ â–©) â†’ Ï€Ì‡ (âˆ¨á¶œ_to_âŸ‡_rw  (a âˆ¨á¶œ b));

opaque symbol not_not x : Ï€Ì‡ ( (Â¬ (Â¬ (Â¬ x))) âŸ‡ x âŸ‡ â–©) â‰”
begin
  assume x;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚;
  apply nnpp H
end;

opaque symbol implies [Ï†â‚ Ï†â‚‚] : Ï€á¶œ (Ï†â‚ â‡’á¶œ Ï†â‚‚) â†’ Ï€Ì‡ (Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ HÏ†â‚â‡’á¶œÏ†â‚‚;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume Ï€Ï†â‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply â‡’á¶œâ‚‘ HÏ†â‚â‡’á¶œÏ†â‚‚ Ï€Ï†â‚
end;

opaque symbol not_implies1 [Ï†â‚ Ï†â‚‚] : Ï€á¶œ (Â¬ (Ï†â‚ â‡’á¶œ Ï†â‚‚)) â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚â‡’á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚ (imply_to_and Hnot_Ï†â‚â‡’á¶œÏ†â‚‚)
end;

opaque symbol not_implies2 [Ï†â‚ Ï†â‚‚] : Ï€á¶œ (Â¬ (Ï†â‚ â‡’á¶œ Ï†â‚‚)) â†’  Ï€Ì‡ (Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚â‡’á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚‚ (imply_to_and Hnot_Ï†â‚â‡’á¶œÏ†â‚‚)
end;

opaque symbol implies_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ â‡’á¶œ Ï†â‚‚ âŸ‡ Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  rewrite .[(Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚] or_com;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚‚;
  rewrite or_com;
  apply classic
end;

opaque symbol implies_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ â‡’á¶œ Ï†â‚‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply classic
end;

opaque symbol equiv1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©) â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€á¶œ (Ï†â‚ â‡”á¶œ Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    have H2: Ï€á¶œ (Ï†â‚ â‡’á¶œ Ï†â‚‚) { apply âˆ§á¶œâ‚‘â‚ Hequiv' };
    have H3: Ï€á¶œ (Ï†â‚‚ â‡’á¶œ Ï†â‚) { apply âˆ§á¶œâ‚‘â‚‚ Hequiv' };
    have Hassoc: Ï€á¶œ (((Â¬ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥)) â‡”á¶œ  (((Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc (Â¬ Ï†â‚) Ï†â‚‚ âŠ¥);
    };
    have Hassoc_left: Ï€á¶œ ((((Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)  â‡’á¶œ  ((Â¬ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥))) {
      refine âˆ§á¶œâ‚‘â‚‚ Hassoc
    };
    apply â‡’á¶œâ‚‘ Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply imply_to_or;
    refine H2;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€á¶œ (Ï†â‚ â‡”á¶œ Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    have H2: Ï€á¶œ (Ï†â‚ â‡’á¶œ Ï†â‚‚) { apply âˆ§á¶œâ‚‘â‚ Hequiv' };
    have H3: Ï€á¶œ (Ï†â‚‚ â‡’á¶œ Ï†â‚) { apply âˆ§á¶œâ‚‘â‚‚ Hequiv' };
    have Hassoc: Ï€á¶œ ((Ï†â‚ âˆ¨á¶œ ((Â¬ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) â‡”á¶œ  ((Ï†â‚ âˆ¨á¶œ (Â¬ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc Ï†â‚ (Â¬ Ï†â‚‚) âŠ¥);
    };
    have Hassoc_left: Ï€á¶œ (((Ï†â‚ âˆ¨á¶œ (Â¬ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)  â‡’á¶œ  (Ï†â‚ âˆ¨á¶œ ((Â¬ Ï†â‚‚) âˆ¨á¶œ âŠ¥))) {
      refine âˆ§á¶œâ‚‘â‚‚ Hassoc
    };
    apply â‡’á¶œâ‚‘ Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ¨á¶œ_com;
    apply imply_to_or;
    refine H3;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv_pos1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume Heq;
  rewrite Heq;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  apply classic
end;

opaque symbol equiv_pos2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ (Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume Heq;
  rewrite or_identity_r;
  apply âˆ¨á¶œ_com;
  rewrite Heq;
  apply classic
end;

opaque symbol equiv_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  apply âˆ¨á¶œ_com;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume Hp;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume Hq;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply â‡’á¶œáµ¢; assume Hp'; apply Hq }
  { apply â‡’á¶œáµ¢; assume Hq'; apply Hp }
end;

opaque symbol equiv_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  rewrite left iff_equiv_eq;
  apply âˆ¨á¶œ_com;
  simplify;
  rewrite distributive_or; //(p âˆ¨á¶œ q) (p â‡’á¶œ q) (q â‡’á¶œ p);
  apply âˆ§á¶œáµ¢
  {
    rewrite left imp_eq_or;
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite .[(Â¬ p) âˆ¨á¶œ q] or_com;
    rewrite  .[q âˆ¨á¶œ (q âˆ¨á¶œ Â¬ p)] âˆ¨á¶œ_assoc_eq;
    rewrite or_idempotent;
    rewrite .[q âˆ¨á¶œ (Â¬ p)] or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
  {
    rewrite left imp_eq_or;
    rewrite âˆ¨á¶œ_assoc_eq;
    rewrite .[p âˆ¨á¶œ q] or_com;
    rewrite left .[((q âˆ¨á¶œ p) âˆ¨á¶œ Â¬ q)] âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite .[p âˆ¨á¶œ Â¬ q] or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
end;

opaque symbol implies_pos [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ â‡’á¶œ Ï†â‚‚)) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume x y;
  rewrite or_identity_r;
  rewrite left imp_eq_or;
  apply âˆ¨á¶œ_com;
  apply classic
end;

opaque symbol not_symm [a] [x y: Ï„ a] : Ï€á¶œ (Â¬ (x = y)) â†’ Ï€á¶œ (Â¬ (y = x)) â‰”
begin
  simplify;
  assume a x y H;
  admit
end;

symbol trans [U] [a b c: Ï„ U]: Ï€Ì‡ (a = b âŸ‡ â–©) â†’ Ï€Ì‡ (b = c âŸ‡ â–©) â†’ Ï€Ì‡ (a = c âŸ‡ â–©) â‰”
begin
  assume U a b c H1 H2;
  apply âˆ¨á¶œáµ¢â‚;
  have H2': Ï€á¶œ (b = c) { apply Ï€Ì‡â‚— H2 };
  have H1': Ï€á¶œ (a = b) { apply Ï€Ì‡â‚— H1 };
  rewrite H1';
  apply H2'
end;

opaque symbol subproof [Ï†â‚ Ïˆ] : Ï€á¶œ Ï†â‚ â†’ Ï€á¶œ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ïˆ HÏ†â‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ
end;

opaque symbol forall_inst1 [a] p (x: Ï„ a) : Ï€á¶œ (Â¬ (`âˆ€á¶œ x', p x') âˆ¨á¶œ (p x)) â‰”
begin
 assume a p x;
 rewrite imp_eq_or;
 apply â‡’á¶œáµ¢;
 assume H;
 apply âˆ€á¶œâ‚‘ x H
end;

opaque symbol forall_inst2 [a] p (x y: Ï„ a) : Ï€á¶œ (Â¬ (`âˆ€á¶œ a, `âˆ€á¶œ b, p a b) âˆ¨á¶œ (p x y)) â‰”
begin
  assume a p x y;
  rewrite imp_eq_or;
  apply â‡’á¶œáµ¢;
  assume H;
  apply âˆ€á¶œâ‚‘ y (âˆ€á¶œâ‚‘ x H)
 end;

opaque symbol forall_inst3 [a] [p] (x y z: Ï„ a) : Ï€á¶œ ((Â¬ (`âˆ€á¶œ a, `âˆ€á¶œ b, `âˆ€á¶œ c, p a b c)) âˆ¨á¶œ ((p x y z) âˆ¨á¶œ âŠ¥)) â‰”
begin
  assume a p x y z;
  apply imply_to_or;
  apply â‡’á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚ (âˆ€á¶œâ‚‘ z (âˆ€á¶œâ‚‘ y (âˆ€á¶œâ‚‘ x H)))
end;

// # In Predicate
//
// The In predicate works with ğ”¹ instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// â–· `$x â‡”á¶œ $x â†ª âŠ¤` to replace `eq $x $h` and,
// â–· `_ âˆ¨á¶œ âŠ¤ â†ª âŠ¤` for `or _ true â†ª true`.
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral âŠ¤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// âŠ¢ (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›), Â¬ğœ‘k
// then we will have
// âŠ¢ In_âˆ¨á¶œ ğœ‘k (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›)  (apply or_neg)
// âŠ¢ In_âˆ¨á¶œ ğœ‘k âŠ¤  (by simplification)
// we got stuck...

// Decidable equality in ğ”¹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.

// symbol ğ‘° [a]: â„• â†’ Ï„ a;

sequential symbol eq : Prop â†’ Prop â†’ ğ”¹;
rule eq $x $x â†ª true
with eq $x $y â†ª false;

sequential symbol In_âˆ§á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§á¶œ $x ($h âˆ§á¶œ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§á¶œ $x $tl)
with In_âˆ§á¶œ $x âŠ¤ â†ª false;

sequential symbol In_âˆ¨á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨á¶œ $x ($h âˆ¨á¶œ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨á¶œ $x $tl)
with In_âˆ¨á¶œ _ âŠ¥ â†ª false;

sequential symbol In_âˆ§á¶œ': Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§á¶œ' $x ($h âˆ§á¶œ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§á¶œ' $x $tl)
with In_âˆ§á¶œ' $x $h â†ª (eq $x $h);

sequential symbol In_âˆ¨á¶œ': Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨á¶œ' $x ($h âˆ¨á¶œ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨á¶œ' $x $tl)
with In_âˆ¨á¶œ' $x $h â†ª (eq $x $h);

// and_pos: Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›), ğœ‘ğ‘˜
symbol and_pos [Ï†â‚__Ï†â‚™ Ï†â‚–]:  Ï€á¶œ ((In_âˆ§á¶œ' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚__Ï†â‚™ âŸ‡ Ï†â‚– âŸ‡ â–©);

opaque symbol test_and_pos: Ï€Ì‡ ((Â¬ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d)) âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply and_pos;
  reflexivity;
end;

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol and_neg_r: Prop â†’ Clause â†’ ğ”¹;
rule and_neg_r ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª and_neg_r $tl $tl2
with and_neg_r âŠ¤ â–© â†ª true;

sequential symbol and_neg_r': Prop â†’ Clause â†’ ğ”¹;
rule and_neg_r' ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª and_neg_r' $tl $tl2
with and_neg_r' ($x) (($x â‡’ âŠ¥) âŸ‡ â–©) â†ª true;
//with and_neg_r âŠ¤ â–© â†ª true;

symbol and_neg [l1 l2]: Ï€á¶œ (and_neg_r' l1 l2 = true) â†’ Ï€Ì‡ (l1 âŸ‡ l2);

opaque symbol test_and_neg: Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d) âŸ‡ (Â¬ a) âŸ‡ (Â¬ b) âŸ‡ (Â¬ c) âŸ‡ (Â¬ d) âŸ‡ â–©) â‰”
begin
  apply and_neg;
  reflexivity;
end;

// or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
sequential symbol or_pos_r: Prop â†’ Clause â†’ ğ”¹;
rule or_pos_r ($x âˆ¨á¶œ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r $tl $tl2
with or_pos_r âŠ¥ â–© â†ª true;

sequential symbol or_pos_r': Prop â†’ Clause â†’ ğ”¹;
rule or_pos_r' ($x âˆ¨á¶œ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r' $tl $tl2
with or_pos_r' $x ($x âŸ‡ â–©) â†ª true;

symbol or_pos [l1 l2]: Ï€á¶œ (or_pos_r' l1 l2 = true) â†’ Ï€Ì‡ (Â¬ l1 âŸ‡ l2);

opaque symbol test_or_pos: Ï€Ì‡ (Â¬ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d) âŸ‡ a âŸ‡ b âŸ‡ c âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply or_pos; reflexivity
end;

// or_neg:
// i. â–· (ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
symbol or_neg [Ï†â‚__Ï†â‚™] Ï†â‚–:  Ï€á¶œ ((In_âˆ¨á¶œ' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ Â¬ Ï†â‚– âŸ‡ â–©);

opaque symbol test_or_neg: Ï€Ì‡ (((a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d)) âŸ‡ Â¬ c âŸ‡ â–©) â‰”
begin
  apply or_neg; reflexivity
end;

// not_or:
// i. â–· Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘ğ‘˜
symbol not_or [Ï†â‚–] Ï†â‚__Ï†â‚™: Ï€á¶œ (Â¬ Ï†â‚__Ï†â‚™) â†’ Ï€á¶œ ((In_âˆ¨á¶œ' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚– âŸ‡ â–©);

opaque symbol identity_âŠ¥ [x] : Ï€á¶œ (x âˆ¨á¶œ âŠ¥) â†’ Ï€á¶œ x â‰”
begin
  assume x H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hx; apply Hx } { assume HâŠ¥; apply âŠ¥á¶œâ‚‘; apply HâŠ¥ }
end;

opaque symbol test_not_or: Ï€Ì‡ (Â¬ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ c âŸ‡ â–©) â‰”
begin
  assume H; // i
  apply not_or (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d)
    { apply Ï€Ì‡â‚—; apply H }
    { reflexivity }
end;

// not_and:
// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol not_and_r: Prop â†’ Clause â†’ ğ”¹;
rule not_and_r ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª not_and_r $tl $tl2
with not_and_r âŠ¤ â–© â†ª true;

sequential symbol not_and_r': Prop â†’ Clause â†’ ğ”¹;
rule not_and_r' ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª not_and_r' $tl $tl2
with not_and_r' $x (($x â‡’ âŠ¥) âŸ‡ â–©) â†ª true;

symbol not_and [l1 l2]: Ï€á¶œ (Â¬ l1) â†’ Ï€á¶œ (not_and_r' l1 l2 = true) â†’ Ï€Ì‡ l2;

opaque symbol test_not_and: Ï€Ì‡ (Â¬ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ a âŸ‡ Â¬ b âŸ‡ Â¬ c âŸ‡ Â¬ d âŸ‡ â–©) â‰”
begin
  assume t1;
  apply not_and (Ï€Ì‡â‚— t1);
  reflexivity
end;

// and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol and [Ï†â‚–] Ï†â‚__Ï†â‚™ : Ï€á¶œ ((In_âˆ§á¶œ' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚– âŸ‡ â–©);

opaque symbol test_and:  Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d) âŸ‡ â–©) â†’  Ï€Ì‡ (c âŸ‡ â–©) â‰”
begin
  assume t1;
  apply and ((a âˆ§á¶œ b âˆ§á¶œ (c âˆ§á¶œ d))) { simplify; reflexivity } { apply t1  };
end;

opaque symbol resolutionâ‚— x a b: Ï€Ì‡ (x âŸ‡ a) â†’ Ï€Ì‡ ((Â¬ x) âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hx;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥á¶œâ‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥á¶œâ‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘  tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol resolutionáµ£ x a b: Ï€Ì‡ ((Â¬ x) âŸ‡ a) â†’ Ï€Ì‡ (x âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hnx;
    apply âŸ‡â‚‘ H2 {
      assume Hx;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥á¶œâ‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥á¶œâ‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€á¶œ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’á¶œ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§á¶œâ‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply â‡’á¶œâ‚‘ tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol bind_âˆƒ [a p q]: (Î  x, Ï€á¶œ (p x = q x))  â†’ Ï€á¶œ ((`âˆƒá¶œ (x: Ï„ a), p x) = (`âˆƒá¶œ (x: Ï„ a), q x)) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hpx;
    apply âˆƒá¶œáµ¢ _ x;
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hqx;
    apply âˆƒá¶œáµ¢ _ x;
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_âˆ€ [a p q]: (Î  (x: Ï„ a), Ï€á¶œ (p x = q x))  â†’ Ï€á¶œ ((`âˆ€á¶œ (x: Ï„ a), p x) = (`âˆ€á¶œ (x: Ï„ a), q x)) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hpx: Ï€á¶œ (p x) { apply âˆ€á¶œâ‚‘ x H1; };
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hqx: Ï€á¶œ (q x) { apply âˆ€á¶œâ‚‘ x H1 };
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_âˆ€' [a p q]: (Î  (x: Ï„ a), Î  (y: Ï„ a), Ï€á¶œ (x = y) â†’ Ï€á¶œ (p x = q y))  â†’ Ï€á¶œ ((`âˆ€á¶œ (x: Ï„ a), p x) = (`âˆ€á¶œ (y: Ï„ a), q y)) â‰”
begin
  assume a p q;
  assume H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hpx: Ï€á¶œ (p x) { apply âˆ€á¶œâ‚‘ x H1; };
    rewrite left H x x (eq_reflá¶œ x);
    apply Hpx
  }
  {
    apply â‡’á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hqx: Ï€á¶œ (q x) { apply âˆ€á¶œâ‚‘ x H1 };
    rewrite H x x (eq_reflá¶œ x);
    apply Hqx;
  };
end;

opaque symbol sko_forall [a p q]: (Î  (x: Ï„ a), Ï€á¶œ (x = `Ïµ (y: Ï„ a), Â¬ (p y)) â†’ Ï€á¶œ (p x = q))  â†’ Ï€á¶œ ((`âˆ€á¶œ (x: Ï„ a), p x) = q) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply â‡’á¶œâ‚‘ (âˆ§á¶œâ‚‘â‚‚ (@contrapos (`âˆ€á¶œ x, p x) q));
    apply â‡’á¶œáµ¢;
    assume Hnq;
    rewrite .[x in Â¬ x]  (Ïµ_to_âˆ€ p);
    have H1:  Ï€á¶œ (p (`Ïµ x, Â¬ (p x)) = q) { apply H; reflexivity };
    rewrite H1;
    apply Hnq
  }
  {
    rewrite .[x in _ â‡’á¶œ x]  (Ïµ_to_âˆ€ p);
    apply â‡’á¶œáµ¢;
    assume Hq;
    have H1:  Ï€á¶œ (p (`Ïµ y, Â¬ (p y)) = q) { apply H; reflexivity };
    rewrite H1;
    apply Hq
  }
end;

// Inductive t A : nat -> Type :=
//   |nil : t A 0
//   |cons : forall (h:A) (n:nat), t A n -> t A (S n).
(a: Set) inductive Vec: â„• â†’ TYPE â‰”
| â–¡ : Vec a 0 // \Box
| cons [n: â„•] : Ï„ a â†’  Vec a n  â†’  Vec a (n + 1);

print Vec;

constant symbol vec : Set â†’ â„• â†’ Set;
rule Ï„ (vec $a $n) â†ª Vec $a $n;

symbol distinct [a] [n: Ï„ nat]  : Vec a n â†’ Prop;

// // boolean case
rule distinct (cons _ â–¡) â†ª âŠ¤
with distinct (cons $x (cons $y â–¡)) â†ª ($x â‰  $y)
with distinct â–¡ â†ª âŠ¥
with distinct (cons _ (cons _ (cons _ _))) â†ª âŠ¥;


// 
assert âŠ¢ distinct (cons a â–¡) â‰¡ âŠ¤;
assert âŠ¢ distinct ((cons a (cons b â–¡))) â‰¡ (a â‰  b);
assert âŠ¢ distinct (cons a (cons b (cons c â–¡))) â‰¡ âŠ¥;
assert âŠ¢ distinct (cons a (cons b (cons c (cons d â–¡)))) â‰¡ âŠ¥;


assert âŠ¢ distinct (cons 1 â–¡) â‰¡ âŠ¤;
assert âŠ¢ distinct ((cons 1 (cons 2 â–¡))) â‰¡ (1 â‰  2);
assert âŠ¢ distinct (cons 1 (cons 2 (cons 3 â–¡))) â‰¡ âŠ¥;

opaque symbol distinct_elim  [a] [t: Ï„ a] : Ï€á¶œ (distinct (cons t â–¡) = âŠ¤) â‰” eq_reflá¶œ (distinct(cons t â–¡));

opaque symbol distinct_elimâ‚‚ [a] [x y: Ï„ a] : Ï€á¶œ ((distinct ((cons x (cons y â–¡)))) = (x â‰  y)) â‰” eq_reflá¶œ (distinct (cons x (cons y â–¡)));

//opaque symbol distinct_elimâ‚ƒ [a] [n: Ï„ nat] [v: Vec a (n + 3)] : Ï€á¶œ (distinct v = âŠ¥) â‰”  eq_reflá¶œ (distinct v);

opaque symbol feqá¶œ [a b] (f:Ï„ a â†’ Ï„ b) [x x':Ï„ a] : Ï€á¶œ(x = x') â†’ Ï€á¶œ(f x = f x') â‰”
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol feq2á¶œ [a b c] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c):
  Î  [x x':Ï„ a], Ï€á¶œ(x = x') â†’ Î  [y y':Ï„ b], Ï€á¶œ(y = y') â†’ Ï€á¶œ(f x y = f x' y') â‰”
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol feq3á¶œ [a b c d] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c â†’ Ï„ d):
  Î  [x x':Ï„ a], Ï€á¶œ(x = x') â†’ Î  [y y':Ï„ b], Ï€á¶œ(y = y') â†’ Î  [z z':Ï„ c], Ï€á¶œ(z = z') â†’ Ï€á¶œ(f x y z = f x' y' z') â‰”
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;

opaque symbol feq4á¶œ [a b c d e] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c â†’ Ï„ d â†’ Ï„ e):
  Î  [x1 x1':Ï„ a], Ï€á¶œ(x1 = x1') â†’
  Î  [x2 x2':Ï„ b], Ï€á¶œ(x2 = x2') â†’
  Î  [x3 x3':Ï„ c], Ï€á¶œ(x3 = x3') â†’
  Î  [x4 x4':Ï„ d], Ï€á¶œ(x4 = x4') â†’
  Ï€á¶œ(f x1 x2 x3 x4 = f x1' x2' x3' x4') â‰”
begin
  assume a b c d e f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  reflexivity
end;

opaque symbol feq5á¶œ [a b c d e g] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c  â†’ Ï„ d â†’ Ï„ e â†’ Ï„ g ):
  Î  [x1 x1':Ï„ a], Ï€á¶œ(x1 = x1') â†’
  Î  [x2 x2':Ï„ b], Ï€á¶œ(x2 = x2') â†’
  Î  [x3 x3':Ï„ c], Ï€á¶œ(x3 = x3') â†’
  Î  [x4 x4':Ï„ d], Ï€á¶œ(x4 = x4') â†’
  Î  [x5 x5':Ï„ e], Ï€á¶œ(x5 = x5') â†’
  Ï€á¶œ(f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5') â‰”
begin
  assume a b c d e g f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  reflexivity
end;

builtin "bot" â‰” âŠ¥;
builtin "top" â‰” âŠ¤;
builtin "imp" â‰” â‡’;
builtin "and" â‰” âˆ§á¶œ;
builtin "or"  â‰” âˆ¨á¶œ;
builtin "not" â‰” Â¬;
builtin "all" â‰” âˆ€á¶œ;
builtin "ex"  â‰” âˆƒá¶œ;
builtin "eqv"  â‰” â‡”á¶œ;

opaque symbol cong_or [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ (t1 âˆ¨á¶œ t2 = u1 âˆ¨á¶œ u2 âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€á¶œ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€á¶œ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨á¶œáµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

opaque symbol cong_and [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ (t1 âˆ§á¶œ t2 = u1 âˆ§á¶œ u2 âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€á¶œ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€á¶œ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨á¶œáµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

opaque symbol cong_imp [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ ((t1 â‡’á¶œ t2) = u1 â‡’á¶œ u2 âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€á¶œ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€á¶œ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨á¶œáµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

opaque symbol and_elim1 [p q : Ï„ bool] : Ï€á¶œ (istrue (p Stdlib.Bool.and q)) â†’ Ï€á¶œ (istrue p) â‰”
begin
  admit
end;

opaque symbol and_elim2 [p q : Ï„ bool] : Ï€á¶œ (istrue (p Stdlib.Bool.and q)) â†’ Ï€á¶œ (istrue q) â‰”
begin
  admit
end;

symbol head : Clause â†’ Ï„ o;

rule head â–© â†ª âŠ¥
with head ($x âŸ‡ _) â†ª $x;

symbol behead  : Clause â†’ Clause;

rule behead â–© â†ª â–©
with behead (_ âŸ‡ $l) â†ª $l;

symbol âˆ¨á¶œ_left: Ï„ o â†’ Ï„ o;
rule âˆ¨á¶œ_left ($x âˆ¨á¶œ _) â†ª $x;

symbol âˆ¨á¶œ_right: Ï„ o â†’ Ï„ o;
rule âˆ¨á¶œ_right (_ âˆ¨á¶œ $y) â†ª $y;

opaque symbol âŸ‡_inj [x:Ï„ o] [l y m] : Ï€á¶œ ((x âŸ‡ l) = (y âŸ‡ m)) â†’ Ï€á¶œ ((x = y) âˆ§á¶œ (l = m)) â‰”
begin
  assume x l y m e;
   apply âˆ§á¶œáµ¢ { apply feqá¶œ head e } { apply feqá¶œ behead e }
end;

opaque symbol âˆ¨á¶œ_inj [x:Ï„ o] [l y m] : Ï€á¶œ ((x âˆ¨á¶œ l) = (y âˆ¨á¶œ m)) â†’ Ï€á¶œ ((x = y) âˆ§á¶œ (l = m)) â‰”
begin
  assume x l y m e; apply âˆ§á¶œáµ¢ { refine feqá¶œ (âˆ¨á¶œ_left) e } { refine feqá¶œ (âˆ¨á¶œ_right) e }
end;

opaque symbol âˆ¨á¶œ_inj2 [x:Ï„ o] [l y m] : Ï€á¶œ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) = (y âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw m)) â†’ Ï€á¶œ ((x = y) âˆ§á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l = âŸ‡_to_âˆ¨á¶œ_rw m)) â‰”
begin
  assume x l y m e; apply âˆ§á¶œáµ¢ { refine feqá¶œ (âˆ¨á¶œ_left) e } { refine feqá¶œ (âˆ¨á¶œ_right) e; }
end;

symbol â„‚: TYPE;
symbol Cl: Set;
rule Ï„ Cl â†ª â„‚;
symbol P: Prop â†’ â„‚;
right associative commutative symbol âŠ”: â„‚ â†’ â„‚ â†’ â„‚; notation âŠ” infix right 2;
symbol â¬“: â„‚;

symbol reify_cl: Clause â†’ â„‚;

rule reify_cl ($x âŸ‡ $xs) â†ª (P $x) âŠ” (reify_cl $xs)
with reify_cl â–© â†ª â¬“
;

symbol isâ¬“ : â„‚ â†’ Ï„ bool;
rule isâ¬“ (P _) â†ª false
with isâ¬“ â¬“ â†ª true
with isâ¬“ (_ âŠ” _) â†ª false
;

symbol isP : â„‚ â†’ Ï„ bool;
rule isP (P _) â†ª true
with isP â¬“ â†ª false
with isP (_ âŠ” _) â†ª false
;

symbol isâŠ” : â„‚ â†’ Ï„ bool;
rule isâŠ” (P _) â†ª false
with isâŠ” â¬“ â†ª false
with isâŠ” (_ âŠ” _) â†ª true
;

opaque symbol âŠ”â‰ â¬“ [x y: â„‚]: Ï€á¶œ (((x âŠ” y) = â¬“) â‡’á¶œ âŠ¥) â‰”
begin
assume x y; apply â‡’á¶œáµ¢; assume h;
refine ind_eqá¶œ h (Î» l, istrue (isâ¬“ l)) trivial;
end;

opaque symbol âŠ”â‰ P [a: Ï„ o] [x y: â„‚]: Ï€á¶œ (((x âŠ” y) = P a) â‡’á¶œ âŠ¥) â‰”
begin
assume a x y; apply â‡’á¶œáµ¢; assume h;
refine ind_eqá¶œ h (Î» l, istrue (isP l)) trivial;
end;

opaque symbol â¬“â‰ P [a: Ï„ o] [x y: â„‚]: Ï€á¶œ ((â¬“ = P a) â‡’á¶œ âŠ¥) â‰”
begin
assume a x y; apply â‡’á¶œáµ¢; assume h;
refine ind_eqá¶œ h (Î» x, istrue (isP x)) trivial;
end;

sequential symbol  â©¦: â„‚ â†’ â„‚ â†’ ğ”¹; notation â©¦ infix 11;
rule (P $x) â©¦ (P $x) â†ª true
with (P $x) â©¦ (P $y) â†ª false
with ($x âŠ” $xs) â©¦ ($y âŠ” $ys) â†ª ($x â©¦ $y) Stdlib.Bool.and ($xs â©¦ $ys)
with â¬“ â©¦ â¬“ â†ª true
with â¬“ â©¦ (P _) â†ª false
with (P _) â©¦ â¬“ â†ª false
with (_ âŠ” _) â©¦ â¬“ â†ª false
with â¬“ â©¦ (_ âŠ” _) â†ª false
with (P _) â©¦ (_ âŠ” _) â†ª false
with (_ âŠ” _) â©¦ (P _) â†ª false;

//NOTE: The proof use a meta reasoning here
opaque symbol Pâ©¦_correct:  Ï€á¶œ (`âˆ€á¶œ x, `âˆ€á¶œ y, (istrue (P x â©¦ P y)) â‡’á¶œ x = y) â‰”
begin apply âˆ€á¶œáµ¢; assume x; apply âˆ€á¶œáµ¢; assume y; apply â‡’á¶œáµ¢; assume Heq; apply âŠ¥á¶œâ‚‘ Heq end;

symbol isâ–©: Clause â†’ ğ”¹;

rule isâ–© â–© â†ª true
with isâ–© (_ âŸ‡ _) â†ª false;

symbol isâŠ¥: Prop â†’ ğ”¹;
rule isâŠ¥ âŠ¥ â†ª true
with isâŠ¥ (_ âˆ¨á¶œ _) â†ª false;

opaque symbol âŸ‡â‰ â–© [x: Prop] [l: Clause] : Ï€á¶œ (( (x âŸ‡ l) =  â–©) â‡’á¶œ âŠ¥) â‰”
begin
  assume x l; apply â‡’á¶œáµ¢; simplify; assume h; type (ind_eqá¶œ h (Î» l, istrue(isâ–© l))) _;
    refine (ind_eqá¶œ h (Î» l, istrue(isâ–© l)) trivial);
end;

opaque symbol âˆ¨á¶œâ‰ âŠ¥ [x: Prop] [l: Clause] : Ï€á¶œ (((âŸ‡_to_âˆ¨á¶œ_rw (x âŸ‡ l)) = (âŸ‡_to_âˆ¨á¶œ_rw â–©)) â‡’á¶œ âŠ¥) â‰”
begin
  assume x l; simplify;  apply â‡’á¶œáµ¢;  assume h;
  refine (ind_eqá¶œ h (Î» l, istrue(isâŠ¥ l))) trivial;
end;

opaque symbol â–©â‰ âŸ‡ [x: Prop] [l: Clause] : Ï€á¶œ ((â–© = (x âŸ‡ l)) â‡’á¶œ âŠ¥) â‰”
begin
  assume x l;
  apply â‡’á¶œáµ¢; assume h;
  have h': Ï€á¶œ ((x âŸ‡ l) = â–©) {symmetry; apply h};
  apply â‡’á¶œâ‚‘ (@âŸ‡â‰ â–© x l);
  refine h'
end;

opaque symbol âŠ¥â‰ âˆ¨á¶œ [x: Prop] [l: Clause] : Ï€á¶œ (((âŸ‡_to_âˆ¨á¶œ_rw â–©) = (âŸ‡_to_âˆ¨á¶œ_rw (x âŸ‡ l))) â‡’á¶œ âŠ¥) â‰”
begin
  assume x l;
  apply â‡’á¶œáµ¢; assume h;
  have h': Ï€á¶œ (âŸ‡_to_âˆ¨á¶œ_rw (x âŸ‡ l) = âŸ‡_to_âˆ¨á¶œ_rw â–©) {symmetry; apply h};
  apply â‡’á¶œâ‚‘ (@âˆ¨á¶œâ‰ âŠ¥ x l);
  refine h'
end;

symbol denote: â„‚ â†’ Prop;
rule denote ($x âŠ” $y) â†ª (denote $x) âˆ¨á¶œ (denote $y)
with denote (P $x) â†ª $x
with denote â¬“ â†ª âŠ¥
;

print ind_â„‚;

opaque symbol â‡“_â‡‘ : Ï€á¶œ (`âˆ€á¶œ x: Clause, denote (reify_cl x) = (âŸ‡_to_âˆ¨á¶œ_rw x)) â‰”
begin
  apply ind_â„‚ (Î» u, denote (reify_cl u) = (âŸ‡_to_âˆ¨á¶œ_rw u))
  { reflexivity; }
  {
    assume x xs IH; simplify; rewrite IH; reflexivity
  }
end;


opaque symbol cl_perm_correct': Ï€á¶œ (`âˆ€á¶œ (a: Clause), `âˆ€á¶œ (b: Clause), (istrue (reify_cl a â©¦ reify_cl b)) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw a = âŸ‡_to_âˆ¨á¶œ_rw b)) â‰”
begin
  apply ind_â„‚ (Î» u, `âˆ€á¶œ (b: Clause), (istrue (reify_cl u â©¦ reify_cl b)) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw u = âŸ‡_to_âˆ¨á¶œ_rw b))
  {
    apply ind_â„‚ (Î» u,  (istrue (reify_cl â–© â©¦ reify_cl u)) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw â–© = âŸ‡_to_âˆ¨á¶œ_rw u))
    { simplify; apply â‡’á¶œáµ¢; assume Htop; reflexivity  }
    {
      assume x xs; simplify; assume H; apply â‡’á¶œáµ¢; assume contra; apply âŠ¥á¶œâ‚‘ contra
    }
  }
  {
    assume x xs IH; 
    apply ind_â„‚ (Î» u,  (istrue (reify_cl (x âŸ‡ xs) â©¦ reify_cl u)) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw (x âŸ‡ xs) = âŸ‡_to_âˆ¨á¶œ_rw u))
    {
      apply â‡’á¶œáµ¢; assume contra; apply âŠ¥á¶œâ‚‘ contra
    }
    {
      assume y ys;
      assume IH2;
      apply â‡’á¶œáµ¢; simplify â©¦; assume H;
      simplify âŸ‡_to_âˆ¨á¶œ_rw;
      refine @feq2á¶œ o o o (âˆ¨á¶œ) x y _ (âŸ‡_to_âˆ¨á¶œ_rw xs) (âŸ‡_to_âˆ¨á¶œ_rw ys) _
      {
        apply â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ y (âˆ€á¶œâ‚‘ x Pâ©¦_correct));
        refine (@and_elim1 (P x â©¦ P y) (reify_cl xs â©¦ reify_cl ys) H);
      }
      {
        refine  â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ys IH) (@and_elim2 (P x â©¦ P y) (reify_cl xs â©¦ reify_cl ys) H);
      }
    }
  }
end;



opaque symbol cl_perm_complete: Ï€á¶œ (`âˆ€á¶œ (a: Clause), `âˆ€á¶œ (b: Clause), (a = b) â‡’á¶œ (istrue (reify_cl a â©¦ reify_cl b))) â‰”
begin
  apply ind_â„‚ (Î» u, `âˆ€á¶œ b, (u = b) â‡’á¶œ  (istrue (reify_cl u â©¦ reify_cl b)))
  {
    apply ind_â„‚ (Î» u, (â–© = u) â‡’á¶œ istrue (reify_cl â–© â©¦ reify_cl u))
    { apply â‡’á¶œáµ¢; assume H; apply trivial }
    { assume x xs H; apply â‡’á¶œáµ¢;  assume j; refine âŠ¥á¶œâ‚‘ (â‡’á¶œâ‚‘ (@â–©â‰ âŸ‡ x xs) j); }
  }
  {
    assume x xs IH;
    apply ind_â„‚ (Î» u, ((x âŸ‡ xs) = u) â‡’á¶œ istrue (reify_cl (x âŸ‡ xs) â©¦ reify_cl u))
    { apply â‡’á¶œáµ¢; assume j; refine âŠ¥á¶œâ‚‘ (â‡’á¶œâ‚‘ (@âŸ‡â‰ â–© x xs) j); }
    {
      assume y ys IH2; apply â‡’á¶œáµ¢; assume H;
      have G: Ï€á¶œ ((x = y) âˆ§á¶œ (xs = ys)) { apply âŸ‡_inj H };
        have G1: Ï€á¶œ (x = y ) { apply âˆ§á¶œâ‚‘â‚  G };
        have G2: Ï€á¶œ (xs = ys) { apply âˆ§á¶œâ‚‘â‚‚  G };
        rewrite G1;
        rewrite left G2;
        refine â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ xs IH) _;
        reflexivity
    }
  }
end;

// cl_perm_correct' with parameter
opaque symbol cl_perm_correct a b : Ï€á¶œ (istrue (reify_cl a â©¦ reify_cl b)) â†’ Ï€á¶œ (âŸ‡_to_âˆ¨á¶œ_rw a = âŸ‡_to_âˆ¨á¶œ_rw b) â‰”
begin assume a b H; apply â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ b (âˆ€á¶œâ‚‘ a cl_perm_correct')) H end;

opaque symbol subst_equiv_clause : Î  x: Clause, Î  y: Clause, Ï€á¶œ (âŸ‡_to_âˆ¨á¶œ_rw x = âŸ‡_to_âˆ¨á¶œ_rw y) â†’ Ï€Ì‡ x â†’ Ï€Ì‡ y â‰”
begin
assume x y;
simplify;
assume Heq; assume Hx;
rewrite left Heq;
apply Hx
end;




// symbol u1: Prop;
// symbol u2: Prop;
// symbol p: Prop;

// symbol a0: Ï€Ì‡ (p âŸ‡ u1 âŸ‡ u2 âŸ‡ â–©);
// symbol a1: Ï€Ì‡ (u2 âŸ‡ u1 âŸ‡ Â¬ p âŸ‡ â–©);

// symbol foo: Ï€Ì‡ (u1 âŸ‡ u2 âŸ‡ â–©) â‰”
// begin
// have cut:  Ï€á¶œ (âŸ‡_to_âˆ¨á¶œ_rw (c âŸ‡ (b âˆ¨á¶œ b) âŸ‡ a âŸ‡ â–©) = âŸ‡_to_âˆ¨á¶œ_rw (a âŸ‡ (b âˆ¨á¶œ b) âŸ‡ c âŸ‡ â–©)) {
//   apply cl_perm_correct (c âŸ‡ (b âˆ¨á¶œ b) âŸ‡ a âŸ‡ â–©) (a âŸ‡ (b âˆ¨á¶œ b) âŸ‡ c âŸ‡ â–©);
//   apply trivial
// };
// refine subst_equiv_clause (c âŸ‡ (b âˆ¨á¶œ b) âŸ‡ a âŸ‡ â–©) (a âŸ‡ (b âˆ¨á¶œ b) âŸ‡ c âŸ‡ â–©) cut H;
// end;

// require open Stdlib.List;

// symbol not_found: Prop;

// symbol I: â„• â†’ â„‚;

// symbol reify_cl2: Stdlib.List.ğ•ƒ o â†’ Clause â†’ â„‚;

// rule reify_cl2 $varmap ($x âŸ‡ $xs) â†ª (I (index eq $x $varmap)) âŠ” (reify_cl2 $varmap $xs)
// with reify_cl2 $varmap â–© â†ª â¬“
// ;

// sequential symbol  Eq_â„‚: Stdlib.List.ğ•ƒ o â†’ â„‚ â†’ â„‚ â†’ ğ”¹;
// rule Eq_â„‚ $varmap (I $x) (I $y) â†ª eqn $x $y
// with Eq_â„‚ $varmap ($x âŠ” $xs) ($y âŠ” $ys) â†ª (Eq_â„‚ $varmap $x $y) Stdlib.Bool.and (Eq_â„‚ $varmap $xs $ys)
// with Eq_â„‚ $varmap â¬“ â¬“ â†ª true
// with Eq_â„‚ $varmap â¬“ (I _) â†ª false
// with Eq_â„‚ $varmap (I _) â¬“ â†ª false
// with Eq_â„‚ $varmap (_ âŠ” _) â¬“ â†ª false
// with Eq_â„‚ $varmap â¬“ (_ âŠ” _) â†ª false
// with Eq_â„‚ $varmap (I _) (_ âŠ” _) â†ª false
// with Eq_â„‚ $varmap (_ âŠ” _) (I _) â†ª false;

// opaque symbol eqn_correct x y : Ï€á¶œ (istrue(eqn x y)) â†’ Ï€á¶œ (x = y) â‰”
// begin
//   admit
// end;

// opaque symbol F_correct_env (varmap: Stdlib.List.ğ•ƒ o) : Ï€á¶œ (`âˆ€á¶œ (a: Clause), `âˆ€á¶œ (b: Clause), (istrue (Eq_â„‚ varmap (reify_cl2 varmap a) (reify_cl2 varmap b))) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw a = âŸ‡_to_âˆ¨á¶œ_rw b)) â‰”
// begin
//   assume varmap;
//   apply ind_â„‚ (Î» u, `âˆ€á¶œ (b: Clause), (istrue (Eq_â„‚ varmap (reify_cl2 varmap u) (reify_cl2 varmap b))) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw u = âŸ‡_to_âˆ¨á¶œ_rw b))
//   {
//     apply ind_â„‚ (Î» u,  (istrue (Eq_â„‚ varmap (reify_cl2 varmap â–©) (reify_cl2 varmap u))) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw â–© = âŸ‡_to_âˆ¨á¶œ_rw u))
//     { simplify; apply â‡’á¶œáµ¢; assume Htop; reflexivity  }
//     {
//       assume x xs; simplify; assume H; apply â‡’á¶œáµ¢; assume contra; apply âŠ¥á¶œâ‚‘ contra
//     }
//   }
//   {
//     assume x xs IH; 
//     apply ind_â„‚ (Î» u,  (istrue (Eq_â„‚ varmap (reify_cl2 varmap (x âŸ‡ xs)) (reify_cl2 varmap u))) â‡’á¶œ (âŸ‡_to_âˆ¨á¶œ_rw (x âŸ‡ xs) = âŸ‡_to_âˆ¨á¶œ_rw u))
//     {
//       apply â‡’á¶œáµ¢; assume contra; apply âŠ¥á¶œâ‚‘ contra
//     }
//     {
//       assume y ys;
//       assume IH2;
//       apply â‡’á¶œáµ¢; simplify reify_cl2; assume H;
//       //simplify âŸ‡_to_âˆ¨á¶œ_rw;
    
//       refine @feq2á¶œ o o o (âˆ¨á¶œ) x y _ (âŸ‡_to_âˆ¨á¶œ_rw xs) (âŸ‡_to_âˆ¨á¶œ_rw ys) _
//       {
//         have  G : Ï€á¶œ (eqn (index eq x varmap) (index eq y varmap)) {
//           refine (@and_elim2 (Eq_â„‚ varmap (reify_cl2 varmap xs) (reify_cl2 varmap ys)) (eqn (index eq x varmap) (index eq y varmap)) H)
//         };
//         have H_index_eq: Ï€á¶œ ((index eq x varmap) = (index eq y varmap)) {
//           refine eqn_correct  (index eq x varmap) (index eq y varmap) G
//         };
//         //FIXME: Prove that If varmap is not empty and index eq x varmap = index eq y varmap then x = y
//         admit
//       }
//       {
//         have  G : Ï€á¶œ (Eq_â„‚ varmap (reify_cl2 varmap xs) (reify_cl2 varmap ys)) {
//           refine (@and_elim1 (Eq_â„‚ varmap (reify_cl2 varmap xs) (reify_cl2 varmap ys)) (eqn (index eq x varmap) (index eq y varmap)) H)
//         };
//         refine  â‡’á¶œâ‚‘ (âˆ€á¶œâ‚‘ ys IH) G;
//       }
//     }
//   }
// end;