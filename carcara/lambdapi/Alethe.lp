require open Stdlib.HOL;
require open Stdlib.Bool;
require open Stdlib.Nat;
require open Stdlib.propExt;

notation Â¬ prefix 35;

// testing symbols
private symbol a: Prop;
private symbol b: Prop;
private symbol c: Prop;
private symbol d: Prop;
private symbol e: Prop;

symbol Bool â‰” o;

// Index symbol for having a total equality function
injective symbol ğ‘° [a]: â„• â†’ Ï„ a;

opaque symbol neg_âŠ¥ : Ï€ (Â¬ âŠ¥) â‰” begin refine (Î» x, x) end;

// # Clause
// Clauses are encoded with list Ã  la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

constant symbol clause: Set;
rule Ï„ clause â†ª Clause;

// Nil
constant symbol â–© : Clause;
// Cons
injective symbol âŸ‡: Prop â†’ Clause â†’ Clause;
notation âŸ‡ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause â†’ Clause â†’ Clause; notation ++ infix right 3;

rule â–© ++ $m â†ª $m
with ($x âŸ‡ $l) ++ $m â†ª $x âŸ‡ ($l ++ $m);

// Version similar to the one generated by Lambdapi induction tactic.
// symbol ind_â„‚ : Î  p: (Clause â†’ Prop), Ï€ (p â–©) â†’ (Î  x0: Ï„ o, Î  x1: Clause, Ï€ (p x1) â†’ Ï€ (p (x0 âŸ‡ x1))) â†’ Ï€ (`âˆ€ (x: Clause), p x);

symbol ind_â„‚ : Î  p: (Clause â†’ Prop), Ï€ (p â–©) â†’ (Î  x0: Ï„ o, Î  x1: Clause, Ï€ (p x1) â†’ Ï€ (p (x0 âŸ‡ x1))) â†’ Î  (x: Clause), Ï€ (p x);

constant symbol Clause_ind:  Î  P: (Clause â†’ Prop), Î  l,
  Ï€ (P â–©) â†’
  (Î  x: Prop, Î  l: Clause, Ï€ (P l) â†’ Ï€ (P (x âŸ‡ l))) â†’
  Ï€ (P l);

// some sanity checks
assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x âŸ‡ l ++ m â‰¡ x âŸ‡ (l ++ m);


sequential symbol âˆ¨_to_âŸ‡_rw: Prop â†’ Clause;
rule âˆ¨_to_âŸ‡_rw ($x âˆ¨ $y) â†ª $x âŸ‡ (âˆ¨_to_âŸ‡_rw $y)
with âˆ¨_to_âŸ‡_rw âŠ¥ â†ª  â–©;

sequential symbol âŸ‡_to_âˆ¨_rw: Clause â†’ Prop;
rule âŸ‡_to_âˆ¨_rw ($x âŸ‡ $y) â†ª $x âˆ¨ (âŸ‡_to_âˆ¨_rw $y)
with âŸ‡_to_âˆ¨_rw â–© â†ª âŠ¥;

assert âŠ¢ âŸ‡_to_âˆ¨_rw (a âŸ‡ b âŸ‡ â–©) â‰¡ a âˆ¨ b âˆ¨ âŠ¥;
assert âŠ¢ âˆ¨_to_âŸ‡_rw (a âˆ¨ b âˆ¨ âŠ¥ âˆ¨ c âˆ¨ âŠ¥) â‰¡ (a âŸ‡ b âŸ‡ âŠ¥ âŸ‡ c âŸ‡ â–©);

injective symbol Ï€Ì‡ c: TYPE â‰” Ï€ (âŸ‡_to_âˆ¨_rw c);

opaque symbol Ï€Ì‡â‚— [a] : Ï€Ì‡ (a âŸ‡ â–©)  â†’ Ï€ a â‰”
begin
  assume a Hcl_a;
  apply @âˆ¨â‚‘ a âŠ¥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply âŠ¥â‚‘ False; };
end;

// opaque injective symbol Ï€ p : TYPE â‰” Ï€ (Â¬ (Â¬ p));

// Introduction rule for Clause
// construct `p âŸ‡ q` from a clause with only `p`
opaque symbol âŸ‡áµ¢â‚ [p q] : Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp;
  apply âˆ¨â‚‘ Hp
  { assume Hpi_p; apply âˆ¨áµ¢â‚;  apply Hpi_p }
  { assume Hbot; apply âŠ¥â‚‘; apply Hbot }
end;

// construct `p âŸ‡ q` from a proof of `p`
opaque symbol âŸ‡áµ¢â‚' [p q] : Ï€ p â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp; apply âˆ¨áµ¢â‚; apply Hp
end;

opaque symbol âŸ‡áµ¢â‚‚ [p q] : Ï€Ì‡ q â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hq; apply âˆ¨áµ¢â‚‚; apply Hq
end;

// Elimination rule for clause
opaque symbol âŸ‡â‚‘ [p q r] : Ï€Ì‡ (p âŸ‡ q) â†’ (Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ r) â†’ (Ï€Ì‡ q â†’ Ï€Ì‡ r) â†’ Ï€Ì‡ r â‰”
begin
  assume p q r Hpq Hpr Hqr;
  apply âˆ¨â‚‘ Hpq
  { assume Hp; apply Hpr (âˆ¨áµ¢â‚ Hp) }
  { assume Hq; apply Hqr Hq }
end;


opaque symbol ++_to_âˆ¨ a b : Ï€ ((âŸ‡_to_âˆ¨_rw (a ++ b)) â‡”  ((âŸ‡_to_âˆ¨_rw a) âˆ¨ (âŸ‡_to_âˆ¨_rw b))) â‰”
begin
  assume a b;
  apply Clause_ind (Î» u, (âŸ‡_to_âˆ¨_rw (u ++ b)) â‡”  ((âŸ‡_to_âˆ¨_rw u) âˆ¨ (âŸ‡_to_âˆ¨_rw b))) a
    {
      apply âˆ§áµ¢
        { assume H; apply âˆ¨áµ¢â‚‚; apply H }
        {
          assume H;
          apply âˆ¨â‚‘ H { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ } { assume H1;  apply H1}
        }
    }
    {
      assume x l Hir;
      apply âˆ§áµ¢
      { assume H;   apply âˆ¨â‚‘ H
        {
          assume Hx;
          apply âˆ¨áµ¢â‚;
          apply âˆ¨áµ¢â‚;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: Ï€ ((x âˆ¨ (âŸ‡_to_âˆ¨_rw l âˆ¨ âŸ‡_to_âˆ¨_rw b)) â‡’ ((x âˆ¨ âŸ‡_to_âˆ¨_rw l) âˆ¨ âŸ‡_to_âˆ¨_rw b)) {
            refine âˆ§â‚‘â‚ (Stdlib.Prop.âˆ¨_assoc  x (âŸ‡_to_âˆ¨_rw l) (âŸ‡_to_âˆ¨_rw b));  //((x âˆ¨ (âŸ‡_to_âˆ¨_rw l âˆ¨ âŸ‡_to_âˆ¨_rw b)) â‡’ ((x âˆ¨ âŸ‡_to_âˆ¨_rw l) âˆ¨ âŸ‡_to_âˆ¨_rw b))
          };
          apply tmp;
          apply âˆ¨â‚‘ H
          {
            assume Hx;  apply âˆ¨áµ¢â‚; apply Hx
          }
          {
            assume Hl_or_b;
            apply âˆ¨áµ¢â‚‚;
            have HirLeft: Ï€ ((âŸ‡_to_âˆ¨_rw (l ++ b) â‡’ (âŸ‡_to_âˆ¨_rw l âˆ¨ âŸ‡_to_âˆ¨_rw b))) {
                refine (âˆ§â‚‘â‚ Hir);
            };
            apply HirLeft;
            apply Hl++b
          }
        }
      }
      {
        assume H;
        apply âˆ¨â‚‘ H {
            assume H1;
            apply âˆ¨â‚‘ H1 {
              assume Hx;
              apply âˆ¨áµ¢â‚;
              apply Hx;
            } {
              assume H2;
              apply âˆ¨áµ¢â‚‚;
              have tmp: Ï€ (((âŸ‡_to_âˆ¨_rw l âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨áµ¢â‚;
              apply H2
            }
        } {
          assume H1;
          apply âˆ¨áµ¢â‚‚;
          have tmp: Ï€ (((âŸ‡_to_âˆ¨_rw l âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨áµ¢â‚‚;
              apply H1
        }
      }
    }
end;

constant symbol nnpp_eq p : Ï€ ((Â¬ Â¬ p) = p);

// Axiom propositional_extensionality: forall (P Q : Prop), (P <-> Q) -> P = Q.
// Ï„ o â†ª Prop
constant symbol prop_ext [p: Prop] [q: Prop]: Ï€ (p â‡” q) â†’ Ï€ (p = q);

opaque symbol âŸº_ext [p: Prop] [q: Prop]:  Ï€ (p = q) â†’ Ï€ (p â‡” q) â‰”
begin
  assume p q Heq;  rewrite Heq; apply â‡”_refl
end;

opaque symbol iff_equiv_eq p q: Ï€ ((p â‡” q) = (p = q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume Hiff; apply prop_ext Hiff }
  { assume Heq; rewrite Heq; apply â‡”_refl }
end;

opaque symbol morgan1 p q : Ï€ (Â¬ (p âˆ§ q) = (Â¬ p âˆ¨ Â¬ q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    apply  not_and_or H
  }
  {
    assume H;
    refine or_not_and H
  }
end;

opaque symbol morgan2 p q : Ï€ (Â¬ (p âˆ¨ q) = (Â¬ p âˆ§ Â¬ q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    refine not_or_and H
  }
  {
    assume H;
    refine and_not_or H
  }
end;

opaque symbol distributive_or p q r : Ï€ ((p âˆ¨ (q âˆ§ r)) = ((p âˆ¨ q) âˆ§ (p âˆ¨ r))) â‰”
begin
  assume p q r;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    apply âˆ§áµ¢
    {
      apply âˆ¨â‚‘ H
      { assume Hp; apply âˆ¨áµ¢â‚; refine Hp }
      { assume Hqr; apply âˆ¨áµ¢â‚‚; refine âˆ§â‚‘â‚ Hqr }
    }
    {
      apply âˆ¨â‚‘ H
      { assume Hp; apply âˆ¨áµ¢â‚; refine Hp }
      { assume Hqr; apply âˆ¨áµ¢â‚‚; refine âˆ§â‚‘â‚‚ Hqr }
    }
  }
  {
    assume H;
    have H1: Ï€ (p âˆ¨ q) { apply âˆ§â‚‘â‚ H  };
    have H2: Ï€ (p âˆ¨ r) { apply âˆ§â‚‘â‚‚ H  };
    apply âˆ¨â‚‘ H1
    {
        assume Hp;
        apply âˆ¨â‚‘ H2
        {
          assume Hp';
          apply âˆ¨áµ¢â‚;
          apply Hp';
        }
        {
          assume Hr;
          apply âˆ¨áµ¢â‚;
          apply Hp;
        }
    }
    {
      assume Hq;
      apply âˆ¨â‚‘ H2
        {
          assume Hp';
          apply âˆ¨áµ¢â‚;
          apply Hp';
        }
        {
          assume Hr;
          apply âˆ¨áµ¢â‚‚;
          apply âˆ§áµ¢
          { refine Hq }
          { refine Hr }
        }
    };
  }
end;

opaque symbol distributive_and p q r : Ï€ ((p âˆ§ (q âˆ¨ r)) = ((p âˆ§ q) âˆ¨ (p âˆ§ r))) â‰”
begin
  assume p q r;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    have Hp: Ï€ p { apply âˆ§â‚‘â‚ H };
    have Hqorr: Ï€ (q âˆ¨ r) { apply âˆ§â‚‘â‚‚ H };
    apply âˆ¨â‚‘ Hqorr
    {
      assume Hq;
      apply âˆ¨áµ¢â‚;
      apply âˆ§áµ¢ { refine Hp } { refine Hq }
    }
    {
      assume Hr;
      apply âˆ¨áµ¢â‚‚;
      apply âˆ§áµ¢ { refine Hp } { refine Hr  }
    }
  }
  {
    assume H;
    apply âˆ¨â‚‘ H
    {
      assume Hpandq;
      apply âˆ§áµ¢ { refine âˆ§â‚‘â‚ Hpandq  } { apply âˆ¨áµ¢â‚; refine âˆ§â‚‘â‚‚ Hpandq }
    }
    {
      assume Hpandr;
      apply âˆ§áµ¢ { refine âˆ§â‚‘â‚ Hpandr  } { apply âˆ¨áµ¢â‚‚; refine âˆ§â‚‘â‚‚ Hpandr }
    }
  }
end;

opaque symbol or_idempotent p : Ï€ ((p âˆ¨ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume Hporp;
    apply âˆ¨â‚‘ Hporp
    { assume Hp; refine Hp }
    { assume Hp; refine Hp }
  }
  {
    assume Hp;
    apply âˆ¨áµ¢â‚;
    refine Hp
  }
end;

opaque symbol and_idempotent p : Ï€ ((p âˆ§ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume Hpandp; apply âˆ§â‚‘â‚ Hpandp; }
  {
    assume Hp;
    apply âˆ§áµ¢ { refine Hp } { refine Hp }
  }
end;

opaque symbol imp_eq_or p q: Ï€ (((Â¬ p) âˆ¨ q) =  (p â‡’ q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume Hor; refine or_to_imply Hor;  }
  { assume Himp; apply imply_to_or Himp }
end;

opaque symbol contrapos [p q] : Ï€ ((p â‡’ q)  â‡” (Â¬ q â‡’ Â¬ p)) â‰”
begin

  assume p q;
  apply âˆ§áµ¢
  {
    assume Himp;
    assume Hnq;
    assume Hp;
    have Hq: Ï€ q
    {  apply Himp Hp };
    apply Â¬â‚‘ Hnq Hq
  }
  {
    assume Himp;
    assume Hp;
    have Hor: Ï€ ((Â¬ Â¬ q) âˆ¨ Â¬ p) {
      rewrite imp_eq_or;
      refine Himp
    };
    apply âˆ¨â‚‘ Hor
    { assume Hnnq; rewrite left  nnpp_eq; refine Hnnq }
    { assume Hnp; apply  Â¬â‚‘ Hnp Hp }
  };
end;

// Alias name for `Â¬Â¬â‚‘`
opaque symbol contradiction p : (Ï€ (Â¬ p) â†’ Ï€ âŠ¥) â†’ Ï€ p â‰”
begin
  assume p Hnp;
  refine Â¬Â¬â‚‘ p Hnp
end;

// // Hilbert epsilon operator/choice
symbol Ïµ  [a]: (Ï„ a â†’ Prop) â†’ Ï„ a; notation Ïµ quantifier;

constant symbol Ïµáµ¢ [a] x (p: Ï„ a â†’ Prop) : Ï€ (p x) â†’ Ï€ (p (Ïµ p));
constant symbol Ïµ_det [a p q]: Î  (x: Ï„ a), Ï€ ((p x) â‡” (q x)) â†’ Ï€ (Ïµ p = Ïµ q);

opaque symbol Ïµ_to_âˆƒ [a] p: Ï€ ((`âˆƒ (x : Ï„ a),  p x) = p (`Ïµ (x : Ï„ a), p x)) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    apply âˆƒâ‚‘ H;
    assume x H1;
    apply Ïµáµ¢ x (Î» u, (p u)) H1;
  }
  {
    refine (âˆ§â‚‘â‚‚ (@contrapos (p (`Ïµ x, p x) ) (`âˆƒ x, p x))) _;
    assume H;
    have H1: Ï€ (`âˆ€ x, Â¬ p x) { apply ((âˆ§â‚‘â‚ (nex_forall p)) H) };
    refine H1 (`Ïµ x, p x);
  }
end;

opaque symbol Ïµ_to_âˆ€ [a] p: Ï€ ((`âˆ€ (x : Ï„ a), p x) = p (`Ïµ (x : Ï„ a), (Â¬ p x))) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    assume H;
    apply H (`Ïµ x, Â¬ (p x)) 
  }
  {
    simplify;
    refine (âˆ§â‚‘â‚‚ (@contrapos (p (`Ïµ x, Â¬ (p x)) ) (`âˆ€ x, p x))) _;
    assume H;
    
    have H1: Ï€ (`âˆƒ x, Â¬ p x) { refine ((âˆ§â‚‘â‚ (nforall_ex p)) H) };
    apply âˆƒâ‚‘ H1;
    assume x Hnpx;
    refine Ïµáµ¢ x (Î» u, Â¬ (p u)) Hnpx;
  }
end;

opaque  symbol and_identity_r x : Ï€ ((x âˆ§ âŠ¤) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume Hand; apply âˆ§â‚‘â‚ Hand  }
  { assume Hx; apply âˆ§áµ¢ { refine Hx } { refine âŠ¤áµ¢ } }
end;

opaque  symbol and_identity_l x : Ï€ ((âŠ¤ âˆ§ x) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§áµ¢
  { assume Hand; apply âˆ§â‚‘â‚‚ Hand  }
  { assume Hx; apply âˆ§áµ¢ { refine âŠ¤áµ¢ } { refine Hx } }
end;

opaque  symbol and_domination x : Ï€ ((x âˆ§ âŠ¥) = âŠ¥) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§áµ¢
  {  assume Hand; apply âˆ§â‚‘â‚‚ Hand  }
  {  assume Hx; apply âŠ¥â‚‘ Hx }
end;

opaque  symbol or_identity_l x : Ï€ ((âŠ¥ âˆ¨ x) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§áµ¢
  {  assume Hor; apply âˆ¨â‚‘ Hor { assume Hbot; apply âŠ¥â‚‘; refine Hbot } { assume Hx; refine Hx }  }
  {  assume Hx; apply âˆ¨áµ¢â‚‚; refine Hx }
end;

opaque  symbol or_identity_r x : Ï€ ((x âˆ¨ âŠ¥) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§áµ¢
  {  assume Hor; apply âˆ¨â‚‘ Hor { assume Hx; refine Hx } { assume Hbot; apply âŠ¥â‚‘; refine Hbot } }
  {  assume Hx; apply âˆ¨áµ¢â‚; refine Hx }
end;

opaque symbol Ïµ_equiv_âˆƒ' [a p] : Ï€ ((`âˆƒ (x: Ï„ a), p x) = (p (`Ïµ x, p x))) â‰”
begin
  assume a p;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    
    assume Hexist;
    apply âˆƒâ‚‘ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    
    assume Heps;
    apply âˆƒáµ¢ (`Ïµ x, p x);
    apply Heps
  }
end;

opaque symbol Ïµ_equiv_âˆƒ [a p] : Ï€ ((`âˆƒ x: Ï„ a, p x) â‡” (p (`Ïµ x, p x))) â‰”
begin
  assume a p;
  apply âˆ§áµ¢
  {
    
    assume Hexist;
    apply âˆƒâ‚‘ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    
    assume Heps;
    apply âˆƒáµ¢ (`Ïµ x, p x);
    apply Heps
  }
end;

constant symbol ite [a] (c: Ï„ o) (t e: Ï„ a): Ï„ a;

constant symbol ite_ind [a] : Î  (c: Ï„ o) (t e: Ï„ a) p,
  (Ï€ c â†’ Ï€ (p t))
  â†’ ((Ï€ c â†’ Ï€ âŠ¥) â†’ Ï€ (p e))
  â†’ Ï€ (p (@ite a c t e));

compute ite true true false;


opaque symbol âˆ¨_to_âŸ‡ a b: Ï€ (a âˆ¨ b) â†’ Ï€Ì‡ (a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b Haorb;
  apply âˆ¨â‚‘ Haorb
  { assume Ha;  apply âˆ¨áµ¢â‚; apply Ha }
  {  assume Hb; apply âˆ¨áµ¢â‚‚; apply âˆ¨áµ¢â‚; apply Hb }
end;

opaque symbol cong [a b] (f:Ï„ a â†’ Ï„ b) [x x':Ï„ a] : Ï€(x = x') â†’ Ï€(f x = f x') â‰”
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol cong2 [a b c] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c):
  Î  [x x':Ï„ a], Ï€ (x = x') â†’ Î  [y y':Ï„ b], Ï€ (y = y') â†’ Ï€ (f x y = f x' y') â‰”
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol cong3 [a b c d] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c â†’ Ï„ d):
  Î  [x x':Ï„ a], Ï€ (x = x') â†’ Î  [y y':Ï„ b], Ï€ (y = y') â†’ Î  [z z':Ï„ c], Ï€ (z = z') â†’ Ï€ (f x y z = f x' y' z') â‰”
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;

opaque symbol cong4 [a1 a2 a3 a4 a5] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5):
  Î  [x1 x1':Ï„ a1], Ï€ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€ (x4 = x4') â†’
  Ï€ (f x1 x2 x3 x4 = f x1' x2' x3' x4') â‰”
begin
  assume a1 a2 a3 a4 a5 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  reflexivity
end;

opaque symbol cong5 [a1 a2 a3 a4 a5 a6] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6):
  Î  [x1 x1':Ï„ a1], Ï€ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€ (x5 = x5') â†’
  Ï€ (f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  reflexivity
end;

opaque symbol cong6 [a1 a2 a3 a4 a5 a6 a7] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7):
  Î  [x1 x1':Ï„ a1], Ï€ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€ (x6 = x6') â†’
  Ï€ (f x1 x2 x3 x4 x5 x6 = f x1' x2' x3' x4' x5' x6') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  reflexivity
end;

opaque symbol cong7 [a1 a2 a3 a4 a5 a6 a7 a8] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7 â†’ Ï„ a8):
  Î  [x1 x1':Ï„ a1], Ï€ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€ (x6 = x6') â†’
  Î  [x7 x7':Ï„ a7], Ï€ (x7 = x7') â†’
  Ï€ (f x1 x2 x3 x4 x5 x6 x7 = f x1' x2' x3' x4' x5' x6' x7') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 a8 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  assume x7 x7' H7;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  rewrite H7;
  reflexivity
end;

opaque symbol cong8 [a1 a2 a3 a4 a5 a6 a7 a8 a9] (f : Ï„ a1 â†’ Ï„ a2 â†’ Ï„ a3 â†’ Ï„ a4 â†’ Ï„ a5 â†’ Ï„ a6 â†’ Ï„ a7 â†’ Ï„ a8 â†’ Ï„ a9):
  Î  [x1 x1':Ï„ a1], Ï€ (x1 = x1') â†’
  Î  [x2 x2':Ï„ a2], Ï€ (x2 = x2') â†’
  Î  [x3 x3':Ï„ a3], Ï€ (x3 = x3') â†’
  Î  [x4 x4':Ï„ a4], Ï€ (x4 = x4') â†’
  Î  [x5 x5':Ï„ a5], Ï€ (x5 = x5') â†’
  Î  [x6 x6':Ï„ a6], Ï€ (x6 = x6') â†’
  Î  [x7 x7':Ï„ a7], Ï€ (x7 = x7') â†’
  Î  [x8 x8':Ï„ a8], Ï€ (x8 = x8') â†’
  Ï€ (f x1 x2 x3 x4 x5 x6 x7 x8 = f x1' x2' x3' x4' x5' x6' x7' x8') â‰”
begin
  assume a1 a2 a3 a4 a5 a6 a7 a8 a9 f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  assume x6 x6' H6;
  assume x7 x7' H7;
  assume x8 x8' H8;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  rewrite H6;
  rewrite H7;
  rewrite H8;
  reflexivity
end;

opaque symbol ite1' [c t e] : Ï€ (ite c t e â‡’ c âˆ¨ e) â‰”
begin
  assume c t e;
  refine ite_ind c t e (Î» u, u â‡’ (c âˆ¨ e)) _ _
  {
    assume Hc;
    
    assume Ht;
    apply âˆ¨áµ¢â‚;
    apply Hc
  }
  {
    assume Hnc;
    
    assume He;
    apply âˆ¨áµ¢â‚‚;
    apply He
  }
end;

opaque symbol ite1 (c t e: Ï„ o) : Ï€ (ite c t e) â†’ Ï€Ì‡ (c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply ( (@ite1' c t e)) H;
end;

opaque symbol ite2' [c t e] : Ï€ (ite c t e â‡’ ((Â¬ c) âˆ¨ t)) â‰”
begin
  assume c t e;
  refine ite_ind c t e (Î» u, u â‡’ (Â¬ c âˆ¨ t)) _ _
  {
    assume Hc;
    
    assume Ht;
    apply âˆ¨áµ¢â‚‚;
    apply Ht
  }
  {
    assume Hc;
    
    assume He;
    remove He;
    apply âˆ¨áµ¢â‚;
    simplify;
    refine Hc
  };
end;

opaque symbol ite2 (c t e: Ï„ o) : Ï€ (ite c t e) â†’ Ï€Ì‡ ((Â¬ c) âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply ( (@ite2' c t e)) H;
end;

// Use it to unfold the definition of `Â¬`.
// The tactic simplify is to agressive.
opaque symbol negdef p : Ï€ ((p â‡’ âŠ¥) = Â¬ p) â‰”
begin
  simplify; reflexivity
end;

opaque symbol ite_pos1 [c t e] : Ï€Ì‡ ((Â¬ (ite c t e)) âŸ‡ c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply imply_to_or;
  
  assume H;
  simplify;
  rewrite or_identity_r;
  apply ( (@ite1' c t e)) H;
end;

opaque symbol ite_pos2 [c t e] : Ï€Ì‡ (Â¬ (ite c t e) âŸ‡ Â¬ c âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply imply_to_or;
  
  assume H;
  simplify;
  rewrite or_identity_r;
  apply ( (@ite2' c t e)) H;
end;

opaque symbol ite_neg1 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  apply ite_ind c t e (Î» u, u âˆ¨ (c âˆ¨ (e â‡’ âŠ¥)))
  {
    assume Hc; apply âˆ¨áµ¢â‚‚; apply âˆ¨áµ¢â‚; refine Hc
  }
  {
    assume Hnc; rewrite âˆ¨_com;
    rewrite left âˆ¨_assoc;
    apply âˆ¨áµ¢â‚‚;
    rewrite âˆ¨_com;
    apply em;
  };
end;

opaque symbol ite_neg2 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  apply ite_ind c t e (Î» u, u âˆ¨ ((c â‡’ âŠ¥)âˆ¨ (t â‡’ âŠ¥)))
  {
    assume Hnc; rewrite âˆ¨_com;
    rewrite left âˆ¨_assoc;
    apply âˆ¨áµ¢â‚‚;
    rewrite âˆ¨_com;
    apply em;
  }
  {
    assume Hc; apply âˆ¨áµ¢â‚‚; apply âˆ¨áµ¢â‚; refine Hc
  }
end;

opaque symbol not_ite1' [c t e] : Ï€ (Â¬ (ite c t e) â‡’ c âˆ¨ Â¬ e) â‰”
begin
  assume c t e;
  refine ite_ind c t e (Î» u, Â¬ u â‡’ c âˆ¨ Â¬ e) _ _
  {
    assume Hc;
    
    assume Hnt;
    apply âˆ¨áµ¢â‚;
    refine Hc;
  }
  {
    assume Hcimpbot;
    
    assume Hne;
    apply âˆ¨áµ¢â‚‚;
    refine Hne
  }
end;

opaque symbol not_ite1 [c t e] : Ï€ (Â¬ (ite c t e)) â†’ Ï€Ì‡( c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply ( (@not_ite1' c t e) H);
end;

opaque symbol not_ite2' [c t e] : Ï€ (Â¬ (ite c t e) â‡’ Â¬ c  âˆ¨ Â¬ t) â‰”
begin
  assume c t e;
  refine ite_ind c t e (Î» u, Â¬ u â‡’ Â¬ c  âˆ¨ Â¬ t) _ _
  { assume Hc;  assume Hnt; apply âˆ¨áµ¢â‚‚; refine Hnt }
  { assume Hcimpbot;  assume Hne; apply âˆ¨áµ¢â‚; simplify; refine Hcimpbot; }
end;

opaque symbol not_ite2 [c t e] : Ï€ (Â¬ (ite c t e)) â†’ Ï€Ì‡(Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  assume c t e H;
  simplify;
  rewrite or_identity_r;
  apply ( (@not_ite2' c t e) H);
end;

opaque symbol ite_cong [a] [c c': Ï„ o] [t t' e e': Ï„ a] : Ï€ (c = c') â†’ Ï€ (t = t') â†’ Ï€ (e = e') â†’ Ï€Ì‡(ite c t e = ite c' t' e' âŸ‡ â–©) â‰”
begin
  assume a c c' t t' e e' Hcc' Htt' Hee';
  simplify;
  rewrite or_identity_r;
  rewrite Hcc';
  rewrite Htt';
  rewrite Hee';
  reflexivity
end;

symbol xor a b â‰” ((Â¬ a) âˆ§ b) âˆ¨ (a âˆ§ (Â¬ b));

opaque symbol xor_pos1 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply imply_to_or;
  
  assume H;
  apply âˆ¨â‚‘ H
  { assume Hnab; apply âˆ¨áµ¢â‚‚;  apply âˆ¨áµ¢â‚; apply âˆ§â‚‘â‚‚ Hnab }
  { assume Hnab; apply âˆ¨áµ¢â‚; apply âˆ§â‚‘â‚ Hnab }
end;

opaque symbol xor_pos2 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ Â¬ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply imply_to_or;
  
  assume H;
  apply âˆ¨â‚‘ H
  { assume Hnab; apply âˆ¨áµ¢â‚; apply âˆ§â‚‘â‚ Hnab }
  { assume Hnab; apply âˆ¨áµ¢â‚‚;  apply âˆ¨áµ¢â‚; apply âˆ§â‚‘â‚‚ Hnab }
end;

opaque symbol xor_neg1 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨_assoc;
  rewrite âˆ¨_com;
  rewrite distributive_or;
  apply âˆ§áµ¢
  {
    rewrite or_identity_r;
    rewrite left âˆ¨_assoc;
    apply âˆ¨áµ¢â‚‚;
    rewrite âˆ¨_com;
    rewrite âˆ¨_assoc;
    apply âˆ¨áµ¢â‚;
    rewrite âˆ¨_com;
    apply em
  }
  {
    rewrite left âˆ¨_assoc;
    apply âˆ¨áµ¢â‚‚;
    rewrite left âˆ¨_assoc;
    apply âˆ¨áµ¢â‚‚;
    rewrite âˆ¨_com;
    rewrite âˆ¨_assoc;
    apply âˆ¨áµ¢â‚;
    apply em
  }
end;

opaque symbol xor_neg2 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ Â¬ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨_assoc;
  rewrite âˆ¨_com;
  rewrite distributive_or;
  apply âˆ§áµ¢
  {
    rewrite left âˆ¨_assoc;
    rewrite âˆ¨_com;
    rewrite distributive_or;
    apply âˆ§áµ¢
    {
      rewrite left âˆ¨_assoc;
      apply âˆ¨áµ¢â‚‚;
      rewrite âˆ¨_com;
      apply em
    }
    {
      rewrite âˆ¨_com;
      rewrite âˆ¨_assoc;
      apply âˆ¨áµ¢â‚;
      rewrite âˆ¨_com;
      rewrite left âˆ¨_assoc;
      apply âˆ¨áµ¢â‚‚;
      rewrite or_identity_r;
      apply em
    }
  }
  {
    rewrite left âˆ¨_assoc;
    rewrite âˆ¨_com;
    rewrite distributive_or;
    apply âˆ§áµ¢
    {
      rewrite âˆ¨_com;
      rewrite âˆ¨_assoc;
      apply âˆ¨áµ¢â‚;
      rewrite âˆ¨_assoc;
      apply âˆ¨áµ¢â‚;
      apply em
    }
    {
      rewrite âˆ¨_com;
      rewrite âˆ¨_assoc;
      rewrite or_identity_r;
      apply âˆ¨áµ¢â‚;
      rewrite âˆ¨_com;
      rewrite left âˆ¨_assoc;
      apply âˆ¨áµ¢â‚‚;
      apply em
    }
  }
end;

// // i â–· ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘n
// // j â–· ğœ‘1 , â‹¯ , ğœ‘n
constant symbol or [a b] : Ï€Ì‡ ((a âˆ¨ b) âŸ‡ â–©) â†’ Ï€Ì‡ (âˆ¨_to_âŸ‡_rw  (a âˆ¨ b));

opaque symbol not_not x : Ï€Ì‡ ( (Â¬ (Â¬ (Â¬ x))) âŸ‡ x âŸ‡ â–©) â‰”
begin
  assume x;
  apply imply_to_or;
  assume H;
  apply âˆ¨áµ¢â‚; 
  refine Â¬Â¬â‚‘ x H
end;

opaque symbol implies [Ï†â‚ Ï†â‚‚] : Ï€ (Ï†â‚ â‡’ Ï†â‚‚) â†’ Ï€Ì‡ (Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ HÏ†â‚â‡’Ï†â‚‚;
  apply imply_to_or;
  
  assume Ï€Ï†â‚;
  apply âˆ¨áµ¢â‚;
  apply  HÏ†â‚â‡’Ï†â‚‚ Ï€Ï†â‚
end;

opaque symbol not_implies1 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬ (Ï†â‚ â‡’ Ï†â‚‚)) â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚â‡’Ï†â‚‚;
  apply âˆ¨áµ¢â‚;
  apply âˆ§â‚‘â‚ (imply_to_and Hnot_Ï†â‚â‡’Ï†â‚‚)
end;

opaque symbol not_implies2 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬ (Ï†â‚ â‡’ Ï†â‚‚)) â†’  Ï€Ì‡ (Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚â‡’Ï†â‚‚;
  apply âˆ¨áµ¢â‚;
  apply âˆ§â‚‘â‚‚ (imply_to_and Hnot_Ï†â‚â‡’Ï†â‚‚)
end;

opaque symbol implies_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ â‡’ Ï†â‚‚ âŸ‡ Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨_assoc;
  apply âˆ¨áµ¢â‚;
  rewrite .[(Â¬ Ï†â‚) âˆ¨ Ï†â‚‚] âˆ¨_com;
  rewrite left âˆ¨_assoc;
  apply âˆ¨áµ¢â‚‚;
  rewrite âˆ¨_com;
  apply em
end;

opaque symbol implies_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ â‡’ Ï†â‚‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨_assoc;
  apply âˆ¨áµ¢â‚;
  rewrite left âˆ¨_assoc;
  apply âˆ¨áµ¢â‚‚;
  apply em
end;

opaque symbol equiv1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©) â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨â‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€ (Ï†â‚ â‡” Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    have H2: Ï€ (Ï†â‚ â‡’ Ï†â‚‚) { apply âˆ§â‚‘â‚ Hequiv' };
    have H3: Ï€ (Ï†â‚‚ â‡’ Ï†â‚) { apply âˆ§â‚‘â‚‚ Hequiv' };
    have Hassoc: Ï€ (((Â¬ Ï†â‚) âˆ¨ (Ï†â‚‚ âˆ¨ âŠ¥)) â‡”  (((Â¬ Ï†â‚) âˆ¨ Ï†â‚‚) âˆ¨ âŠ¥)) {
      apply (@Stdlib.Prop.âˆ¨_assoc (Â¬ Ï†â‚) Ï†â‚‚ âŠ¥);
    };
    have Hassoc_left: Ï€ ((((Â¬ Ï†â‚) âˆ¨ Ï†â‚‚) âˆ¨ âŠ¥)  â‡’  ((Â¬ Ï†â‚) âˆ¨ (Ï†â‚‚ âˆ¨ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply  Hassoc_left;
    apply âˆ¨áµ¢â‚;
    apply imply_to_or;
    refine H2;
  }
  {
    assume Hbot;
    apply âˆ¨áµ¢â‚‚;
    apply âˆ¨áµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨â‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€ (Ï†â‚ â‡” Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    have H2: Ï€ (Ï†â‚ â‡’ Ï†â‚‚) { apply âˆ§â‚‘â‚ Hequiv' };
    have H3: Ï€ (Ï†â‚‚ â‡’ Ï†â‚) { apply âˆ§â‚‘â‚‚ Hequiv' };
    have Hassoc: Ï€ ((Ï†â‚ âˆ¨ ((Â¬ Ï†â‚‚) âˆ¨ âŠ¥)) â‡”  ((Ï†â‚ âˆ¨ (Â¬ Ï†â‚‚)) âˆ¨ âŠ¥)) {
      apply (@Stdlib.Prop.âˆ¨_assoc Ï†â‚ (Â¬ Ï†â‚‚) âŠ¥);
    };
    have Hassoc_left: Ï€ (((Ï†â‚ âˆ¨ (Â¬ Ï†â‚‚)) âˆ¨ âŠ¥)  â‡’  (Ï†â‚ âˆ¨ ((Â¬ Ï†â‚‚) âˆ¨ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply  Hassoc_left;
    apply âˆ¨áµ¢â‚;
    rewrite âˆ¨_com;
    apply imply_to_or;
    refine H3;
  }
  {
    assume Hbot;
    apply âˆ¨áµ¢â‚‚;
    apply âˆ¨áµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv_pos1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  assume Heq;
  rewrite Heq;
  rewrite âˆ¨_assoc;
  apply âˆ¨áµ¢â‚;
  apply em
end;

opaque symbol equiv_pos2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ (Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  assume Heq;
  rewrite or_identity_r;
  rewrite âˆ¨_com;
  rewrite Heq;
  apply em
end;

opaque symbol equiv_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  rewrite âˆ¨_com;
  rewrite left âˆ¨_assoc;
  apply imply_to_or;
  
  assume Hp;
  apply imply_to_or;
  
  assume Hq;
  apply prop_ext;
  apply âˆ§áµ¢
  {  assume Hp'; apply Hq }
  {  assume Hq'; apply Hp }
end;

opaque symbol equiv_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  rewrite left iff_equiv_eq;
  rewrite âˆ¨_com;
  simplify;
  rewrite distributive_or; //(p âˆ¨ q) (p â‡’ q) (q â‡’ p);
  apply âˆ§áµ¢
  {
    rewrite left imp_eq_or;
    rewrite left âˆ¨_assoc;
    rewrite .[(Â¬ p) âˆ¨ q] âˆ¨_com;
    rewrite  .[q âˆ¨ (q âˆ¨ Â¬ p)] âˆ¨_assoc;
    rewrite or_idempotent;
    rewrite .[q âˆ¨ (Â¬ p)] âˆ¨_com;
    rewrite âˆ¨_assoc;
    apply âˆ¨áµ¢â‚;
    apply em
  }
  {
    rewrite left imp_eq_or;
    rewrite âˆ¨_assoc;
    rewrite .[p âˆ¨ q] âˆ¨_com;
    rewrite left .[((q âˆ¨ p) âˆ¨ Â¬ q)] âˆ¨_assoc;
    apply âˆ¨áµ¢â‚;
    rewrite .[p âˆ¨ Â¬ q] âˆ¨_com;
    rewrite âˆ¨_assoc;
    apply âˆ¨áµ¢â‚;
    apply em
  }
end;

opaque symbol implies_pos [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ â‡’ Ï†â‚‚)) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume x y;
  rewrite or_identity_r;
  rewrite left imp_eq_or (x â‡’ y) âŠ¥;
  rewrite left imp_eq_or x âŠ¥;
  rewrite left imp_eq_or;
  rewrite or_identity_r;
  rewrite or_identity_r;
  rewrite âˆ¨_com;
  refine @em ((x â‡’ âŠ¥) âˆ¨ y)
end;

opaque symbol not_symm [a] [x y: Ï„ a] : Ï€ (Â¬ (x = y) â‡’ (Â¬ (y = x))) â‰”
begin
  assume a x y H;
  assume H2;
  apply H;
  symmetry;
  apply H2
end;

symbol trans [U] [a b c: Ï„ U]: Ï€Ì‡ (a = b âŸ‡ â–©) â†’ Ï€Ì‡ (b = c âŸ‡ â–©) â†’ Ï€Ì‡ (a = c âŸ‡ â–©) â‰”
begin
  assume U a b c H1 H2;
  apply âˆ¨áµ¢â‚;
  have H2': Ï€ (b = c) { apply Ï€Ì‡â‚— H2 };
  have H1': Ï€ (a = b) { apply Ï€Ì‡â‚— H1 };
  rewrite H1';
  apply H2'
end;

opaque symbol subproof [Ï†â‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ïˆ HÏ†â‚ HÏˆ;
  apply âˆ¨áµ¢â‚‚;
  apply âˆ¨áµ¢â‚;
  apply HÏˆ
end;

opaque symbol forall_inst1 [a] p (x: Ï„ a) : Ï€ (Â¬ (`âˆ€ x', p x') âˆ¨ (p x)) â‰”
begin
 assume a p x;
 rewrite imp_eq_or;
 assume H;
 apply H
end;

opaque symbol forall_inst2 [a] p (x y: Ï„ a) : Ï€ (Â¬ (`âˆ€ a, `âˆ€ b, p a b) âˆ¨ (p x y)) â‰”
begin
  assume a p x y;
  rewrite imp_eq_or;
  assume H;
  apply H
 end;

opaque symbol forall_inst3 [a] [p] (x y z: Ï„ a) : Ï€ ((Â¬ (`âˆ€ a, `âˆ€ b, `âˆ€ c, p a b c)) âˆ¨ ((p x y z) âˆ¨ âŠ¥)) â‰”
begin
  assume a p x y z;
  apply imply_to_or;
  assume H;
  rewrite or_identity_r;
  apply H
end;

symbol Arity (a b: Set): Ï„ nat â†’ Set;
rule Arity $a $b 0 â†ª $b
with Arity $a $b ($n +1) â†ª $a â¤³ (Arity $a $b $n);

// # In Predicate
//
// The In predicate works with ğ”¹ instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// â–· `$x â‡” $x â†ª âŠ¤` to replace `eq $x $h` and,
// â–· `_ âˆ¨ âŠ¤ â†ª âŠ¤` for `or _ true â†ª true`.
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral âŠ¤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// âŠ¢ (ğœ‘1 âˆ¨ â‹¯ âˆ¨ âŠ¤ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
// then we will have
// âŠ¢ In_âˆ¨ ğœ‘k (ğœ‘1 âˆ¨ â‹¯ âˆ¨ âŠ¤ â‹¯ âˆ¨ ğœ‘ğ‘›)  (apply or_neg)
// âŠ¢ In_âˆ¨ ğœ‘k âŠ¤  (by simplification)
// we got stuck...

// Decidable equality in ğ”¹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.

// symbol ğ‘° [a]: â„• â†’ Ï„ a;

sequential symbol eq : Prop â†’ Prop â†’ ğ”¹;
rule eq $x $x â†ª true
with eq $x $y â†ª false;

sequential symbol In_âˆ§: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§ $x ($h âˆ§ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§ $x $tl)
with In_âˆ§ $x âŠ¤ â†ª false;

sequential symbol In_âˆ¨: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨ $x ($h âˆ¨ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨ $x $tl)
with In_âˆ¨ _ âŠ¥ â†ª false;

sequential symbol In_âˆ§': Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§' $x ($h âˆ§ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§' $x $tl)
with In_âˆ§' $x $h â†ª (eq $x $h);

sequential symbol In_âˆ¨': Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨' $x ($h âˆ¨ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨' $x $tl)
with In_âˆ¨' $x $h â†ª (eq $x $h);


// symbol and_pos [Ï†â‚__Ï†â‚™ Ï†â‚–]:  Ï€ ((In_âˆ§' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚__Ï†â‚™ âŸ‡ Ï†â‚– âŸ‡ â–©);

// opaque symbol test_and_pos: Ï€Ì‡ ((Â¬ (a âˆ§ b âˆ§ c âˆ§ d)) âŸ‡ d âŸ‡ â–©) â‰”
// begin
//   apply and_pos;
//   reflexivity;
// end;

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
// sequential symbol and_neg_r: Prop â†’ Clause â†’ ğ”¹;
// rule and_neg_r ($x âˆ§ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª and_neg_r $tl $tl2
// with and_neg_r âŠ¤ â–© â†ª true;

// sequential symbol and_neg_r': Prop â†’ Clause â†’ ğ”¹;
// rule and_neg_r' ($x âˆ§ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª and_neg_r' $tl $tl2
// with and_neg_r' ($x) (($x â‡’ âŠ¥) âŸ‡ â–©) â†ª true;
// //with and_neg_r âŠ¤ â–© â†ª true;

// symbol and_neg [l1 l2]: Ï€ (and_neg_r' l1 l2 = true) â†’ Ï€Ì‡ (l1 âŸ‡ l2);

// opaque symbol test_and_neg: Ï€Ì‡ ((a âˆ§ b âˆ§ c âˆ§ d) âŸ‡ (Â¬ a) âŸ‡ (Â¬ b) âŸ‡ (Â¬ c) âŸ‡ (Â¬ d) âŸ‡ â–©) â‰”
// begin
//   apply and_neg;
//   reflexivity;
// end;

// or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
// sequential symbol or_pos_r: Prop â†’ Clause â†’ ğ”¹;
// rule or_pos_r ($x âˆ¨ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r $tl $tl2
// with or_pos_r âŠ¥ â–© â†ª true;

// sequential symbol or_pos_r': Prop â†’ Clause â†’ ğ”¹;
// rule or_pos_r' ($x âˆ¨ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r' $tl $tl2
// with or_pos_r' $x ($x âŸ‡ â–©) â†ª true;

// symbol or_pos [l1 l2]: Ï€ (or_pos_r' l1 l2 = true) â†’ Ï€Ì‡ (Â¬ l1 âŸ‡ l2);

// opaque symbol test_or_pos: Ï€Ì‡ (Â¬ (a âˆ¨ b âˆ¨ c âˆ¨ d) âŸ‡ a âŸ‡ b âŸ‡ c âŸ‡ d âŸ‡ â–©) â‰”
// begin
//   apply or_pos; reflexivity
// end;

// or_neg:
// i. â–· (ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
// symbol or_neg [Ï†â‚__Ï†â‚™] Ï†â‚–:  Ï€ ((In_âˆ¨' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ Â¬ Ï†â‚– âŸ‡ â–©);

// opaque symbol test_or_neg: Ï€Ì‡ (((a âˆ¨ b âˆ¨ c âˆ¨ d)) âŸ‡ Â¬ c âŸ‡ â–©) â‰”
// begin
//   apply or_neg; reflexivity
// end;


// symbol not_or [Ï†â‚–] Ï†â‚__Ï†â‚™: Ï€ (Â¬ Ï†â‚__Ï†â‚™) â†’ Ï€ ((In_âˆ¨' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚– âŸ‡ â–©);

// opaque symbol identity_âŠ¥ [x] : Ï€ (x âˆ¨ âŠ¥) â†’ Ï€ x â‰”
// begin
//   assume x H;
//   apply âˆ¨â‚‘ H
//   { assume Hx; apply Hx } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
// end;

// opaque symbol test_not_or: Ï€Ì‡ (Â¬ (a âˆ¨ b âˆ¨ c âˆ¨ d) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ c âŸ‡ â–©) â‰”
// begin
//   assume H; // i
//   apply not_or (a âˆ¨ b âˆ¨ c âˆ¨ d)
//     { apply Ï€Ì‡â‚—; apply H }
//     { reflexivity }
// end;

// not_and:
// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
// sequential symbol not_and_r: Prop â†’ Clause â†’ ğ”¹;
// rule not_and_r ($x âˆ§ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª not_and_r $tl $tl2
// with not_and_r âŠ¤ â–© â†ª true;

// sequential symbol not_and_r': Prop â†’ Clause â†’ ğ”¹;
// rule not_and_r' ($x âˆ§ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª not_and_r' $tl $tl2
// with not_and_r' $x (($x â‡’ âŠ¥) âŸ‡ â–©) â†ª true;

// symbol not_and [l1 l2]: Ï€ (Â¬ l1) â†’ Ï€ (not_and_r' l1 l2 = true) â†’ Ï€Ì‡ l2;

// opaque symbol test_not_and: Ï€Ì‡ (Â¬ (a âˆ§ b âˆ§ c âˆ§ d) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ a âŸ‡ Â¬ b âŸ‡ Â¬ c âŸ‡ Â¬ d âŸ‡ â–©) â‰”
// begin
//   assume t1;
//   apply not_and (Ï€Ì‡â‚— t1);
//   reflexivity
// end;

// and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol and [Ï†â‚–] Ï†â‚__Ï†â‚™ : Ï€ ((In_âˆ§' Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚– âŸ‡ â–©);

opaque symbol test_and:  Ï€Ì‡ ((a âˆ§ b âˆ§ c âˆ§ d) âŸ‡ â–©) â†’  Ï€Ì‡ (c âŸ‡ â–©) â‰”
begin
  assume t1;
  apply and ((a âˆ§ b âˆ§ (c âˆ§ d))) { simplify; reflexivity } { apply t1  };
end;

opaque symbol resolutionâ‚— x a b: Ï€Ì‡ (x âŸ‡ a) â†’ Ï€Ì‡ ((Â¬ x) âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hx;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b)  â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨â‚‘ Hx { assume Hpi_x;  apply âˆ¨â‚‘ Hnx { assume Hpi_nx;  apply Â¬â‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b)  â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨áµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨áµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply   tmp;
      apply âˆ¨áµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol resolutionáµ£ x a b: Ï€Ì‡ ((Â¬ x) âŸ‡ a) â†’ Ï€Ì‡ (x âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hnx;
    apply âŸ‡â‚‘ H2 {
      assume Hx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨â‚‘ Hx { assume Hpi_x;  apply âˆ¨â‚‘ Hnx { assume Hpi_nx;  apply Â¬â‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b)  â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨áµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨áµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨_rw a âˆ¨ âŸ‡_to_âˆ¨_rw b) â‡’ âŸ‡_to_âˆ¨_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨ a b);
      };
      apply  tmp;
      apply âˆ¨áµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol bind_âˆƒ [a p q]: (Î  x, Ï€ (p x = q x))  â†’ Ï€ ((`âˆƒ (x: Ï„ a), p x) = (`âˆƒ (x: Ï„ a), q x)) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    
    assume H1;
    apply âˆƒâ‚‘ H1;
    assume x Hpx;
    apply âˆƒáµ¢ x;
    simplify;
    rewrite left (H x);
    apply Hpx;
  }
  {
    
    assume H1;
    apply âˆƒâ‚‘ H1;
    assume x Hqx;
    apply âˆƒáµ¢ x;
    simplify;
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_âˆ€ [a p q]: (Î  (x: Ï„ a), Ï€ (p x = q x))  â†’ Ï€ ((`âˆ€ (x: Ï„ a), p x) = (`âˆ€ (x: Ï„ a), q x)) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    
    assume H1;
    assume x;
    have Hpx: Ï€ (p x) { apply H1; };
    rewrite left (H x);
    apply Hpx;
  }
  {
    
    assume H1;
    assume x;
    have Hqx: Ï€ (q x) { apply H1 };
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_âˆ€' [a p q]: (Î  (x: Ï„ a), Î  (y: Ï„ a), Ï€ (x = y) â†’ Ï€ (p x = q y))  â†’ Ï€ ((`âˆ€ (x: Ï„ a), p x) = (`âˆ€ (y: Ï„ a), q y)) â‰”
begin
  assume a p q;
  assume H;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    
    assume H1;
    assume x;
    have Hpx: Ï€ (p x) { apply H1; };
    rewrite left H x x (eq_refl x);
    apply Hpx
  }
  {
    
    assume H1;
    assume x;
    have Hqx: Ï€ (q x) { apply H1 };
    rewrite H x x (eq_refl x);
    apply Hqx;
  };
end;

opaque symbol sko_forall [a p q]: (Î  (x: Ï„ a), Ï€ (x = `Ïµ (y: Ï„ a), Â¬ (p y)) â†’ Ï€ (p x = q))  â†’ Ï€ ((`âˆ€ (x: Ï„ a), p x) = q) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§áµ¢
  {
    refine  (âˆ§â‚‘â‚‚ (@contrapos (`âˆ€ x, p x) q)) _;
    assume Hnq;
    rewrite .[x in Â¬ x]  (Ïµ_to_âˆ€ p);
    have H1:  Ï€ (p (`Ïµ x, Â¬ (p x)) = q) { apply H; reflexivity };
    rewrite H1;
    refine Hnq
  }
  {
    rewrite .[x in _ â‡’ x]  (Ïµ_to_âˆ€ p);
    
    assume Hq;
    have H1:  Ï€ (p (`Ïµ y, Â¬ (p y)) = q) { apply H; reflexivity };
    rewrite H1;
    apply Hq
  }
end;

// Inductive t A : nat -> Type :=
//   |nil : t A 0
//   |cons : forall (h:A) (n:nat), t A n -> t A (S n).
(a: Set) inductive Vec: â„• â†’ TYPE â‰”
| â§ˆ : Vec a 0 // \Box
| cons [n: â„•] : Ï„ a â†’  Vec a n  â†’  Vec a (n + 1);

print Vec;

constant symbol vec : Set â†’ â„• â†’ Set;
rule Ï„ (vec $a $n) â†ª Vec $a $n;

symbol distinct [a] [n: Ï„ nat]  : Vec a n â†’ Prop;

// // boolean case
rule distinct (cons _ â§ˆ) â†ª âŠ¤
with distinct (cons $x (cons $y â§ˆ)) â†ª ($x â‰  $y)
with distinct â§ˆ â†ª âŠ¥
with distinct (cons _ (cons _ (cons _ _))) â†ª âŠ¥;


// 
assert âŠ¢ distinct (cons a â§ˆ) â‰¡ âŠ¤;
assert âŠ¢ distinct ((cons a (cons b â§ˆ))) â‰¡ (a â‰  b);
assert âŠ¢ distinct (cons a (cons b (cons c â§ˆ))) â‰¡ âŠ¥;
assert âŠ¢ distinct (cons a (cons b (cons c (cons d â§ˆ)))) â‰¡ âŠ¥;


assert âŠ¢ distinct (cons 1 â§ˆ) â‰¡ âŠ¤;
assert âŠ¢ distinct ((cons 1 (cons 2 â§ˆ))) â‰¡ (1 â‰  2);
assert âŠ¢ distinct (cons 1 (cons 2 (cons 3 â§ˆ))) â‰¡ âŠ¥;

opaque symbol distinct_elim  [a] [t: Ï„ a] : Ï€ (distinct (cons t â§ˆ) = âŠ¤) â‰” eq_refl (distinct(cons t â§ˆ));

opaque symbol distinct_elimâ‚‚ [a] [x y: Ï„ a] : Ï€ ((distinct ((cons x (cons y â§ˆ)))) = (x â‰  y)) â‰” eq_refl (distinct (cons x (cons y â§ˆ)));

//opaque symbol distinct_elimâ‚ƒ [a] [n: Ï„ nat] [v: Vec a (n + 3)] : Ï€ (distinct v = âŠ¥) â‰”  eq_refl (distinct v);

opaque symbol feq [a b] (f:Ï„ a â†’ Ï„ b) [x x':Ï„ a] : Ï€(x = x') â†’ Ï€(f x = f x') â‰”
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol feq2 [a b c] (f:Ï„ a â†’ Ï„ b â†’ Ï„ c):
  Î  [x x':Ï„ a], Ï€(x = x') â†’ Î  [y y':Ï„ b], Ï€(y = y') â†’ Ï€(f x y = f x' y') â‰”
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol feq3 [a b c d] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c â†’ Ï„ d):
  Î  [x x':Ï„ a], Ï€(x = x') â†’ Î  [y y':Ï„ b], Ï€(y = y') â†’ Î  [z z':Ï„ c], Ï€(z = z') â†’ Ï€(f x y z = f x' y' z') â‰”
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;

opaque symbol feq4 [a b c d e] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c â†’ Ï„ d â†’ Ï„ e):
  Î  [x1 x1':Ï„ a], Ï€(x1 = x1') â†’
  Î  [x2 x2':Ï„ b], Ï€(x2 = x2') â†’
  Î  [x3 x3':Ï„ c], Ï€(x3 = x3') â†’
  Î  [x4 x4':Ï„ d], Ï€(x4 = x4') â†’
  Ï€(f x1 x2 x3 x4 = f x1' x2' x3' x4') â‰”
begin
  assume a b c d e f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  reflexivity
end;

opaque symbol feq5 [a b c d e g] (f:Ï„ a â†’ Ï„ b â†’  Ï„ c  â†’ Ï„ d â†’ Ï„ e â†’ Ï„ g ):
  Î  [x1 x1':Ï„ a], Ï€(x1 = x1') â†’
  Î  [x2 x2':Ï„ b], Ï€(x2 = x2') â†’
  Î  [x3 x3':Ï„ c], Ï€(x3 = x3') â†’
  Î  [x4 x4':Ï„ d], Ï€(x4 = x4') â†’
  Î  [x5 x5':Ï„ e], Ï€(x5 = x5') â†’
  Ï€(f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5') â‰”
begin
  assume a b c d e g f;
  assume x1 x1' H1;
  assume x2 x2' H2;
  assume x3 x3' H3;
  assume x4 x4' H4;
  assume x5 x5' H5;
  rewrite H1;
  rewrite H2;
  rewrite H3;
  rewrite H4;
  rewrite H5;
  reflexivity
end;

builtin "bot" â‰” âŠ¥;
builtin "top" â‰” âŠ¤;
builtin "imp" â‰” â‡’;
builtin "and" â‰” âˆ§;
builtin "or"  â‰” âˆ¨;
builtin "not" â‰” Â¬;
builtin "eqv"  â‰” â‡”;

opaque symbol cong_or [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ ((t1 âˆ¨ t2) = (u1 âˆ¨ u2) âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨áµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

opaque symbol cong_and [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ ((t1 âˆ§ t2) = (u1 âˆ§ u2) âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨áµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

opaque symbol cong_imp [t1 t2 u1 u2: Ï„ o]: Ï€Ì‡ (t1 = u1 âŸ‡ â–©) â†’ Ï€Ì‡ (t2 = u2 âŸ‡ â–©) â†’ Ï€Ì‡ ((t1 â‡’ t2) = (u1 â‡’ u2) âŸ‡ â–©) â‰”
begin
  assume t1 t2 u1 u2 H1 H2;
  have H1': Ï€ (t1 = u1) { apply Ï€Ì‡â‚— H1 };
  have H2': Ï€ (t2 = u2) { apply Ï€Ì‡â‚— H2 };
  apply âˆ¨áµ¢â‚;
  rewrite H1';
  rewrite H2';
   reflexivity
end;

// symbol head : Clause â†’ Ï„ o;

// rule head â–© â†ª âŠ¥
// with head ($x âŸ‡ _) â†ª $x;

// symbol behead  : Clause â†’ Clause;

// rule behead â–© â†ª â–©
// with behead (_ âŸ‡ $l) â†ª $l;

// symbol âˆ¨_left: Ï„ o â†’ Ï„ o;
// rule âˆ¨_left ($x âˆ¨ _) â†ª $x;

// symbol âˆ¨_right: Ï„ o â†’ Ï„ o;
// rule âˆ¨_right (_ âˆ¨ $y) â†ª $y;

// opaque symbol âŸ‡_inj [x:Ï„ o] [l y m] : Ï€ ((x âŸ‡ l) = (y âŸ‡ m)) â†’ Ï€ ((x = y) âˆ§ (l = m)) â‰”
// begin
//   assume x l y m e;
//    apply âˆ§áµ¢ { apply feq head e } { apply feq behead e }
// end;

// opaque symbol âˆ¨_inj [x:Ï„ o] [l y m] : Ï€ ((x âˆ¨ l) = (y âˆ¨ m)) â†’ Ï€ ((x = y) âˆ§ (l = m)) â‰”
// begin
//   assume x l y m e; apply âˆ§áµ¢ { refine feq (âˆ¨_left) e } { refine feq (âˆ¨_right) e }
// end;

// opaque symbol âˆ¨_inj2 [x:Ï„ o] [l y m] : Ï€ ((x âˆ¨ âŸ‡_to_âˆ¨_rw l) = (y âˆ¨ âŸ‡_to_âˆ¨_rw m)) â†’ Ï€ ((x = y) âˆ§ (âŸ‡_to_âˆ¨_rw l = âŸ‡_to_âˆ¨_rw m)) â‰”
// begin
//   assume x l y m e; apply âˆ§áµ¢ { refine feq (âˆ¨_left) e } { refine feq (âˆ¨_right) e; }
// end;

// symbol â„‚: TYPE;
// symbol Cl: Set;
// rule Ï„ Cl â†ª â„‚;
// symbol P: Prop â†’ â„‚;
// right associative commutative symbol âŠ”: â„‚ â†’ â„‚ â†’ â„‚; notation âŠ” infix right 2;
// symbol â¬“: â„‚;

// symbol reify_cl: Clause â†’ â„‚;

// rule reify_cl ($x âŸ‡ $xs) â†ª (P $x) âŠ” (reify_cl $xs)
// with reify_cl â–© â†ª â¬“
// ;

// symbol isâ¬“ : â„‚ â†’ Ï„ bool;
// rule isâ¬“ (P _) â†ª false
// with isâ¬“ â¬“ â†ª true
// with isâ¬“ (_ âŠ” _) â†ª false
// ;

// symbol isP : â„‚ â†’ Ï„ bool;
// rule isP (P _) â†ª true
// with isP â¬“ â†ª false
// with isP (_ âŠ” _) â†ª false
// ;

// symbol isâŠ” : â„‚ â†’ Ï„ bool;
// rule isâŠ” (P _) â†ª false
// with isâŠ” â¬“ â†ª false
// with isâŠ” (_ âŠ” _) â†ª true
// ;

// opaque symbol âŠ”â‰ â¬“ [x y: â„‚]: Ï€ (((x âŠ” y) = â¬“) â‡’ âŠ¥) â‰”
// begin
// assume x y;  assume h;
// refine ind_eq h (Î» l, istrue (isâ¬“ l)) âŠ¤áµ¢;
// end;

// opaque symbol âŠ”â‰ P [a: Ï„ o] [x y: â„‚]: Ï€ (((x âŠ” y) = P a) â‡’ âŠ¥) â‰”
// begin
// assume a x y;  assume h;
// refine ind_eq h (Î» l, istrue (isP l)) âŠ¤áµ¢;
// end;

// opaque symbol â¬“â‰ P [a: Ï„ o] [x y: â„‚]: Ï€ ((â¬“ = P a) â‡’ âŠ¥) â‰”
// begin
// assume a x y;  assume h;
// refine ind_eq h (Î» x, istrue (isP x)) âŠ¤áµ¢;
// end;

// sequential symbol  â©¦: â„‚ â†’ â„‚ â†’ ğ”¹; notation â©¦ infix 11;
// rule (P $x) â©¦ (P $x) â†ª true
// with (P $x) â©¦ (P $y) â†ª false
// with ($x âŠ” $xs) â©¦ ($y âŠ” $ys) â†ª ($x â©¦ $y) Stdlib.Bool.and ($xs â©¦ $ys)
// with â¬“ â©¦ â¬“ â†ª true
// with â¬“ â©¦ (P _) â†ª false
// with (P _) â©¦ â¬“ â†ª false
// with (_ âŠ” _) â©¦ â¬“ â†ª false
// with â¬“ â©¦ (_ âŠ” _) â†ª false
// with (P _) â©¦ (_ âŠ” _) â†ª false
// with (_ âŠ” _) â©¦ (P _) â†ª false;

// //NOTE: The proof use a meta reasoning here
// opaque symbol Pâ©¦_correct:  Ï€ (`âˆ€ x, `âˆ€ y, (istrue (P x â©¦ P y)) â‡’ x = y) â‰”
// begin assume x y;  assume Heq; apply âŠ¥â‚‘ Heq end;

// symbol isâ–©: Clause â†’ ğ”¹;

// rule isâ–© â–© â†ª true
// with isâ–© (_ âŸ‡ _) â†ª false;

// symbol isâŠ¥: Prop â†’ ğ”¹;
// rule isâŠ¥ âŠ¥ â†ª true
// with isâŠ¥ (_ âˆ¨ _) â†ª false;

// opaque symbol âŸ‡â‰ â–© [x: Prop] [l: Clause] : Ï€ (( (x âŸ‡ l) =  â–©) â‡’ âŠ¥) â‰”
// begin
//   assume x l;  simplify; assume h; type (ind_eq h (Î» l, istrue(isâ–© l))) _;
//     refine (ind_eq h (Î» l, istrue(isâ–© l)) âŠ¤áµ¢);
// end;

// opaque symbol âˆ¨â‰ âŠ¥ [x: Prop] [l: Clause] : Ï€ (((âŸ‡_to_âˆ¨_rw (x âŸ‡ l)) = (âŸ‡_to_âˆ¨_rw â–©)) â‡’ âŠ¥) â‰”
// begin
//   assume x l; simplify;    assume h;
//   refine (ind_eq h (Î» l, istrue(isâŠ¥ l))) âŠ¤áµ¢;
// end;

// opaque symbol â–©â‰ âŸ‡ [x: Prop] [l: Clause] : Ï€ ((â–© = (x âŸ‡ l)) â‡’ âŠ¥) â‰”
// begin
//   assume x l;
//    assume h;
//   have h': Ï€ ((x âŸ‡ l) = â–©) {symmetry; apply h};
//   apply  (@âŸ‡â‰ â–© x l);
//   refine h'
// end;

// opaque symbol âŠ¥â‰ âˆ¨ [x: Prop] [l: Clause] : Ï€ (((âŸ‡_to_âˆ¨_rw â–©) = (âŸ‡_to_âˆ¨_rw (x âŸ‡ l))) â‡’ âŠ¥) â‰”
// begin
//   assume x l;
//    assume h;
//   have h': Ï€ (âŸ‡_to_âˆ¨_rw (x âŸ‡ l) = âŸ‡_to_âˆ¨_rw â–©) {symmetry; apply h};
//   apply  (@âˆ¨â‰ âŠ¥ x l);
//   refine h'
// end;

// symbol denote: â„‚ â†’ Prop;
// rule denote ($x âŠ” $y) â†ª (denote $x) âˆ¨ (denote $y)
// with denote (P $x) â†ª $x
// with denote â¬“ â†ª âŠ¥
// ;

// print ind_â„‚;

// opaque symbol â‡“_â‡‘ : Ï€ (`âˆ€ x: Clause, denote (reify_cl x) = (âŸ‡_to_âˆ¨_rw x)) â‰”
// begin
//   refine ind_â„‚ (Î» u, denote (reify_cl u) = (âŸ‡_to_âˆ¨_rw u)) _ _
//   { reflexivity; }
//   {
//     assume x xs IH; simplify; rewrite IH; reflexivity
//   }
// end;


// opaque symbol cl_perm_correct': Ï€ (`âˆ€ (a: Clause), `âˆ€ (b: Clause), (istrue (reify_cl a â©¦ reify_cl b)) â‡’ (âŸ‡_to_âˆ¨_rw a = âŸ‡_to_âˆ¨_rw b)) â‰”
// begin
//   refine ind_â„‚ (Î» u, `âˆ€ (b: Clause), (istrue (reify_cl u â©¦ reify_cl b)) â‡’ (âŸ‡_to_âˆ¨_rw u = âŸ‡_to_âˆ¨_rw b))  _ _
//   {
//     refine ind_â„‚ (Î» u,  (istrue (reify_cl â–© â©¦ reify_cl u)) â‡’ (âŸ‡_to_âˆ¨_rw â–© = âŸ‡_to_âˆ¨_rw u))  _ _
//     { simplify;  assume Htop; reflexivity  }
//     {
//       assume x xs; simplify; assume H;  assume contra; apply âŠ¥â‚‘ contra
//     }
//   }
//   {
//     assume x xs IH; 
//     refine ind_â„‚ (Î» u,  (istrue (reify_cl (x âŸ‡ xs) â©¦ reify_cl u)) â‡’ (âŸ‡_to_âˆ¨_rw (x âŸ‡ xs) = âŸ‡_to_âˆ¨_rw u)) _ _
//     {
//        assume contra; apply âŠ¥â‚‘ contra
//     }
//     {
//       assume y ys;
//       assume IH2;
//        simplify â©¦; assume H;
//       simplify âŸ‡_to_âˆ¨_rw;
//       refine @feq2 o o o (âˆ¨) x y _ (âŸ‡_to_âˆ¨_rw xs) (âŸ‡_to_âˆ¨_rw ys) _
//       {
//         apply  Pâ©¦_correct;
//         refine (@andâ‚‘â‚ (P x â©¦ P y) (reify_cl xs â©¦ reify_cl ys) H);
//       }
//       {
//         refine IH ys _;
//         refine @andâ‚‘â‚‚ (P x â©¦ P y) (reify_cl xs â©¦ reify_cl ys) H;
//       }
//     }
//   }
// end;



// opaque symbol cl_perm_complete: Ï€ (`âˆ€ (a: Clause), `âˆ€ (b: Clause), (a = b) â‡’ (istrue (reify_cl a â©¦ reify_cl b))) â‰”
// begin
//   refine ind_â„‚ (Î» u, `âˆ€ b, (u = b) â‡’  (istrue (reify_cl u â©¦ reify_cl b))) _ _
//   {
//     refine ind_â„‚ (Î» u, (â–© = u) â‡’ istrue (reify_cl â–© â©¦ reify_cl u)) _ _
//     {  assume H; apply âŠ¤áµ¢ }
//     { assume x xs H;   assume j; refine âŠ¥â‚‘ ( (@â–©â‰ âŸ‡ x xs) j); }
//   }
//   {
//     assume x xs IH;
//     refine ind_â„‚ (Î» u, ((x âŸ‡ xs) = u) â‡’ istrue (reify_cl (x âŸ‡ xs) â©¦ reify_cl u)) _ _
//     {  assume j; refine âŠ¥â‚‘ ( (@âŸ‡â‰ â–© x xs) j); }
//     {
//       assume y ys IH2;  assume H;
//       have G: Ï€ ((x = y) âˆ§ (xs = ys)) { apply âŸ‡_inj H };
//         have G1: Ï€ (x = y ) { apply âˆ§â‚‘â‚  G };
//         have G2: Ï€ (xs = ys) { apply âˆ§â‚‘â‚‚  G };
//         rewrite G1;
//         rewrite left G2;
//         refine  IH xs _;
//         reflexivity
//     }
//   }
// end;

// // cl_perm_correct' with parameter
// opaque symbol cl_perm_correct a b : Ï€ (istrue (reify_cl a â©¦ reify_cl b)) â†’ Ï€ (âŸ‡_to_âˆ¨_rw a = âŸ‡_to_âˆ¨_rw b) â‰”
// begin assume a b H; apply  (cl_perm_correct' a b) H end;

opaque symbol subst_equiv_clause : Î  x: Clause, Î  y: Clause, Ï€ (âŸ‡_to_âˆ¨_rw x = âŸ‡_to_âˆ¨_rw y) â†’ Ï€Ì‡ x â†’ Ï€Ì‡ y â‰”
begin
assume x y;
simplify;
assume Heq; assume Hx;
rewrite left Heq;
apply Hx
end;

// require open Stdlib.List;

// inductive ClauseAlg : TYPE â‰”
// p : â„• â†’ ClauseAlg;

// symbol clalg: Set;

// rule Ï„ clalg â†ª ClauseAlg;

// symbol â‡‘ : ğ•ƒ o â†’ Clause â†’ ğ•ƒ clalg;

// symbol reify: ğ•ƒ o â†’ Clause â†’ Ï„(list clalg Ã— list o);

// sequential symbol prop_eq: Prop â†’ Prop â†’ ğ”¹;
// rule prop_eq $x $x â†ª true
// with prop_eq $x $y â†ª false;

// rule â‡‘ $ctx ($x âŸ‡ $xs) â†ª (p (index prop_eq $x $ctx )) â¸¬ (â‡‘ $ctx $xs)
// with â‡‘ _ â–© â†ª â–¡;

// symbol â‡“ : ğ•ƒ o â†’ ğ•ƒ clalg â†’ Prop;
// rule â‡“ $ctx â–¡ â†ª âŠ¥
// with â‡“ $ctx ((p $i) â¸¬ $tl) â†ª  (nth âŠ¥ $ctx $i) âˆ¨ (â‡“ $ctx $tl);

// symbol den_reify â‰” Î» l x, â‡“ l (â‡‘ l (x));

// require open Stdlib.Comp;

// symbol compN : â„• â†’ â„• â†’ Comp;

// rule compN _0 _0 â†ª Eq
// with compN _0 (_ +1) â†ª Lt
// with compN (_ +1) _0 â†ª Gt
// with compN ($x +1) ($y +1) â†ª compN $x $y;

// opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
// begin
// induction
// { induction
//   {assume h; reflexivity}
//   {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
// }
// { assume x hx; induction
//   {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
//   {assume y hy h; apply feq (+1); apply hx y h }
// }
// end;

// symbol insert: ClauseAlg â†’ Ï„(list clalg) â†’ Ï„(list clalg);
// rule insert $x â–¡ â†ª $x â¸¬ â–¡
// with insert (p $i) (p $j â¸¬ $l) â†ª
//      case_Comp (compN $i $j)
//             (p $i â¸¬ p $j â¸¬ $l)
//             (p $i â¸¬ p $j â¸¬ $l)
//             (p $j â¸¬ insert (p $i) $l);

// symbol sort_cl: Ï„(list clalg) â†’ Ï„(list clalg);

// rule sort_cl â–¡ â†ª â–¡
// with sort_cl ($x â¸¬ $xs) â†ª insert $x (sort_cl $xs);

// symbol norm_cl l â‰” sort_cl l;

// symbol insert_correct l gs g : Ï€ (â‡“ l (insert g gs) =  ((â‡“ l (g â¸¬ â–¡)) âˆ¨  (â‡“ l gs))) â‰”
// begin
// assume l;
// induction
// {
//   assume g; simplify; rewrite or_identity_r; reflexivity
// }
// {
//   induction;
//   assume j xs IH;
//   induction;
//   assume i;
//   simplify;
//   refine ind_Comp (Î» u, (compN i j) = u â‡’  â‡“ l (case_Comp u (p i â¸¬ (p j â¸¬ xs)) (p i â¸¬ (p j â¸¬ xs)) (p j â¸¬ insert (p i) xs)) = ((nth âŠ¥ l i âˆ¨ âŠ¥) âˆ¨ (nth âŠ¥ l j âˆ¨ â‡“ l xs))) _ _ _ (compN i j) _
//   { assume Heq; simplify; rewrite or_identity_r; reflexivity }
//   { assume Hlt; simplify; rewrite or_identity_r; reflexivity }
//   {
//     assume Hgt;
//     simplify;
//     rewrite IH;
//     simplify;
//     rewrite or_identity_r;
//     rewrite âˆ¨_assoc;
//     rewrite .[in x in (x âˆ¨ _) = _ ] âˆ¨_com;
//     rewrite left âˆ¨_assoc;
//     reflexivity
//   }
//   { reflexivity }
// }
// end;

// opaque symbol norm_correct l (x: Ï„ (list clalg))  : Ï€ (â‡“ l (norm_cl x) = (â‡“ l x)) â‰”
// begin
//   assume l;
//   induction
//   { reflexivity; }
//   { 
//     induction;
//     assume i xs IH;
//     simplify;
//     rewrite left IH;
//     simplify;
//     rewrite insert_correct;
//     simplify;
//     rewrite or_identity_r;
//     reflexivity
//   }
// end;

// private opaque symbol foo: Ï€Ì‡ (a âŸ‡ b âŸ‡ c âŸ‡ â–©) â†’  Ï€Ì‡ (c âŸ‡ b âŸ‡ a âŸ‡ â–©) â‰”
// begin
//   assume h;
//   set l â‰” a â¸¬ b â¸¬ c â¸¬ â–¡;
//   have perm: Ï€ (âŸ‡_to_âˆ¨_rw (a âŸ‡ b âŸ‡ c âŸ‡ â–©) = âŸ‡_to_âˆ¨_rw (c âŸ‡ b âŸ‡ a âŸ‡ â–©)) {
//     change Ï€ (â‡“ l (â‡‘ l (a âŸ‡ (b âŸ‡ (c âŸ‡ â–©)))) = â‡“ l (â‡‘ l (c âŸ‡ (b âŸ‡ (a âŸ‡ â–©)))));
//     rewrite left norm_correct l;
//     rewrite left .[x in _ = x] norm_correct l;
//     reflexivity
//   };
//   refine subst_equiv_clause
//     (a âŸ‡ (b âŸ‡ (c âŸ‡ â–©)))
//     (c âŸ‡ (b âŸ‡ (a âŸ‡ â–©)))
//     perm h;
// end;

/**********************************************
* N-ary rules
**********************************************/

require open Stdlib.List;

symbol literal â‰” nth âŠ¥;
symbol literals â‰” nths âŠ¥;

symbol âˆˆâ‚™ â‰” âˆˆ eqn;
notation âˆˆâ‚™ infix right 40;

symbol list_to_clause :  ğ•ƒ o â†’ Clause;
rule list_to_clause ($p â¸¬ $ps) â†ª $p âŸ‡ (list_to_clause $ps)
with list_to_clause â–¡ â†ª â–©;

symbol conj : ğ•ƒ o â†’ Ï„ o;
rule conj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ§ conj ($c â¸¬ $l))
with conj ($l1 â¸¬ â–¡) â†ª $l1 
with conj â–¡ â†ª âŠ¤;

opaque symbol conj_head (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (c0) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 c1 h1 h2;
        refine âˆ§â‚‘â‚ h2}
end; 

symbol indexes_shift (l: ğ•ƒ nat) (n : Ï„ nat):
    Ï€ (istrue ((n +1) âˆˆâ‚™ (map (+1) l)) â‡’ istrue (n âˆˆâ‚™ l))â‰”
begin
  induction
      {assume n x; refine x}
      {assume n0;
      induction
          {assume h0 n h1; refine h1}
          {assume n1 l h0 h1 n2 h2;
          refine orâ‚‘ [eqn n2 n0] [eqn n2 n1 Stdlib.Bool.or âˆˆ eqn (n2 +1) (map (+1) l)] (eqn n2 n0 Stdlib.Bool.or (eqn n2 n1 Stdlib.Bool.or âˆˆ eqn n2 l)) h2 _ _
              {assume h3;
              refine oráµ¢â‚ (eqn n2 n1 Stdlib.Bool.or âˆˆ eqn n2 l) h3}
              {assume h3;
              refine oráµ¢â‚‚ (eqn n2 n0) (h1 n2 h3)}}}
end;

symbol indexes_decrement (id : Ï„ nat) (l0: Ï„ o) (l: ğ•ƒ o): 
     Ï€ ((id +1) âˆˆâ‚™ (indexes (l0 â¸¬ l))) â†’ Ï€ (id âˆˆâ‚™ (indexes l))â‰”
begin
    assume id l0 l;
    assume h0; 
    have H1 : Ï€ ((istrue (âˆˆ eqn (id +1) (iota 1 (size l)))) â‡’ (istrue (âˆˆ eqn id (iota 0 (size l)))))
        {have H2: Ï€ (iota 1 (size l) = map (+1) (iota 0 (size l)))
            {refine (eq_sym (mapS_iota (size l) 0))};
        rewrite H2;
        refine indexes_shift (iota 0 (size l)) id};
    refine H1 h0
end;


opaque symbol literal_ext (l: ğ•ƒ o) (l0 : Ï„ o) (n: Ï„ nat) : 
    Ï€ (literal l n) â†’ Ï€ (literal (l0 â¸¬ l) (n +1)) â‰”
begin
    assume l l0 n h1;
    refine h1
end;

opaque symbol conj_tail (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âŠ¤áµ¢}   
        {assume x0 c1 h1 h2; 
        refine âˆ§â‚‘â‚‚ h2}
end; 

opaque symbol select (id : Ï„ nat) (cnf: ğ•ƒ o) : 
    Ï€ (id âˆˆâ‚™ (indexes cnf)) â†’ Ï€ (conj cnf) â†’ Ï€ (literal cnf id) â‰”
begin
    induction 
        {induction
            {assume h0 h1; refine h0}
            {assume x cnf h0 h1 h2; 
            refine conj_head x cnf h2}}
        {assume id h0;
        induction
            {assume b; refine âŠ¥â‚‘ b}
            {assume x cnf h1 h2 h3;
            have ConjImpCl : Ï€ (conj cnf â‡’ literal cnf id)
                {refine h0 cnf (indexes_decrement id x cnf h2)};
            refine literal_ext cnf x id (ConjImpCl (conj_tail x cnf h3))}}
end;

// Rule and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol âˆ§â‚‘â‚™ k l : Ï€ (k âˆˆâ‚™ (indexes l)) â†’ Ï€Ì‡ (conj l âŸ‡ â–©) â†’ Ï€Ì‡ ((literal l k ) âŸ‡ â–©) â‰”
begin
  assume k l h1 h2;
  simplify;
  rewrite or_identity_r;
  refine select k l h1 (Ï€Ì‡â‚— h2)
end;


// (and_pos) âŠ¢ Â¬ (x1 âˆ§ ... âˆ§ xn), xk â‰¡ (x1 âˆ§ ... âˆ§ xn) âŠ¢ xk
opaque symbol and_pos_aux (id : Ï„ nat) (cnf: ğ•ƒ o) : Ï€ (id âˆˆâ‚™ (indexes cnf)) â†’ Ï€ (Â¬ (conj cnf) âˆ¨ (literal cnf id)) â‰”
begin
  assume id cnf h;
  rewrite imp_eq_or;
  assume hconj;
  refine select id cnf h hconj 
end;

// Rule and_pos: Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›), ğœ‘ğ‘˜
// (and_pos) âŠ¢ Â¬ (x1 âˆ§ ... âˆ§ xn), xk â‰¡ (x1 âˆ§ ... âˆ§ xn) âŠ¢ xk
opaque symbol and_pos (k : Ï„ nat) (cnf: ğ•ƒ o) : Ï€ (k âˆˆâ‚™ (indexes cnf)) â†’ Ï€Ì‡ (Â¬ (conj cnf) âŸ‡ (literal cnf k) âŸ‡ â–©) â‰”
begin
  assume k cnf h;
  simplify;
  rewrite or_identity_r;
  refine and_pos_aux k cnf h
end;

symbol negate: ğ•ƒ o â†’ ğ•ƒ o;
rule negate â–¡ â†ª â–¡
with negate ($x â¸¬ $xs) â†ª Â¬ $x â¸¬ negate $xs;

symbol disj : ğ•ƒ o â†’ Ï„ o;
rule disj ($l1 â¸¬ $l) â†ª ($l1 âˆ¨ disj $l)
with disj â–¡ â†ª âŠ¥;

opaque symbol disj_head (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (l0) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1; simplify; rewrite or_identity_r;
        refine h1}   
        {assume x0 l1 h1 h2; 
        refine âˆ¨áµ¢â‚ h2}
end; 

opaque symbol disj_tail (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume x1 l1 h1 h2;
        refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol disj_correct (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj (l0 â¸¬ l)) â†’ Ï€ (l0 âˆ¨ disj l) â‰”
begin
    assume l0;
    induction
        {
          assume h1;
          refine h1
        }
        {assume x1 l1 h1 h2;
        refine h2}
end;

opaque symbol disj_complete (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (l0 âˆ¨ disj l) â†’ Ï€ (disj (l0 â¸¬ l))  â‰”
begin
    assume l0;
    induction
        {
          refine (Î» x, x)
        }
        {assume x1 l1 h1 h2;
        refine h2}
end;

opaque symbol disj_eq (l0 : Ï„ o) (l : ğ•ƒ o) :  Ï€ ((l0 âˆ¨ disj l) = disj (l0 â¸¬ l)) â‰”
begin
  assume x l;
  apply prop_ext;
  apply âˆ§áµ¢ 
  { refine disj_complete x l }
  { refine disj_correct x l }
end;

opaque symbol conj_correct (c0 : Ï„ o) (c : ğ•ƒ o) : 
    Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (c0 âˆ§ conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âˆ§áµ¢ h1 âŠ¤áµ¢}
        {assume x1 c1 h1 h2;
        refine h2}
end;

opaque symbol conj_complete (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (c0 âˆ§ conj c) â†’ Ï€ (conj (c0 â¸¬ c)) â‰”
begin
    assume c0;
    induction
        {assume h1; simplify;
        refine âˆ§â‚‘â‚ h1}
        {assume x1 c1 h1 h2;
        refine h2}
end;

opaque symbol conj_eq (l0 : Ï„ o) (l : ğ•ƒ o) :  Ï€ ((l0 âˆ§ conj l) = conj (l0 â¸¬ l)) â‰”
begin
  assume x l;
  apply prop_ext;
  apply âˆ§áµ¢ 
  { refine conj_complete x l }
  { refine conj_correct x l }
end;
 
opaque symbol morgan (l: ğ•ƒ o) : Ï€ ((Â¬ (disj l)) = conj (negate l)) â‰”
begin
induction
{
  simplify;
  apply prop_ext;
  apply âˆ§áµ¢ { assume h; apply âŠ¤áµ¢ } { assume h; refine (Î» x, x) }
}
{
  assume h tl IH;
  rewrite left disj_eq;
  rewrite morgan2;
  rewrite IH;
  simplify;
  rewrite conj_eq;
  reflexivity
}
end;

opaque symbol morganN2 (l: ğ•ƒ o) : Ï€ ((Â¬ (conj l)) = disj (negate l)) â‰”
begin
induction
{
  simplify;
  apply prop_ext;
  apply âˆ§áµ¢ { assume h; apply h âŠ¤áµ¢ } { assume h; apply âŠ¥â‚‘ h }
}
{
  assume h tl IH;
  simplify;
  rewrite left conj_eq;
  rewrite left IH;
  have foldneg: Î  e, Ï€ (Â¬ e = (e â‡’ âŠ¥)) { reflexivity };
  rewrite left foldneg;
  rewrite morgan1 h (conj tl);
  reflexivity
}
end;

opaque symbol clause_to_disj_from_list l : Ï€ (âŸ‡_to_âˆ¨_rw (list_to_clause l) = disj l) â‰”
begin
induction
{reflexivity}
{
  assume x xs ih;simplify;
  apply feq2 (âˆ¨) _ _
  {reflexivity}
  {refine ih}  
}
end;

opaque symbol select_disj (id : Ï„ nat) (l: ğ•ƒ o) : 
    Ï€ (id âˆˆâ‚™ (indexes (negate l))) â†’ Ï€ (Â¬ (disj l)) â†’ Ï€ (literal (negate l) id) â‰”
begin
  assume id l H Hdisj;
  have g: Ï€ (conj (negate l)) { rewrite left morgan l; refine Hdisj };
  refine select id (negate l) H g;
end;

// Rule not_or:
// i. â–· Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘ğ‘˜
opaque symbol not_or (id : Ï„ nat) (l: ğ•ƒ o) : 
    Ï€ (id âˆˆâ‚™ (indexes (negate l))) â†’ Ï€ (Â¬ (disj l)) â†’ Ï€Ì‡ (literal (negate l) id âŸ‡  â–©) â‰”
begin
  assume id l H Hdisj;
  apply âˆ¨áµ¢â‚;
  have g: Ï€ (conj (negate l)) { rewrite left morgan l; refine Hdisj };
  refine select id (negate l) H g;
end;


opaque symbol not_and_aux (l: ğ•ƒ o) : 
    Ï€ (Â¬ (conj l)) â†’ Ï€ (disj (negate l)) â‰”
begin
  induction
  { assume H; refine H âŠ¤áµ¢ }
  {
    assume x xs IH Hconj;
    simplify;
    have g: Ï€ (Â¬ (x âˆ§  conj xs)) {
      rewrite conj_eq;
      refine Hconj;
    };
    have g2: Ï€ (Â¬ x âˆ¨  Â¬ conj xs) { rewrite left morgan1; refine g };
    apply âˆ¨â‚‘ g2 
    { assume Hnx; apply âˆ¨áµ¢â‚; refine Hnx; }
    { assume Hnxs; apply âˆ¨áµ¢â‚‚; refine IH Hnxs }
  }
end;

// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
opaque symbol not_and (l: ğ•ƒ o) : 
    Ï€ (Â¬ (conj l)) â†’ Ï€Ì‡ (list_to_clause (negate l)) â‰”
begin
  simplify;
  assume l h;
  rewrite clause_to_disj_from_list (negate l);
  refine not_and_aux l h;
end;

// assert c0 c1 c2 c2' âŠ¢ not_and_k (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡): 
//     Ï€ (Â¬ (c0 âˆ§ c1 âˆ§ c2 âˆ§ c1)) â†’ Ï€ ((Â¬ c0) âˆ¨ (Â¬ c1) âˆ¨ (Â¬ c2) âˆ¨ (Â¬ c1));

// or_pos: âŠ¢ Â¬ (x1 âˆ¨ ... âˆ¨ xn) âˆ¨ x1 âˆ¨ ... âˆ¨ xn
opaque symbol or_pos_aux (l: ğ•ƒ o) : Ï€ (Â¬ (disj l) âˆ¨ (disj l)) â‰”
begin
  assume l;
  rewrite âˆ¨_com;
  apply em
end;


// Rule or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
opaque symbol or_pos (l: ğ•ƒ o) :  Ï€Ì‡ ((Â¬ (disj l)) âŸ‡ (list_to_clause l)) â‰”
begin
  assume l;
  simplify;
  rewrite clause_to_disj_from_list;
  rewrite âˆ¨_com;
  apply em
end;

// and_neg: âŠ¢  (x1 âˆ§ ... âˆ§ xn) âˆ¨ Â¬ x1 âˆ¨ ... âˆ¨ Â¬ xn
opaque symbol and_neg_aux (l: ğ•ƒ o) : Ï€ ((conj l) âˆ¨ disj (negate l)) â‰”
begin
  assume l;
  rewrite left morganN2 l;
  refine em (conj l);
end;

symbol cl_to_list : Clause â†’ ğ•ƒ o;
 rule cl_to_list ($p âŸ‡ $ps) â†ª $p â¸¬ (cl_to_list $ps)
with cl_to_list â–© â†ª â–¡;

symbol clause_to_disj_via_list c: Ï€ (âŸ‡_to_âˆ¨_rw c = disj (cl_to_list c)) â‰”
begin
  refine ind_â„‚ (Î» u, âŸ‡_to_âˆ¨_rw u = disj (cl_to_list u)) _ _ 
  {reflexivity}
  {
    assume x xs ih;
    refine feq2 (âˆ¨) _ _
    {reflexivity}
    {refine ih};
  }
end;

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
opaque symbol and_neg [c] (l: ğ•ƒ o) : Ï€ (disj (cl_to_list c) = disj (negate l)) â†’ Ï€Ì‡ ((conj l) âŸ‡ c) â‰”
begin
  assume c l h;
  simplify;
  rewrite clause_to_disj_via_list;
  rewrite h;
  refine and_neg_aux l
end;


opaque symbol lit_imp_disj (c: ğ•ƒ o) (ks: ğ•ƒ nat) : 
    Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ ks) â†’ Ï€ (disj (literals c ks)) â‰”
begin
    assume c;
    induction
    {assume h1;
        have H0: Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ âŠ¥) x) â†’ Ï€ âŠ¥
        {assume x h2;
        refine âˆ§â‚‘â‚‚ h2};
        refine âˆƒâ‚‘ h1 H0}
    {assume n l h1 h2;
        have H1: Î  x: Ï„ nat,
        Ï€ ((Î» x1, literal c x1 âˆ§ (eqn x1 n Stdlib.Bool.or x1 âˆˆâ‚™ l)) x)
            â†’ Ï€ (disj (literal c n â¸¬ literals c l))
        {assume m h3;
        have H0: Ï€ (eqn m n âˆ¨ m âˆˆâ‚™ l)
            {refine âˆ¨_istrue [eqn m n] [m âˆˆâ‚™ l] (âˆ§â‚‘â‚‚ h3)};
        have H1: Ï€ (eqn m n) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H1_0: Ï€ (literal c n)
                {have H1_0_0: Ï€ (n = m)
                {symmetry;
                refine eqn_correct m n h4};
                rewrite H1_0_0;
                refine âˆ§â‚‘â‚ h3};
            refine disj_head (literal c n) (literals c l) H1_0};
        have H2: Ï€ (m âˆˆâ‚™ l) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H2_0: Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ l)
                {have H2_0_0: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ l) m)
                {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h3) h4};
                refine âˆƒáµ¢ m H2_0_0};
            refine disj_tail (literal c n) (literals c l) (h1 H2_0)};
        refine âˆ¨â‚‘ H0 H1 H2};
        refine âˆƒâ‚‘ h2 H1}
end;

assert c0 c1 c2 c2' âŠ¢ lit_imp_disj (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡) (indexes (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡)): 
    Ï€ (`âˆƒ x, literal (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡) x âˆ§ x âˆˆâ‚™ (indexes (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡))) â†’ Ï€ (disj (literals (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡) (indexes (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡))));


// or_neg  (x1 âˆ¨ ... âˆ¨ xn) âˆ¨ Â¬ xk â‰¡ Â¬ xk âˆ¨ (x1 âˆ¨ ... âˆ¨ xn) â‰¡  xk â‡’ (x1 âˆ¨ ... âˆ¨ xn) â‰¡ xk âŠ¢  (x1 âˆ¨ ... âˆ¨ xn)
opaque symbol or_neg_aux id (l: ğ•ƒ o) : 
    Ï€ (literal l id âˆ§ id âˆˆâ‚™ (indexes l)) â†’ Ï€ (disj l) â‰”
begin
  assume id l h;
  have g: Ï€ (disj (literals l (indexes l)))
  {
    refine lit_imp_disj l (indexes l) _;
    refine âˆƒáµ¢ id _;
    refine h
  };
  rewrite left nths_indexes_id âŠ¥ l;
  refine g
end;

// Rule or_neg (ğœ‘1 âˆ¨ â€¦ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘
// However, this lemma prove Â¬ğœ‘, (ğœ‘1 âˆ¨ â€¦ âˆ¨ ğœ‘ğ‘›)
// The litteral Â¬ğœ‘
opaque symbol or_neg [c] k (l: ğ•ƒ o) : Ï€ ((disj (cl_to_list c)) = (disj l)) â†’
    Ï€ (k âˆˆâ‚™ (indexes l)) â†’ Ï€Ì‡ ((Â¬ (literal l k )) âŸ‡ c) â‰”
begin
  assume c k l h h2;
  simplify;
  // rewrite âˆ¨_com;
  rewrite clause_to_disj_via_list;
  rewrite h;
  change Ï€ ((Â¬ nth âŠ¥ l k) âˆ¨ disj l);
  rewrite imp_eq_or;
  assume hlit;
  refine or_neg_aux k l _ ;
  apply âˆ§áµ¢
  { refine hlit }
  { refine h2 }
end;

symbol sym_clause x y : Ï€Ì‡ (x âŸ‡ y âŸ‡ â–©) â†’ Ï€Ì‡ (y âŸ‡ x âŸ‡ â–©) â‰”
begin
simplify;
assume x y h;
rewrite  âˆ¨_assoc;
rewrite âˆ¨_com y x;
rewrite left âˆ¨_assoc;
refine h
end;

symbol eraseIdx [a] : ğ•ƒ a â†’ â„• â†’ ğ•ƒ a;
rule eraseIdx â–¡ _ â†ª â–¡
with eraseIdx (_ â¸¬ $xs) 0 â†ª $xs
with eraseIdx ($x â¸¬ $xs) ($n +1) â†ª $x â¸¬ (eraseIdx $xs $n);

assert âŠ¢ (eraseIdx (0 â¸¬ 1 â¸¬ 2 â¸¬ 3 â¸¬ â–¡) 2) â‰¡ (0 â¸¬ 1 â¸¬ 3 â¸¬ â–¡);
assert âŠ¢ (eraseIdx (0 â¸¬ 1 â¸¬ 2 â¸¬ 3 â¸¬ â–¡) 5) â‰¡ (0 â¸¬ 1 â¸¬ 2 â¸¬ 3 â¸¬ â–¡);
assert âŠ¢ (eraseIdx  â–¡ 2) â‰¡ â–¡;

opaque symbol case_l [a] x (l: ğ•ƒ a) n : Ï€ ((n +1) â‰¤ (size (x â¸¬ l))) â†’ Ï€ (n â‰¤ (size l)) â‰”
begin
  assume a x l n H;
  refine H
end;

symbol orN_eraseIdx qs j (hj: Ï€ (j < size qs)) : Ï€ ((disj (eraseIdx qs j) âˆ¨ (nth âŠ¥ qs j)) = (disj qs)) â‰”
begin
  induction
  {
    assume j;
    simplify;
    assume contra;
    refine âŠ¥â‚‘ contra
  }
  {
    assume t l ih;
    induction
    {
      simplify;
      assume h;
      rewrite âˆ¨_com;
      reflexivity
    }
   {
      assume j ih2 h;
      simplify;
      rewrite left ih j (case_l t l (j +1) h);
      rewrite âˆ¨_assoc;
      reflexivity
    }
  }
end;

print ind_â„•;

symbol rec_â„• : Î  p0: (â„• â†’ Prop), Ï€ (p0 0) â†’ (Î  x0: â„•, Ï€ (p0 (x0 +1))) â†’ Î  x: â„•, Ï€ (p0 x);

symbol sublist [a] (xs : ğ•ƒ a) (i j : â„•) â‰” drop i (take j xs);

symbol orN_subList (qs ps : ğ•ƒ o)  (i j : â„•) (hps : Ï€ (disj ps)) (hpq : Ï€ (ps = sublist qs i j)) : Ï€ (disj qs) â‰”
begin
  induction // qs
  {
    assume x i j h1 heq;
    change Ï€ (disj (sublist â–¡ i j));
    rewrite left heq;
    apply h1    
  }
  {
    assume t l ih;
    assume  ps i;
    refine rec_â„• (Î» j, disj ps â‡’ ((ps = sublist (t â¸¬ l) i j) â‡’ disj (t â¸¬ l))) _ _
    {
      simplify;
      assume hp hps;
      apply âˆ¨áµ¢â‚‚;
      refine ih ps i 0 hp hps;
    }
    {
      assume j;
      generalize i;
      refine rec_â„• (Î» i, `âˆ€ j, disj ps â‡’ ((ps = sublist (t â¸¬ l) i (j +1)) â‡’ disj (t â¸¬ l))) _ _
      {
        simplify;
        assume j hps heq;
        type ih ps 0 j hps;
        compute sublist l 0 j;
        have g: Ï€ (t âˆ¨ disj (take j l)) {
          change Ï€ (disj (t â¸¬ take j l));
          rewrite left heq;
          apply hps
        };
        apply âˆ¨â‚‘ g
        { assume ht; apply âˆ¨áµ¢â‚; refine ht }
        { assume g2; apply âˆ¨áµ¢â‚‚; apply ih (drop 0 (take j l)) 0 j g2 (eq_refl _) }
      }
      {
        simplify;
        assume i j hp hps;
        apply âˆ¨áµ¢â‚‚;
        apply ih ps i j hp hps;
      }
    }
  }
end;

symbol orN_append_right (ps qs : ğ•ƒ o) (hqs : Ï€ (disj qs)) : Ï€ (disj (ps ++ qs)) â‰”
begin
  assume ps qs hqs;
  apply orN_subList (ps ++ qs) qs  (size ps) (size ps + size qs) hqs;
  simplify;
  rewrite left size_cat;
  rewrite take_size;
  rewrite drop_size_cat (size ps) ps qs (eq_refl _);
  reflexivity
end;

symbol orN_append_left (ps qs : ğ•ƒ o) (hqs : Ï€ (disj ps)) : Ï€ (disj (ps ++ qs)) â‰”
begin
  assume ps qs hps;
  apply orN_subList (ps ++ qs) ps  0 (size ps) hps;
  simplify;
  rewrite take_size_cat (size ps) ps qs (eq_refl _);
  reflexivity
end;

// Used when carcara put the flag at `false`
symbol disj_resolutionN1 (ps qs:  ğ•ƒ o) (i j: â„•)
  (hps: Ï€ (disj ps))
  (hqs: Ï€ (disj qs))
  (hi: Ï€ (i < size ps))
  (hj: Ï€ (j < size qs))
  (hij: Ï€ ((nth âŠ¥ ps i) = Â¬ (nth âŠ¥ qs j))) : Ï€ (disj ((eraseIdx ps i) Stdlib.List.++ (eraseIdx qs j))) â‰”
begin
assume ps qs i j;
have h: Ï€ ((nth âŠ¥ ps i) âˆ¨ Â¬ (nth âŠ¥ ps i)) { refine em (nth âŠ¥ ps i) };
assume hps hqs hi hj hij;
have h1: Ï€ ((disj (eraseIdx ps i) âˆ¨ nth âŠ¥ ps i) = disj ps) { refine  orN_eraseIdx ps i hi };
have h2: Ï€ ((disj (eraseIdx qs j) âˆ¨ nth âŠ¥ qs j) = disj qs) { refine orN_eraseIdx qs j hj };
apply âˆ¨â‚‘ h
{
  assume hp;
  have hij': Ï€ (nth âŠ¥ ps i â‡” Â¬ (nth âŠ¥ qs j)) { rewrite hij; apply â‡”_refl };
  have h3: Ï€ (Â¬ (nth âŠ¥ qs j)) { refine âˆ§â‚‘â‚ hij' hp };
  have hps': Ï€ ((disj (eraseIdx ps i) âˆ¨ Â¬ (nth âŠ¥ qs j))) { rewrite left hij; apply âˆ¨áµ¢â‚‚; refine hp };
  remove hps;
  remove h1;
  have hqs': Ï€ ((disj (eraseIdx qs j) âˆ¨ nth âŠ¥ qs j)) { rewrite h2; apply hqs };
  remove h2;
  remove hqs;
  have g: Ï€ ((âŠ¥ = nth âŠ¥ qs j)) { rewrite âŠ¥= (nth âŠ¥ qs j); refine h3 };
  have hqs'': Ï€ (disj (eraseIdx qs j)) { rewrite left or_identity_r; rewrite g; refine hqs' };
  apply orN_append_right (eraseIdx ps i) (eraseIdx qs j) hqs'';
}
{
  assume hp;
   have g: Ï€ ((âŠ¥ = nth âŠ¥ ps i)) { rewrite âŠ¥= (nth âŠ¥ ps i); refine hp };
   have hps': Ï€ ((disj (eraseIdx ps i))) { rewrite left or_identity_r; rewrite g;  rewrite h1; apply hps };
   have hqs': Ï€ ((disj (eraseIdx qs j) âˆ¨ nth âŠ¥ qs j)) { rewrite h2; apply hqs };
  apply orN_append_left (eraseIdx ps i) (eraseIdx qs j) hps';
}
end;

// Used when carcara put the flag at `true`
symbol disj_resolutionN2 (ps qs:  ğ•ƒ o) (i j: â„•)
  (hps: Ï€ (disj ps))
  (hqs: Ï€ (disj qs))
  (hi: Ï€ (i < size ps))
  (hj: Ï€ (j < size qs))
  (hij: Ï€ (Â¬ (nth âŠ¥ ps i) = (nth âŠ¥ qs j))) : Ï€ (disj ((eraseIdx ps i) Stdlib.List.++ (eraseIdx qs j))) â‰”
begin
admit
end;

// Lemmas `cl_â­ˆ_cl` and `disj_â­ˆ_cl` are used to prove the iso:  Ï€Ì‡ c â‰¡ Ï€ (disj l) with the invariant (âŸ‡_to_âˆ¨_rw c = disj l).
// We need this lemma to use disj_resolutionN from Ï€Ì‡ c

opaque symbol cl_â­ˆ_cl c l: Ï€Ì‡ c â†’ Ï€ (âŸ‡_to_âˆ¨_rw c = disj l) â†’ Ï€ (disj l) â‰”
begin
  simplify;
  change  Î  c: Clause,  Ï€ (`âˆ€ l: ğ•ƒ o, âŸ‡_to_âˆ¨_rw c â‡’ âŸ‡_to_âˆ¨_rw c = disj l â‡’ disj l);
  refine ind_â„‚ (Î» u, `âˆ€ l, âŸ‡_to_âˆ¨_rw u â‡’ ((âŸ‡_to_âˆ¨_rw u = disj l) â‡’ disj l)) _ _
  { simplify; assume l h heq; rewrite left heq; refine h  }
  { assume c cs ih; induction
    { simplify; assume h heq; rewrite left heq; apply h }
    { assume l ls ih2 h1 h2; rewrite left h2; apply h1 }
  };
end;

symbol disj_â­ˆ_cl l c: Ï€ (disj l) â†’ Ï€ (disj l = âŸ‡_to_âˆ¨_rw c) â†’ Ï€Ì‡ c â‰”
begin
  simplify;
  induction
  {simplify; assume x Hcontra; apply âŠ¥â‚‘ Hcontra}
  {
    assume l ls ihl;
    refine ind_â„‚ (Î» u, disj (l â¸¬ ls) â‡’ ((disj (l â¸¬ ls) = âŸ‡_to_âˆ¨_rw u) â‡’ âŸ‡_to_âˆ¨_rw u)) _ _
    { simplify; assume h heq; rewrite left heq; apply h }
    {assume x xs ih2 h1 h2; rewrite left h2; apply h1 }
  }
end;

symbol clâ†ªlist : Clause â†’ ğ•ƒ o;
rule clâ†ªlist â–© â†ª â–¡
with clâ†ªlist ($x âŸ‡ $xs) â†ª $x â¸¬ (clâ†ªlist $xs);

symbol listâ†ªcl :  ğ•ƒ o â†’ Clause;
rule listâ†ªcl â–¡ â†ª â–©
with listâ†ªcl ($x â¸¬ $xs) â†ª $x âŸ‡ (listâ†ªcl $xs);

coerce_rule coerce Clause (ğ•ƒ o) $x â†ª clâ†ªlist $x;
coerce_rule coerce (ğ•ƒ o) Clause  $x â†ª listâ†ªcl $x;

symbol âˆ¨â‚‘â‚™ (l : ğ•ƒ o) : Ï€Ì‡ ((disj l) âŸ‡ â–©) â†’ Ï€Ì‡ (cl_to_list l) â‰”
begin
simplify;
induction
{simplify; assume h; apply âˆ¨â‚‘ h { refine Î» x, x } { refine Î» x, x }}
{
  simplify;
  assume x xs ih;
  change Ï€ ((x âˆ¨ disj xs) âˆ¨ âŠ¥ â‡’ x âˆ¨ âŸ‡_to_âˆ¨_rw (listâ†ªcl (cl_to_list (listâ†ªcl xs))));
  rewrite or_identity_r;
  assume h;
  apply âˆ¨â‚‘ h
  { assume hx; apply âˆ¨áµ¢â‚; refine hx }
  { assume hxs; apply âˆ¨áµ¢â‚‚; apply ih; apply âˆ¨áµ¢â‚; refine hxs}
}
end;