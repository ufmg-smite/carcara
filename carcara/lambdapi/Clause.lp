require open lambdapi.Alethe;
require open Stdlib.Comp;



protected symbol compN : â„• â†’ â„• â†’ Comp;

rule compN _0 _0 â†ª Eq
with compN _0 (_ +1) â†ª Lt
with compN (_ +1) _0 â†ª Gt
with compN ($x +1) ($y +1) â†ª compN $x $y;

protected opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
begin
induction
{ induction
  {assume h; reflexivity}
  {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
}
{ assume x hx; induction
  {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
  {assume y hy h; apply feq (+1); apply hx y h }
}
end;

inductive ClauseAlg : TYPE â‰”
| p : â„• â†’ ClauseAlg;

symbol cl : Set;
rule Ï„ cl â†ª ClauseAlg;


symbol compCl : ClauseAlg â†’ ClauseAlg â†’ Comp;
rule compCl (p $i) (p $j) â†ª compN $i $j
;

symbol split [a: Set] (l : Ï„ (list a)): Ï„(list a Ã— list a);
rule split â–¡ â†ª (â–¡ â€š â–¡)
with split ($x â¸¬ â–¡) â†ª (($x â¸¬ â–¡) â€š â–¡)
with split ($x â¸¬ $y â¸¬ $l) â†ª
    let res â‰”  (split $l) in
        ($x â¸¬ (res â‚)) â€š ($y â¸¬ (res â‚‚));

symbol list_ind2_principle [A : Set]  :
  Î  (P : Ï„ (list A) â†’ Prop),
    Ï€ (P â–¡) â†’
    (Î  (a: Ï„ A), Ï€ (P (a â¸¬ â–¡))) â†’
    (Î  (a b : Ï„ A) (l : Ï„ (list A)), Ï€ (P l) â†’  Ï€ (P (a â¸¬ b â¸¬ l))) â†’
    Î  (l : Ï„ (list A)), Ï€ (P l);


symbol den: ğ•ƒ o â†’ ğ•ƒ cl â†’ Prop;
rule den $Ïƒ â–¡ â†ª âŠ¥
with den $Ïƒ ((p $i) â¸¬ $xs) â†ª (nth âŠ¥ $Ïƒ $i) âˆ¨ (den $Ïƒ $xs)
;



constant symbol R : TYPE;
constant symbol Index : â„• â†’ R;
constant symbol New : â„• â†’ R;

symbol case [a] : R â†’ (â„• â†’ Ï„ a) â†’ (â„• â†’ Ï„ a) â†’ Ï„ a;

rule case (Index $i) $f _ â†ª $f $i
with case (New $i) _ $g â†ª $g $i;

/* index of a value in a list: returns New if the value is not
definitionally equivalent to some element of the list */

sequential symbol index: â„• â†’ Î  [a], Ï„ a â†’ Ï„(list a) â†’ R;

rule index $k _ â–¡ â†ª New $k
with index $k $x ($x â¸¬ _) â†ª Index $k
with index $k $x ($y â¸¬ $l) â†ª index ($k +1) $x $l;

//compute case (New Stdlib.Nat._0) (Î» i, (p i) â€š (â–¡)) (Î» i, (p i) â€š (âŠ¤ â¸¬ â–¡));

symbol rfy_cl: ğ•ƒ o â†’ Clause â†’ Ï„ (list cl Ã— list o);
rule rfy_cl $l â–© â†ª (â–¡ â€š $l)
with rfy_cl $l ($x âŸ‡ $xs) â†ª 
  let X â‰”  case (index 0 $x $l) (Î» i, (p i) â€š $l) (Î» i, (p i) â€š ($l Stdlib.List.++ ($x â¸¬ â–¡))) in
  let x â‰” X â‚ in
  let l' â‰” X â‚‚ in
  let xs â‰” rfy_cl l' $xs in
    ((x â¸¬ (xs â‚)) â€š (xs â‚‚));

symbol reify_cl â‰” rfy_cl â–¡;

symbol a: Prop;
symbol b: Prop;

compute reify_cl (a âŸ‡ b âŸ‡ â–©);

compute  den ((reify_cl (a âŸ‡ b âŸ‡ â–©)) â‚‚) ((reify_cl (a âŸ‡ b âŸ‡ â–©)) â‚);

assert a b âŠ¢ reify_cl (a âŸ‡ b âŸ‡ â–©) â‰¡ (((p 0) â¸¬ (p 1) â¸¬ â–¡) â€š (a â¸¬ b â¸¬ â–¡));

assert a b âŠ¢ den ((reify_cl (a âŸ‡ b âŸ‡ â–©)) â‚‚) ((reify_cl (a âŸ‡ b âŸ‡ â–©)) â‚) â‰¡  âŸ‡_to_âˆ¨_rw (a âŸ‡ b âŸ‡ â–©);

opaque symbol ++_eq_âˆ¨ l x y : Ï€ ((den l (x Stdlib.List.++ y)) = (den l x âˆ¨ den l y)) â‰”
begin
    assume l;
    induction
    {
        assume y;
        simplify;
        rewrite or_identity_l;
        reflexivity
    }
    {
        induction;
        assume i xs ih;
        assume y;
        simplify;
        rewrite ih;
        rewrite âˆ¨_assoc;
        reflexivity
    }
end;

// symbol flat: Ï„(list cl) â†’ Ï„ cl;

// rule flat â–¡ â†ª Cst 0
// with flat ($x â¸¬ $l) â†ª Add $x (sum $l);

opaque symbol split_correct l gs : Ï€ (den l ((split gs â‚) Stdlib.List.++ (split gs â‚‚)) = den l gs) â‰”
begin
assume l;
refine list_ind2_principle (Î» u, den l ((split u â‚) Stdlib.List.++ (split u â‚‚)) = den l u) _ _ _
{ reflexivity }
{ reflexivity }
{
    induction;
    assume i;
    induction;
    assume j;
    assume tl ih;
    simplify;
    rewrite left ih;
    rewrite ++_eq_âˆ¨;
    rewrite ++_eq_âˆ¨;
    simplify;
    rewrite .[in x in (_ âˆ¨ x ) = _] âˆ¨_assoc;
    rewrite .[in x in (_ âˆ¨ (x âˆ¨ _) ) = _] âˆ¨_com;
    rewrite left .[in x in (_ âˆ¨ x ) = _] âˆ¨_assoc;
    reflexivity
}
end;

symbol merge  (l1 l2 : Ï„ (list cl)): Ï„ (list cl);
rule merge â–¡ â–¡ â†ª â–¡
with merge â–¡ $l2 â†ª $l2
with merge $l1 â–¡ â†ª $l1
with merge (p $i â¸¬ $l1') (p $j â¸¬ $l2') â†ª
    case_Comp (compN $i $j)
        (p $i â¸¬ p $j â¸¬ merge $l1' $l2')
        ((p $i) â¸¬ merge $l1' (p $j â¸¬ $l2'))
        (p $j â¸¬ merge (p $i â¸¬ $l1') $l2')
;


opaque symbol merge_correct l g1 g2 :  Ï€ (den l (merge  g1 g2) = (den l g1  âˆ¨ den l g2)) â‰”
begin
  assume l;
  induction
  {
        simplify; assume g2;
        rewrite or_identity_l; reflexivity
  }
  {
        induction; assume i xs ih;
        induction
        {
            simplify;
            rewrite or_identity_r; reflexivity
        }
        {
            induction;
            assume j ys ih2;
            simplify;
            refine ind_Comp (Î» u, (compN i j) = u â‡’  (den l (case_Comp u (p i â¸¬ (p j â¸¬ merge xs ys)) (p i â¸¬ merge xs (p j â¸¬ ys)) (p j â¸¬ merge (p i â¸¬ xs) ys)) = ((nth âŠ¥ l i âˆ¨ den l xs) âˆ¨ (nth âŠ¥ l j âˆ¨ den l ys)))) _ _ _ (compN i j) _
            {
                simplify;
                assume heq;
                rewrite ih;
                rewrite left .[x in _ = x] âˆ¨_assoc;
                rewrite  .[x in _ = ( _ âˆ¨ x)] âˆ¨_assoc;
                rewrite âˆ¨_com (den l xs) (nth âŠ¥ l j);
                rewrite left  .[x in _ = ( _ âˆ¨ x)] âˆ¨_assoc;
                reflexivity
            }
            {
                simplify; assume hlt;
                rewrite ih;
                simplify;
                rewrite âˆ¨_assoc;
                reflexivity
            }
            {
                simplify;
                assume hgt;
                rewrite ih2;
                simplify;
                rewrite .[x in (_ âˆ¨ x) = _] âˆ¨_com;
                rewrite âˆ¨_assoc;
                rewrite âˆ¨_com;
                reflexivity
            }
            {reflexivity}
        }
  }
end;


symbol mergesort:  Ï„ (list cl) â†’  Ï„ (list cl);
rule mergesort â–¡ â†ª â–¡
with mergesort ($x â¸¬ â–¡) â†ª ($x â¸¬ â–¡)
with mergesort ($x â¸¬ $y â¸¬ $l) â†ª
    let s â‰” split ($x â¸¬ $y â¸¬ $l) in
    let l1 â‰” s â‚ in
    let l2 â‰” s â‚‚ in
        merge (mergesort l1) (mergesort l2);



opaque symbol rec_ğ•ƒ : Î  [a: Set], Î  l: ğ•ƒ a, Î  p: (ğ•ƒ a â†’ Prop), Ï€ (p â–¡) â†’ (Î  x0: Ï„ a, Î  l': ğ•ƒ a, Ï€ (p (x0 â¸¬ l'))) â†’ Ï€ (p l) â‰”
begin
  assume a l P H1 H2;
  refine @ind_ğ•ƒ a P H1 (Î» x l' ih, H2 x l') l
end;

opaque symbol case_l [a] x (l: ğ•ƒ a) n : Ï€ ((size (x â¸¬ l)) â‰¤ (n +1)) â†’ Ï€ (size l â‰¤ n) â‰”
begin
  assume a x l n;
  refine Î» x, x;
end;

opaque symbol size_split [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚) â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚) â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol size_split2 [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚‚) â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚‚) â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;


opaque symbol mergesort_correct_aux n l g : Ï€ (size g â‰¤ n) â†’  Ï€ (den l (mergesort g) = den l g) â‰”
begin
induction
{
    assume l g h;
    rewrite size0nil g (â‰¤0 (size g) h);
    reflexivity
}
{
    assume n ihn l g;
    refine rec_ğ•ƒ g (Î» g, (istrue (size g â‰¤ (n +1))) â‡’ (den l (mergesort g) = den l g)) _ _
    { simplify; assume h; reflexivity }
    {
        induction; assume i gs;
        refine rec_ğ•ƒ gs (Î» gs, istrue (size (p i â¸¬ gs) â‰¤ (n +1)) â‡’ (den l (mergesort (p i â¸¬ gs)) = den l (p i â¸¬ gs))) _ _
        {
            simplify;
            assume h;
            reflexivity
        }
        {
            induction;
            assume j xs inv;
            simplify;
            rewrite merge_correct;
            have h1:  Ï€ ((size (p i â¸¬ (split xs â‚))) â‰¤ n) {
                apply @leq_trans
                (size (split xs â‚) +1)
                (size xs +1)
                n
                _
                inv;
                apply size_split xs;
            };
            have h2:  Ï€ ((size (p j â¸¬ (split xs â‚‚))) â‰¤ n) {
                apply @leq_trans
                (size (split xs â‚‚) +1)
                (size xs +1)
                n
                _
                inv;
                apply size_split2 xs;
            };
            rewrite ihn l (p i â¸¬ (split xs â‚)) h1;
            rewrite ihn l (p j â¸¬ (split xs â‚‚)) h2;
            simplify;
            rewrite left âˆ¨_assoc;
            rewrite .[x in (_ âˆ¨ x) = _] âˆ¨_assoc;
            rewrite âˆ¨_com (den l (split xs â‚)) (nth âŠ¥ l j);
            rewrite left âˆ¨_assoc;
            rewrite left ++_eq_âˆ¨ l (split xs â‚) (split xs â‚‚);
            rewrite split_correct;
            reflexivity
        }
    }
}
end;

symbol mergesort_correct l g â‰” mergesort_correct_aux (size g) l g (â‰¤_refl (size g));

symbol remove_iden: Ï„ (list cl) â†’ Ï„ (list cl);
rule remove_iden â–¡ â†ª â–¡
with remove_iden ((p $i) â¸¬ â–¡) â†ª (p $i) â¸¬ â–¡
with remove_iden ((p $i) â¸¬ (p $j) â¸¬ $tl) â†ª case_Comp (compN $i $j)
                                            (remove_iden ((p $j) â¸¬ $tl))
                                            ((p $i) â¸¬ (remove_iden ((p $j) â¸¬ $tl)))
                                            ((p $i) â¸¬ (remove_iden ((p $j) â¸¬ $tl)));


// Rule contraction:
// ğ‘–. âŠ³ ğ‘™1, ... , ğ‘™n    (...)
// ğ‘—. âŠ³  ğ‘™ğ‘˜1, ... , ğ‘™kn (contraction i)
symbol contraction g â‰” remove_iden (mergesort g);

opaque symbol remove_iden_correct l g : Ï€ (den l (remove_iden g) = den l g) â‰”
begin
  assume l;
  induction
  {simplify;reflexivity}
  {
    induction; assume i;
    induction
    {
      assume h; reflexivity
    }
    {
      induction; assume j gs ih1 ih2;
      simplify;
      refine ind_Comp (Î» u, (compN i j) = u â‡’  den l (case_Comp u (remove_iden (p j â¸¬ gs)) (p i â¸¬ remove_iden (p j â¸¬ gs)) (p i â¸¬ remove_iden (p j â¸¬ gs))) = (nth âŠ¥ l i âˆ¨ (nth âŠ¥ l j âˆ¨ den l gs))) _ _ _ (compN i j) _
      {
        simplify;
        assume heq;
        rewrite compN_correct i j heq;
        rewrite âˆ¨_assoc;
        rewrite or_idempotent (nth âŠ¥ l j);
        rewrite ih2;
        reflexivity
      }
      {
        simplify;
        assume hlt;
        rewrite ih2;
        reflexivity
      }
      {
        simplify;
        assume hlt;
        rewrite ih2;
        reflexivity
      }
      {reflexivity}
    }
  }
end;

opaque symbol contraction_correct l g : Ï€ (den l (contraction g) = den l g) â‰”
begin
  assume l g;
  simplify;
  rewrite remove_iden_correct;
  rewrite mergesort_correct;
  reflexivity
end;

opaque symbol contraction_correct_r l g : Ï€ (den l g = den l (contraction g)) â‰”
begin
  assume l g;
  symmetry;
  refine contraction_correct l g
end;

private symbol example a b : Ï€Ì‡ (a âŸ‡ b âŸ‡ b âŸ‡ â–©) â†’ Ï€Ì‡ (a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b i;
  set X â‰” (a âŸ‡ (b âŸ‡ (b âŸ‡ â–©)));
  set Y â‰” (a âŸ‡ b âŸ‡ â–©);
  have g : Ï€ (âŸ‡_to_âˆ¨_rw X = âŸ‡_to_âˆ¨_rw Y) {
    set r â‰” reify_cl X;
    change Ï€ (den (r â‚‚) (r â‚) = âŸ‡_to_âˆ¨_rw Y);
    rewrite left contraction_correct;
    reflexivity
  };
  refine subst_equiv_clause X Y  g i
end;
