require open lambdapi.Alethe;
require open lambdapi.Simplify;

notation Â¬ prefix 35;


// (define-rule eq-refl ((t ?)) (= t t) true)
opaque symbol eq-refl [a] (t: Ï„ a) : Ï€ ((t = t) = âŠ¤) â‰” begin
    assume a p;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume H; remove H; apply âŠ¤áµ¢  }
    { assume HâŠ¤; remove HâŠ¤; reflexivity } 
end;

// (define-rule eq-symm ((t ?) (s ?)) (= t s) (= s t))
opaque symbol eq-symm [a] (t s: Ï„ a) : Ï€ ((t = s) = (s = t)) â‰”
begin
    assume a t s;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        assume H;
        symmetry; apply H
    }
    {
        assume H;
        symmetry; apply H
    }
end;

// (define-rule bool-impl-false1 ((t Bool)) (=> t false) (not t))
opaque symbol bool-impl-false1 t : Ï€ ((t â‡’ âŠ¥) = Â¬ t) â‰” implies_simplify5 t;

// (define-rule bool-impl-false2 ((t Bool)) (=> false t) true)
opaque symbol bool-impl-false2 t : Ï€ ((âŠ¥ â‡’ t) = âŠ¤) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    { assume Htbot; apply âŠ¤áµ¢  }
    { assume Htop;  assume Ht; apply âŠ¥â‚‘ Ht }
end;

// (define-rule bool-double-not-elim ((t Bool)) (not (not t)) t)
// Duplicate of Alethe
opaque symbol bool-double-not-elim t : Ï€ ((Â¬ (Â¬ t)) = t) â‰” not_simplify1 t;


//(define-rule bool-impl-elim ((t Bool) (s Bool)) (=> t s) (or (not t) s))
opaque symbol bool-impl-elim s t: Ï€ ((s â‡’ t) = ((Â¬ s) âˆ¨ t)) â‰”
begin
  assume s t;
  apply prop_ext;
  apply âˆ§áµ¢
  {  assume Himp; apply imply_to_or Himp }
  {  assume Hor; refine or_to_imply Hor }
end;

//(define-rule distinct-binary-elim ((t ?) (s ?)) (distinct t s) (not (= t s)))
opaque symbol distinct-binary-elim [a] (t s: Ï„ a) : Ï€ (distinct (cons t (cons s â§ˆ)) = ( t â‰  s)) â‰” eq_refl (distinct (cons t (cons s â§ˆ)));

// (define-rule bool-impl-true2 ((t Bool)) (=> true t) t)
opaque symbol bool-impl-true2 t : Ï€ ((âŠ¤ â‡’ t) = t) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {   assume HTopt; apply HTopt âŠ¤áµ¢ }
    {  assume Ht;  assume Htop; apply Ht }
end;

// (define-rule bool-impl-true1 ((t Bool)) (=> t true) true)
opaque symbol bool-impl-true1 t : Ï€ ((t â‡’ âŠ¤) = âŠ¤) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {   assume HTopt; apply âŠ¤áµ¢ }
    {  assume Ht;  assume Htop; apply âŠ¤áµ¢ }
end;


// (define-rule* bool-and-true ((xs Bool :list) (ys Bool :list)) (and xs true ys) (and xs ys))
opaque symbol bool-and-true xs ys : Ï€ ((xs âˆ§ âŠ¤ âˆ§ ys) = (xs âˆ§ ys)) â‰”
begin
    assume xs ys;
    rewrite âˆ§_com âŠ¤ ys;
    rewrite and_identity_r;
    reflexivity
end;

// (define-rule bool-and-false ((xs Bool :list) (ys Bool :list)) (and xs false ys) false)
opaque symbol bool-and-false xs ys : Ï€ ((xs âˆ§ âŠ¥ âˆ§ ys) = âŠ¥) â‰”
begin
    assume xs ys;
    rewrite âˆ§_com âŠ¥ ys;
    rewrite and_domination;
    rewrite and_domination;
    reflexivity
end;

// (define-rule* bool-or-false ((xs Bool :list) (ys Bool :list)) (or xs false ys) (or xs ys))
opaque symbol bool-or-false xs ys : Ï€ ((xs âˆ¨ âŠ¥ âˆ¨ ys) = (xs âˆ¨ ys)) â‰”
begin
    assume xs ys; 
    rewrite âˆ¨_com âŠ¥ ys;
    rewrite or_identity_r;
    reflexivity
end;

// (define-rule* bool-or-flatten ((xs Bool :list) (b Bool) (ys Bool :list) (zs Bool :list)) (or xs (or b ys) zs) (or xs b ys zs))
opaque symbol bool-or-flatten xs b ys zs : Ï€ ((xs âˆ¨ (b âˆ¨ ys) âˆ¨ zs) = (xs âˆ¨ b âˆ¨ ys âˆ¨ zs)) â‰”
begin
    assume xs b ys zs;
    rewrite left âˆ¨_assoc;
    reflexivity
end;


// Reviewed bool-or-flatten without `xs`
// (define-rule* bool-or-flatten ((b Bool) (ys Bool :list) (zs Bool :list)) (or (or b ys) zs) (or b ys zs))
opaque symbol bool-or-flatten' b ys zs : Ï€ (((b âˆ¨ ys) âˆ¨ zs) = (b âˆ¨ ys âˆ¨ zs)) â‰”
begin
    assume b ys zs;
    symmetry;
    apply âˆ¨_assoc;
end;

// (define-rule* bool-and-flatten ((xs Bool :list) (b Bool) (ys Bool :list) (zs Bool :list)) (and xs (and b ys) zs) (and xs b ys zs))
opaque symbol bool-and-flatten b [xs ys zs] : Ï€ ((xs âˆ§ (b âˆ§ ys) âˆ§ zs) = (xs âˆ§ b âˆ§ ys âˆ§ zs)) â‰”
begin
    assume b xs ys zs;
    rewrite left âˆ§_assoc;
    reflexivity
end;

// Reviewed bool-and-flatten without `xs`
// (define-rule* bool-and-flatten ((b Bool) (ys Bool :list) (zs Bool :list)) (and (and b ys) zs) (and b ys zs))
opaque symbol bool-and-flatten' b ys zs : Ï€ (((b âˆ§ ys) âˆ§ zs) = (b âˆ§ ys âˆ§ zs)) â‰”
begin
    assume b ys zs;
    symmetry;
    apply âˆ§_assoc;
end;

// (define-rule bool-eq-true ((t Bool)) (= t true) t)
opaque symbol bool-eq-true (t: Ï„ o) : Ï€ ((t = âŠ¤) = t) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        
        assume H;
        rewrite H;
        apply âŠ¤áµ¢
    }
    {
        
        assume Ht;
        apply prop_ext;
        apply âˆ§áµ¢
        {  assume Ht'; apply âŠ¤áµ¢ }
        {  assume Ht';  apply Ht }
    }
end;

// (define-rule bool-eq-false ((t Bool)) (= t false) (not t))
opaque symbol bool-eq-false (t: Ï„ o) : Ï€ ((t = âŠ¥) = Â¬ t) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        
        assume H;
        rewrite H;
        assume Hbot;
        apply Hbot
    }
    {
        
        assume Hnt;
        apply prop_ext;
        apply âˆ§áµ¢
        {   assume Ht; apply (Â¬â‚‘ Hnt Ht) }
        {  assume Ht';  apply (âŠ¥â‚‘ Ht') }
    }
end;

// (define-rule* bool-and-de-morgan ((x Bool) (y Bool) (zs Bool :list)) 
//   (not (and x y zs))
//   (not (and y zs))
//   (or (not x) _))
opaque symbol bool-and-de-morgan (x y zs: Ï„ o): Ï€ ((Â¬ (x âˆ§ y âˆ§ zs)) = ((Â¬ x) âˆ¨ (Â¬ y) âˆ¨ (Â¬ zs))) â‰”
begin
    assume x y zs;
    apply prop_ext;
    apply âˆ§áµ¢
    { rewrite morgan1; rewrite morgan1;  assume H; refine H }
    { rewrite morgan1; rewrite morgan1;  assume H; refine H }
end;

// (define-rule* bool-or-de-morgan ((x Bool) (y Bool) (zs Bool :list)) 
//   (not (or x y zs))
//   (not (or y zs))
//   (and (not x) _))
opaque symbol bool-or-de-morgan (x y zs: Ï„ o): Ï€ ((Â¬ (x âˆ¨ y âˆ¨ zs)) = ((Â¬ x) âˆ§ (Â¬ y) âˆ§ (Â¬ zs))) â‰”
begin
    assume x y zs;
    apply prop_ext;
    apply âˆ§áµ¢
    { rewrite morgan2; rewrite morgan2;  assume H; refine H }
    { rewrite morgan2; rewrite morgan2;  assume H; refine H }
end;


// Integer
require open Stdlib.Z;
require open Stdlib.Bool;
require open Stdlib.Comp;
require open Stdlib.Pos;

notation â‰¥ infix 10; //FIXME: fix notation in Stdlib

// (define-rule arith-elim-lt ((t ?) (s ?)) (< t s) (not (>= t s)))
opaque symbol arith-elim-lt t s : Ï€ ((t < s) = Â¬ (t â‰¥ s)) â‰”
begin
    assume t s;
    simplify;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        assume H;
        assume H2;
        apply fold_â‡’ H2;
        apply H  
    }
    {
        assume H;
        have H2: Ï€ (Â¬ Â¬ istrue (isLt (t â‰ s))) { refine H };
        rewrite left nnpp_eq;
        refine H2
    }
end;

symbol ind_â„¤ (p: (â„¤ â†’ Prop)) :
    Î  x,  Ï€ (p 0) â†’ 
    (Î  (y: â„™), Ï€ (p (Zpos y))) â†’ 
    (Î  (y: â„™), Ï€ (p (Zneg y))) â†’ 
    Ï€ (p x);


symbol ind_â„¤â‚‚ (p: (â„¤ â†’ Prop)) :
     Ï€ (p 0) â†’ 
    (Î  (y: â„™), Ï€ (p (Zpos y))) â†’ 
    (Î  (y: â„™), Ï€ (p (Zneg y))) â†’ 
    Î  x, Ï€ (p x);

symbol ind_â„™ (p: â„™ â†’ Prop):
    Î  (x: â„™), (Î  y: â„™, Ï€ (p y) â†’ Ï€ (p (I y))) â†’
    (Î  y: â„™, Ï€ (p y) â†’
    Ï€ (p (O y))) â†’
    Ï€ (p H) â†’ Ï€ (p x);

// (define-rule arith-geq-tighten ((t Int) (s Int)) (not (>= t s)) (>= s (+ t 1)))
opaque symbol arith-geq-tighten t s : Ï€ ((Â¬ (t â‰¥ s)) = (s â‰¥ (t + 1))) â‰”
begin
admitted;

// (define-rule arith-geq-norm2 ((t ?) (s ?)) (>= t s) (<= (- t) (- s)))
opaque symbol arith-geq-norm2 t s : Ï€ ((t â‰¥ s) =  (â€” t â‰¤ â€” s)) â‰”
begin 
    assume t s;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        refine (âˆ§â‚‘â‚ (opp_le_mono t s));
    }
    {
        refine (âˆ§â‚‘â‚‚ (opp_le_mono t s));
    }
end;

// (define-rule arith-geq-norm1 ((t ?) (s ?)) (>= t s) (>= (- t s) 0))
opaque symbol arith-geq-norm1 t s : Ï€ ((t â‰¥ s) = ((t - s) â‰¥ 0)) â‰”
begin 
    assume t s;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        refine ge_implies_diff_nonneg t s;
    }
    {
        refine diff_nonneg_implies_ge t s;
    }
end;

// (define-rule arith-leq-norm ((t Int) (s Int)) (<= t s) (not (>= t (+ s 1))))
opaque symbol arith-leq-norm (t s: Ï„ int) : Ï€ ((t â‰¤ s) = Â¬ (t â‰¥ s + 1)) â‰”
begin
    assume t s;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        refine â‰¤-norm t s
    }
    {
        admit //TODO: prove me
    }
end;

// (define-rule arith-elim-gt ((t ?) (s ?)) (> t s) (not (<= t s)))
opaque symbol arith-elim-gt (t s: Ï„ int) : Ï€ ((t > s) = (Â¬ (t â‰¤ s))) â‰”
begin 
assume t s;
apply prop_ext;
apply âˆ§áµ¢
{
    refine >_neg_â‰¤ t s
}
{
    refine (Î» x, x);
}
end;

// (define-rule arith-elim-leq ((t ?) (s ?)) (<= t s) (>= s t))
opaque symbol arith-elim-leq (t s: Ï„ int) : Ï€ ((t â‰¤ s) = (s â‰¥ t)) â‰”
begin 
    assume t s;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        assume H;
        refine (âˆ§â‚‘â‚‚ (â‰¤_â‰¥ s t)) H
    }
    {
        assume H;
        refine (âˆ§â‚‘â‚ (â‰¤_â‰¥ s t)) H
    }
end;

// (define-rule arith-refl-leq ((t ?)) (<= t t) true)
opaque symbol arith-refl-leq (t: Ï„ int) : Ï€ ((t â‰¤ t) = âŠ¤) â‰”
begin
assume t;
apply prop_ext;
apply âˆ§áµ¢
{  assume H; apply âŠ¤áµ¢ }
{
     assume Htop;
    refine (â‰¤_refl t)
}
end;

// (define-rule arith-refl-lt ((t ?)) (< t t) false)
opaque symbol arith-refl-lt (t: Ï„ int) : Ï€ ((t < t) = âŠ¥) â‰”
begin
    assume t;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        refine <_no_refl t
    }
    {
        
        assume Hbot;
        apply âŠ¥â‚‘ Hbot 
    }
end;

// (define-rule arith-refl-geq ((t ?)) (>= t t) true)
opaque symbol arith-refl-geq (t: Ï„ int) : Ï€ ((t â‰¥ t) = âŠ¤) â‰”
begin
assume t;
apply prop_ext;
apply âˆ§áµ¢
{  assume H; apply âŠ¤áµ¢ }
{
     assume Htop;
    refine (â‰¥_refl t)
}
end;

// (define-rule arith-refl-gt ((t ?)) (> t t) false)
opaque symbol arith-refl-gt (t: Ï„ int) : Ï€ ((t > t) = âŠ¥) â‰”
begin 
assume t;
apply prop_ext;
apply âˆ§áµ¢
{
    generalize t;
    assume t;
    refine >_no_refl t;
}
{
    
    assume Hbot;
    apply âŠ¥â‚‘ Hbot 
};
end;

// (define-rule arith-int-eq-elim ((t Int) (s Int)) (= t s) (and (>= t s) (<= t s)))
opaque symbol arith-int-eq-elim (t s: Ï„ int) : Ï€ ((t = s) = ((t â‰¥ s) âˆ§ (t â‰¤ s))) â‰”
begin
assume t s;
apply prop_ext;
apply âˆ§áµ¢
{
     assume Heq;
    rewrite Heq;
    apply âˆ§áµ¢ 
    {
        refine (â‰¥_refl s)
    }
    {
        refine (â‰¤_refl s)
    }
}
{
    assume H1;
    refine  â‰¤_antisym t s _ _
    {
        refine (âˆ§â‚‘â‚ (â‰¤_â‰¥ s t)) _;
        refine (âˆ§â‚‘â‚‚ (â‰¤_â‰¥ s t)) (âˆ§â‚‘â‚‚ H1);
    }
    {  refine  (âˆ§â‚‘â‚ (â‰¤_â‰¥ t s)) (âˆ§â‚‘â‚ H1); }
}
end;

//  (define-rule* bool-implies-or-distrib
//  ((y1 Bool) (y2 Bool) (ys Bool :list) (z Bool))
//      (=> (or y1 y2 ys) z)
//      (=> (or y2 ys) z)
//      (and (=> y1 z) _))
// Version without list of disjuncts `ys`
opaque symbol bool_implies_or_distrib (y1 y2 z: Ï„ o) : Ï€ (((y1 âˆ¨ y2) â‡’ z) = ((y1 â‡’ z) âˆ§ (y2 â‡’ z))) â‰”
begin
    assume y1 y2 z;
    apply prop_ext;
    apply âˆ§áµ¢
    {
        assume H;
        apply âˆ§áµ¢
        { assume H1; refine H (âˆ¨áµ¢â‚ H1) }
        { assume H2; refine H (âˆ¨áµ¢â‚‚ H2) }
    }
    {
        assume H H1;
        apply âˆ¨â‚‘ H1
        { assume H2; refine (âˆ§â‚‘â‚ H) H2 }
        { assume Hy; refine (âˆ§â‚‘â‚‚ H) Hy }
    }
end;

//  (define-rule* bool-implies-or-distrib
//  ((y1 Bool) (y2 Bool) (ys Bool :list) (z Bool))
//      (=> (or y1 y2 ys) z)
//      (=> (or y2 ys) z)
//      (and (=> y1 z) _))
// Version with list of disjuncts `ys`
opaque symbol bool_implies_or_distrib_rec (y1 y2 ys z: Ï„ o) : Ï€ (((y1 âˆ¨ y2 âˆ¨ ys) â‡’ z) = ((y1 â‡’ z) âˆ§ (y2 âˆ¨ ys â‡’ z))) â‰”
begin
    assume y1 y2 ys z;
    refine bool_implies_or_distrib y1 (y2 âˆ¨ ys) z;
end;

// //FIXME: Move to Lia.lp ?
// la_disequality: ğ‘¡1 â‰ˆ ğ‘¡2 âˆ¨ Â¬(ğ‘¡1 â‰¤ ğ‘¡2) âˆ¨ Â¬(ğ‘¡2 â‰¤ ğ‘¡1 )
opaque symbol la_disequality (t1 t2: Ï„ int) : Ï€Ì‡ (((t1 = t2) âˆ¨ Â¬ (t1 â‰¤ t2) âˆ¨ Â¬ (t2 â‰¤ t1)) âŸ‡ â–©) â‰”
begin
  assume t1 t2;
  apply âˆ¨áµ¢â‚;
  rewrite âˆ¨_com;
  rewrite left âˆ¨_assoc;
  rewrite imp_eq_or;
  rewrite imp_eq_or;
  refine â‰¤_antisym t1 t2
end;

opaque symbol la_totality (t1 t2: Ï„ int) : Ï€Ì‡ (((t1 â‰¤ t2) âˆ¨ (t2 â‰¤ t1)) âŸ‡ â–©) â‰”
begin
  assume t1 t2;
  apply âˆ¨áµ¢â‚;
  refine â‰¤_total t1 t2
end;