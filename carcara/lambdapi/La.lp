require open Stdlib.Z;
require Stdlib.Nat as Nat;
open Stdlib.Nat;
require open Stdlib.Rat Stdlib.List;

// Move into HOL.lp ?
symbol â‡’d : Î  (x: Prop), (Ï€ x â†’ Prop) â†’ Prop; notation â‡’d infix 10;
rule Ï€ ($x â‡’d $y) â†ª Î  (z: Ï€ $x), Ï€ ($y z);

// type for rational arithmetic expressions
inductive G: TYPE â‰”
| Cst: Ï„ rat â†’ G
| Var: â„• â†’ Ï„ rat â†’ G
| Add: G â†’ G â†’ G
; 

constant symbol grp : Set;
rule Ï„ grp â†ª G;

// multiplication by a constant

symbol mul: Ï„ rat â†’ G â†’ G;

rule mul $k (Cst $l) â†ª Cst ($k q* $l)
with mul $k (Var $i $l) â†ª Var $i ($k q* $l)
with mul $k (Add $x $y) â†ª Add (mul $k $x) (mul $k $y);

// opposite

symbol opp â‰” mul (q~ 1â«½1);

// highest variable index in a term

symbol varmax : G â†’ â„•;

rule varmax (Cst _) â†ª _0
with varmax (Var $k _) â†ª $k
with varmax (Add $x $y) â†ª max (varmax $x) (varmax $y);

/* evaluation of an arithmetic expression wrt a list of values for variables

variables with indexes not in the list are interpreted by 0 */


symbol â„•2Rat (x: â„•): Ï„ rat;
rule â„•2Rat _0 â†ª 0â«½1
with â„•2Rat ($n +1) â†ª (â„•2Rat $n) q+ 1â«½1;


symbol nth â‰” nth (â„•2Rat _0);

symbol val: Ï„ (grp Ã— list rat) â†’ Ï„ rat;

// type nth;

rule val (Cst $k â€š _) â†ª $k
with val (Var $i $k â€š $l) â†ª (nth $l $i) q* $k
with val (Add $x $y â€š $l) â†ª val ($x â€š $l) q+ val ($y â€š $l);

symbol va l x â‰” val (x â€š l);

// // // some useful type (use inductive instead?)

constant symbol R : TYPE;
constant symbol Index : â„• â†’ R;
constant symbol New : â„• â†’ R;

symbol case [a] : R â†’ (â„• â†’ Ï„ a) â†’ (â„• â†’ Ï„ a) â†’ Ï„ a;

rule case (Index $i) $f _ â†ª $f $i
with case (New $i) _ $g â†ª $g $i;

// // /* index of a value in a list: returns New if the value is not
// // definitionally equivalent to some element of the list */

sequential symbol index: â„• â†’ Î  [a], Ï„ a â†’ Ï„(list a) â†’ R;

rule index $k _ â–¡ â†ª New $k
with index $k $x ($x â¸¬ _) â†ª Index $k
with index $k $x ($y â¸¬ $l) â†ª index ($k +1) $x $l;

compute index _0 1 (1 â¸¬ 4 â¸¬ â–¡);

// // /* reification: given a Lambdapi term x of type â„¤, compute an
// // expression in G and a list of values whose evaluation is equal to
// // x. WARNING: rfy is sequential. */

sequential symbol rfy: Ï„(list rat) â†’ Ï„ rat â†’ Ï„(grp Ã— list rat);

rule rfy $l ($x q+ $y) â†ª
  let x â‰” rfy $l $x in
    let y â‰” rfy (x â‚‚) $y in
      Add (x â‚) (y â‚) â€š (y â‚‚)
with rfy $l (q~ $x) â†ª
  let x â‰” rfy $l $x in
  opp (x â‚) â€š (x â‚‚)

with rfy $l ($x q- $y) â†ª rfy $l ($x q+ q~ $y)

with rfy $l (Rat 0 $d $inv) â†ª Cst (Rat 0 $d $inv) â€š $l
with rfy $l (Rat (Zpos $n) (Zpos $d) $inv) â†ª Cst (Rat (Zpos $n) (Zpos $d) $inv) â€š $l
with rfy $l (Rat (Zpos $n) (Zneg $d) $inv) â†ª Cst (Rat (Zpos $n) (Zneg $d) $inv) â€š $l
with rfy $l (Rat (Zneg $z) (Zpos $d) $inv) â†ª Cst (Rat (Zneg $z) (Zpos $d) $inv) â€š $l
with rfy $l (Rat (Zneg $z) (Zneg $d) $inv) â†ª Cst (Rat (Zneg $z) (Zneg $d) $inv) â€š $l
with rfy $l (fracq 0 $d) â†ª Cst (fracq 0 $d) â€š $l
with rfy $l (fracq (Zpos $n) (Zpos $d)) â†ª Cst (fracq (Zpos $n) (Zpos $d)) â€š $l
with rfy $l (fracq (Zpos $n) (Zneg $d)) â†ª Cst (fracq (Zpos $n) (Zneg $d)) â€š $l
with rfy $l (fracq (Zneg $z) (Zpos $d)) â†ª Cst (fracq (Zneg $z) (Zpos $d)) â€š $l
with rfy $l (fracq (Zneg $z) (Zneg $d)) â†ª Cst (fracq (Zneg $z) (Zneg $d)) â€š $l
with rfy $l (0â«½1 q* _) â†ª Cst 0â«½1 â€š $l
// with rfy $l (Zpos $k * $x) â†ª
//   let x â‰” rfy $l $x in
//   mul (Zpos $k) (x â‚) â€š x â‚‚
// with rfy $l (Zneg $k * $x) â†ª
//   let x â‰” rfy $l $x in
//   mul (Zneg $k) (x â‚) â€š x â‚‚
// with rfy $l ($x * Zpos $k) â†ª
//   let x â‰” rfy $l $x in
//   mul (Zpos $k) (x â‚) â€š x â‚‚
// with rfy $l ($x * Zneg $k) â†ª
//   let x â‰” rfy $l $x in
//   mul (Zneg $k) (x â‚) â€š x â‚‚
with rfy $l $x â†ª
  case (index _0 $x $l) (Î» i, Var i (1â«½1) â€š $l) (Î» i, Var i (1â«½1) â€š ($l ++ ($x â¸¬ â–¡)))
;

symbol reify â‰” rfy â–¡;

compute reify (fracq 120 4);

opaque symbol reify_correct (x: TRat) : Ï€(val(reify x) = x) â‰”
begin
    assume x;
    simplify;
    change Ï€ ((x q* 1â«½1) = x);
    apply q*_neutral_r
end;

opaque nth;

// // aliens (constants and variables) of an arithmetic expression

symbol aliens: G â†’ Ï„(list grp);

rule aliens (Cst $k) â†ª Cst $k â¸¬ â–¡
with aliens (Var $i $k) â†ª Var $i $k â¸¬ â–¡
with aliens (Add $x $y) â†ª aliens $x ++ aliens $y;

symbol isNotAdd: Ï„ grp â†’ Prop; //FIXME: replace Prop by ğ”¹

rule isNotAdd (Cst _) â†ª âŠ¤
with isNotAdd (Var _ _ ) â†ª âŠ¤
with isNotAdd (Add _ _ ) â†ª âŠ¥;

symbol no_Add : Ï„(list grp) â†’ Prop;

rule no_Add â–¡ â†ª âŠ¤
with no_Add ($g â¸¬ $gs) â†ª  isNotAdd $g âˆ§ no_Add $gs;

opaque symbol no_Add_++ ys xs : Ï€(no_Add xs â‡’ no_Add ys â‡’ no_Add(xs ++ ys)) â‰”
begin
assume ys; induction
{assume h1 h2; refine h2}
{assume x xs IH h1 h2; simplify; apply âˆ§áµ¢ {refine âˆ§â‚‘â‚ h1} {apply IH {refine âˆ§â‚‘â‚‚ h1} {refine h2}}}
end;

opaque symbol no_Add_aliens x : Ï€(no_Add (aliens x)) â‰”
begin
induction
{assume k; simplify; apply âˆ§áµ¢ âŠ¤áµ¢ âŠ¤áµ¢}
{assume i ki; simplify; apply âˆ§áµ¢ âŠ¤áµ¢ âŠ¤áµ¢}
{assume x hx y hy; simplify; apply no_Add_++ (aliens y) (aliens x) hx hy; }
end;

// ordering of natural numbers
// move to Nat
symbol compN : â„• â†’ â„• â†’ Comp;

rule compN _0 _0 â†ª Eq
with compN _0 (_ +1) â†ª Lt
with compN (_ +1) _0 â†ª Gt
with compN ($x +1) ($y +1) â†ª compN $x $y;

opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
begin
induction
{ induction
  {assume h; reflexivity}
  {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
}
{ assume x hx; induction
  {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
  {assume y hy h; apply feq (+1); apply hx y h }
}
end;

// // normalization of arithmetic expressions

// /*
//symbol merge : Ï„(list grp) â†’ Ï„(list grp);

// rule merge â–¡ â†ª â–¡
// with merge ($x â¸¬ â–¡) â†ª $x â¸¬ â–¡
// with merge (Cst $k â¸¬ Cst $k' â¸¬ $l) â†ª merge (Cst ($k + $k') â¸¬ $l)
// with merge (Cst $k â¸¬ Var $i $ki â¸¬ $l) â†ª Cst $k â¸¬ merge (Var $i $ki â¸¬ $l)
// with merge (Var $i $ki â¸¬ Var $j $kj â¸¬ $l) â†ª
//   case_Comp (compN $i $j)
//             (merge (Var $i ($ki + $kj) â¸¬ $l))
//             (Var $i $ki â¸¬ merge (Var $j $kj â¸¬ $l))
//             (Var $i $ki â¸¬ merge (Var $j $kj â¸¬ $l))
// ;
// */

symbol remove0 : Ï„(list grp) â†’ Ï„(list grp);

rule remove0 â–¡ â†ª â–¡
with remove0 (Cst (Rat 0 _ _) â¸¬ $l) â†ª remove0 $l
with remove0 (Cst (Rat (Zpos $k) $p $inv)  â¸¬ $l) â†ª Cst (Rat (Zpos $k) $p $inv) â¸¬ remove0 $l
with remove0 (Cst (Rat (Zneg $k) $p $inv) â¸¬ $l) â†ª Cst (Rat (Zneg $k) $p $inv) â¸¬ remove0 $l
with remove0 (Var _ (Rat 0 _ _) â¸¬ $l) â†ª remove0 $l
with remove0 (Var $i (Rat (Zpos $n) $p $inv) â¸¬ $l) â†ª Var $i (Rat (Zpos $n) $p $inv) â¸¬ remove0 $l
with remove0 (Var $i (Rat (Zneg $z) $p $inv) â¸¬ $l) â†ª Var $i (Rat (Zneg $z) $p $inv) â¸¬ remove0 $l
;

symbol sum: Ï„(list grp) â†’ Ï„ grp;

rule sum â–¡ â†ª Cst 0â«½1
with sum ($x â¸¬ $l) â†ª Add $x (sum $l);

symbol vas l xs â‰” va l (sum xs);

opaque symbol remove0_correct l gs : Ï€ (no_Add gs) â†’  Ï€ (val (sum (remove0 gs) â€š l) = val (sum gs â€š l)) â‰”
begin
  assume l;
  induction // on l
  {
    reflexivity
  }
  {

    induction // on g
    {
        // Case Cst k
        induction;
        change Ï€  (`âˆ€ x0: Ï„ int, `âˆ€ x2: Ï„ int, (istrue (isLt (0 â‰ x2) and isEq (Z_gcd (abs x0) (abs x2) â‰ _1))) â‡’d Î» x3, (`âˆ€ x4, (no_Add x4 â‡’d (Î» _, val (sum (remove0 x4) â€š l) = val (sum x4 â€š l))) â‡’d (Î» _, no_Add (Cst (Rat x0 x2 x3) â¸¬ x4) â‡’d (Î» _, val (sum (remove0 (Cst (Rat x0 x2 x3) â¸¬ x4)) â€š l) = val (sum (Cst (Rat x0 x2 x3) â¸¬ x4) â€š l)))));
        assume n;
        generalize n;
        induction 
          // Case Z0
          { assume p inv gs IH H; simplify;  rewrite left valqK (Rat 0 p inv); simplify; rewrite frac_0_num; rewrite q+_neutral_l; apply IH;  refine (âˆ§â‚‘â‚‚ H) }
          // Case Zpos
          { assume p inv c gs IH H; simplify; rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity }
          // Case Zneg
          { assume p inv c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity }
    }
    {
      // Case Var i k
      assume i;
      induction;
      induction // on k
      {assume p inv gs IH H; simplify; rewrite left valqK (Rat 0 p inv); simplify; rewrite frac_0_num; rewrite q*_cancel_r; rewrite q+_neutral_l; apply IH; refine (âˆ§â‚‘â‚‚ H)} // Case Z0
      { assume p inv c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity } // Case Zpos
      { assume p inv c gs IH H; simplify;  rewrite (IH (âˆ§â‚‘â‚‚ H)); reflexivity } // Case Zneg
    }
    {
      // Case Add g1 g2
      // That violate the invariant: no_Add gs
      simplify;
      assume g1 IHg1 g2 IHg2 gs IHg H;
      refine âŠ¥â‚‘ (âˆ§â‚‘â‚ H)
    }
  }
end;

opaque symbol case_Comp_prop [a] (p:Ï„ a â†’ Prop) eq lt gt c :
  Ï€(p eq â‡’ p lt â‡’ p gt â‡’ p (case_Comp c eq lt gt)) â‰”
begin
assume a p eq lt gt; induction
{assume peq plt pgt; refine peq}
{assume peq plt pgt; refine plt}
{assume peq plt pgt; refine pgt}
end;

symbol insert: G â†’ Ï„(list grp) â†’ Ï„(list grp);

// /*
// rule insert (Cst $k) (Cst $k' â¸¬ $l) â†ª Cst $k â¸¬ Cst $k' â¸¬ $l
// with insert (Cst $k) (Var $i $k' â¸¬ $l) â†ª Cst $k â¸¬ Var $i $k' â¸¬ $l
// with insert (Var $i $k) (Cst $k' â¸¬ $l) â†ª Cst $k' â¸¬ insert (Var $i $k) $l
// with insert (Var $i $ki) (Var $j $kj â¸¬ $l) â†ª
//      case_Comp (compN $i $j)
//             (Var $i $ki â¸¬ Var $j $kj â¸¬ $l)
//             (Var $i $ki â¸¬ Var $j $kj â¸¬ $l)
//             (Var $j $kj â¸¬ insert (Var $i $ki) $l);
// */

rule insert $x â–¡ â†ª $x â¸¬ â–¡
with insert (Cst $k) (Cst $k' â¸¬ $l) â†ª Cst ($k q+ $k') â¸¬ $l
with insert (Cst $k) (Var $i $k' â¸¬ $l) â†ª Cst $k â¸¬ Var $i $k' â¸¬ $l
with insert (Var $i $k) (Cst $k' â¸¬ $l) â†ª Cst $k' â¸¬ insert (Var $i $k) $l
with insert (Var $i $ki) (Var $j $kj â¸¬ $l) â†ª
     case_Comp (compN $i $j)
            (Var $i ($ki q+ $kj) â¸¬ $l) // Eq
            (Var $i $ki â¸¬ Var $j $kj â¸¬ $l) // Lt
            (Var $j $kj â¸¬ insert (Var $i $ki) $l); // i > j

opaque symbol no_Add_insert xs y : Ï€(isNotAdd y) â†’ Ï€(no_Add xs) â†’ Ï€(no_Add(insert y xs)) â‰”
begin
induction
{ assume x h i; simplify; apply âˆ§áµ¢ { refine h } { apply âŠ¤áµ¢ } }
{ induction
  { assume k xs IH; induction
    { assume k' h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2} }
    { assume ki i h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢}
      {apply IH (Var ki i) {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}} }
    { assume x1 H1 x2 H2 h1 h2; apply âŠ¥â‚‘; refine h1}
  }
  { assume j kj xs IH; induction
    { assume k h1 h2; simplify; apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§áµ¢ {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}}}
    { assume i ki h1 h2; simplify;
      apply case_Comp_prop no_Add (Var i (ki q+ kj) â¸¬ xs) (Var i ki â¸¬ (Var j kj â¸¬ xs)) (Var j kj â¸¬ insert (Var i ki) xs) (compN i j)
         {refine h2}
         {simplify; apply âˆ§áµ¢ {refine âŠ¤áµ¢}{refine h2}}
         {simplify; apply âˆ§áµ¢{apply âŠ¤áµ¢}{apply IH (Var i ki) {apply âŠ¤áµ¢} {apply âˆ§â‚‘â‚‚ h2}}}
    }
    { assume x1 H1 x2 H2 h1 h2; apply âŠ¥â‚‘; refine h1}
  }
  { assume x1 H1 x2 H2 xs IH y h i; apply âŠ¥â‚‘; refine âˆ§â‚‘â‚ i}
}
end;

// // // to be moved to Nat
// // opaque symbol distr*+ x y z : Ï€(x * (y + z) = x * y + x * z) â‰”
// // begin
// // admitted;

symbol insert_correct l gs g : Ï€ (no_Add (g â¸¬ gs)) â†’ Ï€ (val (sum (insert g gs) â€š l) =  val (g â€š l) q+  val (sum gs â€š l)) â‰”
begin
assume l;
induction
{ reflexivity }
{
  // /assume g' gs IH g Haliens;
  induction
  {
    // Cst k
    assume k gs IH;
    induction
    // Cst k
    { assume k2 H; simplify; rewrite q+_assoc; reflexivity }
    // Var i j
    {
      assume i c H;
      simplify;
      have g: Ï€ (no_Add (Var i c â¸¬ gs)) { 
        apply âˆ§áµ¢
        { refine âˆ§â‚‘â‚ H; }
        { refine âˆ§â‚‘â‚‚ (âˆ§â‚‘â‚‚ H); }
       };
      rewrite IH (Var i c) g;
      rewrite left q+_assoc k (val (Var i c â€š l)) (val (sum gs â€š l));
      rewrite q+_com k;
      rewrite q+_assoc;
      reflexivity
    }
    // Case Add
    { assume g1 h2 g2 h4 contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ contradiction) }
  }
  {
    // Case Var i k
    assume i k gs IH;
    induction
    { assume c H; reflexivity }
    {
      assume j k2 Haliens;
      simplify insert;
      refine ind_Comp (Î» u, (compN j i) = u â‡’ val (sum (case_Comp u (Var j (k2 q+ k) â¸¬ gs) (Var j k2 â¸¬ (Var i k â¸¬ gs)) (Var i k â¸¬ insert (Var j k2) gs)) â€š l) = (val (Var j k2 â€š l) q+ val (sum (Var i k â¸¬ gs) â€š l))) _ _ _ (compN j i) _
      {
        assume Hi_eq_j;
        simplify case_Comp;
        rewrite compN_correct j i Hi_eq_j;
        simplify; rewrite distrq*q+; rewrite q+_assoc; reflexivity
      }
      {
        assume Hcomp;
        simplify case_Comp;
        reflexivity
      }
      {
        assume Hcomp;
        simplify case_Comp;
        simplify;
        type IH (Var j k2);
        have g: Ï€ (no_Add (Var j k2 â¸¬ gs)) {
          simplify;
          apply âˆ§áµ¢
          { refine âˆ§â‚‘â‚ Haliens }
          { refine âˆ§â‚‘â‚‚ (âˆ§â‚‘â‚‚ Haliens) }
        };
        rewrite IH (Var j k2) g;
        simplify;
        rewrite left q+_assoc (nth l i q* k) (nth l j q* k2) (val (sum gs â€š l));
        rewrite q+_com (nth l i q* k) (nth l j q* k2);
        rewrite q+_assoc;
        reflexivity
      }
      {reflexivity}
    }
    { assume g IH1 g' IH2 contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ contradiction) }
  }
  { assume g1  IH g2 IH2 gs H g contradiction; refine âŠ¥â‚‘ (âˆ§â‚‘â‚ (âˆ§â‚‘â‚‚ contradiction)); }
}
end;

// // // to be moved to List
symbol sort: Ï„(list grp) â†’ Ï„(list grp);
rule sort â–¡ â†ª â–¡
with sort ($x â¸¬ $xs) â†ª insert $x (sort $xs);

opaque symbol no_Add_sort xs : Ï€(no_Add xs) â†’ Ï€(no_Add (sort xs)) â‰”
begin
induction
{ assume h; apply âŠ¤áµ¢ }
{ assume x xs IH h; simplify; apply no_Add_insert (sort xs) x
  {refine âˆ§â‚‘â‚ h}
  {apply IH; refine âˆ§â‚‘â‚‚ h}
}
end;

opaque symbol sort_correct l gs : Ï€(no_Add gs) â†’ Ï€ (val (sum (sort gs) â€š l) =  val (sum gs â€š l)) â‰”
begin
assume l;
induction
{ assume h; reflexivity }
{ assume g gs IH h;
  have e: Ï€(val (sum (sort gs) â€š l) = val (sum gs â€š l))
    { apply IH; apply âˆ§â‚‘â‚‚ h };
  simplify; rewrite left e; apply insert_correct l (sort gs) g;
  simplify; apply âˆ§áµ¢ { apply âˆ§â‚‘â‚ h } { apply no_Add_sort gs; apply âˆ§â‚‘â‚‚ h }
}
end;

symbol norm x â‰” sum (remove0 (sort (aliens x)));

// to be moved to Nat
opaque symbol max_leq m n1 n2 :
  Ï€ (max n1 n2 Stdlib.Nat.â‰¤ m â‡’ n1 Stdlib.Nat.â‰¤ m âˆ§ n2 Stdlib.Nat.â‰¤ m) â‰”
begin
assume m n1 n2 h; apply âˆ§áµ¢
{ refine @leq_trans n1 (max n1 n2) m _ _ { apply leq_maxl n1 n2 } { refine h } }
{ refine @leq_trans n2 (max n1 n2) m _ _ { apply leq_maxr n1 n2 } { refine h } }
end;

// moved to Eq
opaque symbol eq_trans [a] (x y z:Ï„ a) : Ï€(x = y â‡’ y = z â‡’ x = z) â‰”
begin
assume a x y z xy yz; rewrite xy; refine yz
end;

opaque symbol sum++ l ys xs : Ï€(val(sum(xs ++ ys) â€š l) = val(sum xs â€š l) q+ val(sum ys â€š l)) â‰”
begin
assume l ys; induction
{ simplify; change Ï€ (val (sum ys â€š l) = (0â«½1 q+ val (sum ys â€š l))); rewrite q+_neutral_l; reflexivity }
{ assume x xs IH; simplify; rewrite IH; rewrite q+_assoc; reflexivity }
end;

opaque symbol aliens_correct l x : Ï€ (val (sum (aliens x) â€š l) = val (x â€š l)) â‰”
begin
assume l; induction
{assume k; simplify; change  Ï€ ((k q+ 0â«½1) = k); rewrite q+_neutral_r; reflexivity }
{assume i ki; simplify; change Ï€ (((nth l i q* ki) q+ 0â«½1) = (nth l i q* ki)); rewrite q+_neutral_r; reflexivity}
{assume x hx y hy; simplify; rewrite sum++; rewrite hx; rewrite hy; reflexivity}
end;

opaque symbol norm_correct (x: G) l :
  Ï€(varmax x Stdlib.Nat.â‰¤ size l) â†’ Ï€(val(norm x â€š l) = val(x â€š l)) â‰”
begin
assume x l h; simplify; apply eq_trans (val (sum (remove0 (sort (aliens x))) â€š l)) (val (sum (sort (aliens x)) â€š l)) (val (x â€š l))
{ apply remove0_correct l (sort(aliens x));
  apply no_Add_sort (aliens x); apply no_Add_aliens x }
{ apply eq_trans (val (sum (sort (aliens x)) â€š l)) (val (sum (aliens x) â€š l)) (val (x â€š l))
  { apply sort_correct l (aliens x); apply no_Add_aliens x }
  { apply aliens_correct l x}
}
end;

// move to Prod ?
symbol eta_prod [a b] (x:Ï„(a Ã— b)): Ï€(x = (x â‚) â€š (x â‚‚));

// to be moved to Comp
opaque symbol â‰_decides_neq [x y: Ï„ rat] : Ï€ ((x qâ‰ y) â‰  Eq â‡’ x â‰  y) â‰”
begin
admitted;

symbol l1 x y : Ï€((x q+ y) q- (x q+ y) â‰  1â«½1) â‰”
begin
  assume x y;
  refine â‰_decides_neq _;
  rewrite left .[z in z qâ‰ _] reify_correct;
  set e â‰” reify ((x q+ y) q- (x q+ y));
  rewrite .[z in val z] eta_prod;
  compute e;
  rewrite left norm_correct (e â‚) (e â‚‚) _ { refine âŠ¤áµ¢ } { refine Ltâ‰ Eq }
end;
