require open Stdlib.List Stdlib.propExt;
require open lambdapi.Rat;

inductive G: TYPE â‰”
| Cst: â„š â†’ G
| Var: â„• â†’ â„š â†’ G
;

symbol rec_G : Î  p0: (G â†’ Prop), (Î  x0: â„š, Ï€ (p0 (Cst x0))) â†’ (Î  x0: â„•, Î  x2: â„š, Ï€ (p0 (Var x0 x2))) â†’ Î  x: G, Ï€ (p0 x);

constant symbol grp : Set;
rule Ï„ grp â†ª G;

// multiplication by a constant

symbol mul: â„š â†’ ğ•ƒ grp â†’ ğ•ƒ grp;

rule mul $k ((Cst $l) â¸¬ $xs) â†ª mul ($k *áµ£ $l) $xs
with mul $k ((Var $i $l) â¸¬ $xs) â†ª Var $i ($k *áµ£ $l) â¸¬ (mul $k $xs)
with mul _ â–¡ â†ª â–¡;

// opposite

symbol opp â‰” mul (â€”áµ£ 1â«½1);


/* evaluation of an arithmetic expression wrt a list of values for variables
variables with indexes not in the list are raterpreted by 0 */

symbol nth â‰” nth (0â«½1);

symbol val_grp: Ï„ grp â†’  ğ•ƒ rat â†’ â„š;
rule val_grp (Cst $k) _ â†ª $k
with val_grp (Var $i $k) $l â†ª ((nth $l $i) *áµ£ $k)
;

symbol val: Ï„(list grp Ã— list rat) â†’ â„š;

rule val (â–¡ â€š _) â†ª 0â«½1
with val (($x â¸¬ $xs) â€š $l) â†ª (val_grp $x $l) áµ£+ (val ($xs â€š $l));

symbol va l x â‰” val (x â€š l);

// some useful type (use inductive instead?)

constant symbol R : TYPE;
constant symbol Index : â„• â†’ R;
constant symbol New : â„• â†’ R;

symbol case [a] : R â†’ (â„• â†’ Ï„ a) â†’ (â„• â†’ Ï„ a) â†’ Ï„ a;

rule case (Index $i) $f _ â†ª $f $i
with case (New $i) _ $g â†ª $g $i;

/* index of a value in a list: returns New if the value is not
definitionally equivalent to some element of the list */

sequential symbol index: â„• â†’ Î  [a], Ï„ a â†’ Ï„(list a) â†’ R;

rule index $k _ â–¡ â†ª New $k
with index $k $x ($x â¸¬ _) â†ª Index $k
with index $k $x ($y â¸¬ $l) â†ª index ($k Stdlib.Nat.+ Stdlib.Nat._1) $x $l;

/* reification: given a Lambdapi term x of type â„š, compute an
expression in G and a list of values whose evaluation is equal to
x. WARNING: rfy is sequential. */

sequential symbol rfy: Ï„(list rat) â†’ â„š â†’ Ï„(list grp Ã— list rat);

// addition
rule rfy $l ($x áµ£+ $y) â†ª
  let x â‰” rfy $l $x in let y â‰” rfy (x â‚‚) $y in ((x â‚) ++ (y â‚)) â€š (y â‚‚)

// opposite
with rfy $l (â€”áµ£ $x) â†ª let x â‰” rfy $l $x in opp (x â‚) â€š (x â‚‚)

// substraction
with rfy $l ($x áµ£- $y) â†ª rfy $l ($x áµ£+ â€”áµ£ $y)

// constants
with rfy $l 0 â†ª (Cst 0 â¸¬ â–¡) â€š $l
with rfy $l ((Zpos $n) / (Zpos $d)) â†ª (Cst ((Zpos $n) / (Zpos $d)) â¸¬ â–¡) â€š $l
with rfy $l ((Zneg $n) / (Zpos $d)) â†ª (Cst ((Zneg $n) / (Zpos $d)) â¸¬ â–¡) â€š $l
with rfy $l (0 / _) â†ª (Cst (0 / 1) â¸¬ â–¡) â€š $l

// multiplication by a constant
with rfy $l ((Zpos $n / Zpos $d) *áµ£ $x) â†ª let x â‰” rfy $l $x in (mul (Zpos $n / Zpos $d) (x â‚)) â€š (x â‚‚)
with rfy $l ((Zneg $n / Zpos $d) *áµ£ $x) â†ª let x â‰” rfy $l $x in (mul (Zneg $n / Zpos $d) (x â‚)) â€š (x â‚‚)
with rfy $l ($x *áµ£ ((Zpos $n) / (Zpos $d))) â†ª let x â‰” rfy $l $x in (mul (((Zpos $n) / (Zpos $d))) (x â‚)) â€š (x â‚‚)
with rfy $l ($x *áµ£ ((Zneg $n) / (Zpos $d))) â†ª let x â‰” rfy $l $x in (mul (((Zneg $n) / (Zpos $d))) (x â‚)) â€š (x â‚‚)

//other cases are abstracted by a variable
with rfy $l $x â†ª
  case (index _0 $x $l) (Î» i, (Var i (1â«½1) â¸¬ â–¡) â€š $l) (Î» i, (Var i (1â«½1) â¸¬ â–¡) â€š ($l ++ ($x â¸¬ â–¡)))
;

symbol reify â‰” rfy â–¡;

symbol compN : â„• â†’ â„• â†’ Comp;

rule compN _0 _0 â†ª Eq
with compN _0 (_ +1) â†ª Lt
with compN (_ +1) _0 â†ª Gt
with compN ($x +1) ($y +1) â†ª compN $x $y;

symbol compG : G â†’ G â†’ Comp;
rule compG (Var $i $k) (Var $j $k2) â†ª compN $i $j
with compG (Var _ _) (Cst _) â†ª Gt
with compG (Cst _) (Var _ _)  â†ª Lt
with compG (Cst $c1) (Cst $c2)  â†ª $c1 áµ£â‰ $c2;


symbol split [a: Set] (l : Ï„ (list a)): Ï„(list a Ã— list a);
rule split â–¡ â†ª (â–¡ â€š â–¡)
with split ($x â¸¬ â–¡) â†ª (($x â¸¬ â–¡) â€š â–¡)
with split ($x â¸¬ $y â¸¬ $l) â†ª  
    let res â‰”  (split $l) in
        ($x â¸¬ (res â‚)) â€š ($y â¸¬ (res â‚‚));


symbol list_ind2_principle [A : Set]  :
  Î  (P : Ï„ (list A) â†’ Prop),
    Ï€ (P â–¡) â†’
    (Î  (a: Ï„ A), Ï€ (P (a â¸¬ â–¡))) â†’
    (Î  (a b : Ï„ A) (l : Ï„ (list A)), Ï€ (P l) â†’  Ï€ (P (a â¸¬ b â¸¬ l))) â†’
    Î  (l : Ï„ (list A)), Ï€ (P l);

opaque symbol ++_eq_+ l x y : Ï€ (val ((x ++ y) â€š l) =  val (x â€š l) áµ£+ val (y â€š l)) â‰”
begin
assume l;
induction
{
  assume y;
  simplify;
  change Ï€ (val (y â€š l) = (frac 0 1 áµ£+ val (y â€š l)));
  rewrite áµ£+_neutral_frac_l;
  reflexivity
}
{
  assume x xs ih;
  simplify;
  assume y;
  rewrite ih y;
  rewrite áµ£+_assoc;
  reflexivity
}
end;

opaque symbol split_correct l gs : Ï€ (val (((split gs â‚) ++ (split gs â‚‚)) â€š l) = val (gs â€š l)) â‰”
begin
assume l;
refine list_ind2_principle (Î» u, (val (((split u â‚) ++ (split u â‚‚)) â€š l) = val (u â€š l))) _ _ _
{reflexivity}
{reflexivity}
{
  assume a b tl ih;
  simplify;
  rewrite left ih;
  rewrite ++_eq_+;
  rewrite ++_eq_+;
  simplify;
  rewrite left .[in x in (_ áµ£+ x ) = _] áµ£+_assoc;
  rewrite  .[in x in (_ áµ£+ (x áµ£+ _) ) = _] áµ£+_com;
  rewrite .[in x in (_ áµ£+ x ) = _] áµ£+_assoc;
  reflexivity
}
end;

symbol merge  (l1 l2 : Ï„ (list grp)): Ï„ (list grp);
rule merge â–¡ â–¡ â†ª â–¡
with merge â–¡ $l2 â†ª $l2
with merge $l1 â–¡ â†ª $l1
with merge (Cst $c1 â¸¬ $l1') (Cst $c2 â¸¬ $l2') â†ª (Cst ($c1 áµ£+ $c2) â¸¬ merge $l1' $l2')
with merge (Cst $c â¸¬ $l1') (Var $i $k â¸¬ $l2') â†ª (Cst $c â¸¬ merge $l1' (Var $i $k â¸¬ $l2'))
with merge (Var $i $k â¸¬ $l1') (Cst $c â¸¬ $l2') â†ª (Cst $c â¸¬ merge (Var $i $k â¸¬ $l1') $l2')
with merge ((Var $i $k1) â¸¬ $l1') ((Var $j $k2) â¸¬ $l2') â†ª
    case_Comp (compN $i $j)
        (Var $i ($k1 áµ£+ $k2) â¸¬ merge $l1' $l2')
        ((Var $i $k1) â¸¬ merge $l1' (Var $j $k2 â¸¬ $l2'))
        ((Var $j $k2) â¸¬ merge (Var $i $k1 â¸¬ $l1') $l2')
;

opaque symbol compN_correct x y : Ï€ (compN x y = Eq â‡’ x = y) â‰”
begin
induction
{ induction
  {assume h; reflexivity}
  {assume y hy h; apply âŠ¥â‚‘; apply Ltâ‰ Eq h}
}
{ assume x hx; induction
  {assume h; apply âŠ¥â‚‘; apply Gtâ‰ Eq h}
  {assume y hy h; apply feq (+1); apply hx y h }
}
end;

opaque symbol merge_correct l g1 g2 : Ï€ (val ((merge  g1 g2) â€š l ) = val (g1 â€š l) áµ£+ val (g2 â€š l)) â‰”
begin
    assume l;
    induction
    { simplify; assume x; change Ï€ (val (x â€š l) = (frac 0 1 áµ£+ val (x â€š l))); rewrite áµ£+_neutral_frac_l;  reflexivity }
    {
      induction
      {
        assume k1 xs ih1;
        induction
        {
          simplify;
          //change Ï€ ((k1 áµ£+ val (xs â€š l)) = ((k1 áµ£+ val (xs â€š l)) áµ£+ frac 0 1));
          change Ï€ ((k1 áµ£+ val (xs â€š l)) = ((k1 áµ£+ val (xs â€š l)) áµ£+ (0 / _1)));
          rewrite áµ£+_neutral_div_r (k1 áµ£+ val (xs â€š l));
          reflexivity
        }
        {
          induction
          {
            assume k2 ys ih2;
            simplify; rewrite ih1;
            rewrite áµ£+_assoc;
            rewrite  left .[x in _ áµ£+ x = _] áµ£+_assoc;
            rewrite áµ£+_com k2;
            rewrite  .[x in _ áµ£+ x = _] áµ£+_assoc;
            rewrite left áµ£+_assoc;
            reflexivity
          }
          {
            assume i k2 ys ih2;
            simplify; rewrite ih1;
            simplify;
            rewrite left áµ£+_assoc;
            reflexivity
          }
        }
      }
      {
        assume i k1 xs ih1;
        induction
        {
          simplify val;
          simplify 0â«½1;
          rewrite áµ£+_neutral_div_r;
          reflexivity          
        }
        {
          induction
          {
            assume K ys ih2;
            simplify;
            rewrite ih2;
            simplify;
            rewrite áµ£+_com;
            rewrite áµ£+_assoc;
            rewrite áµ£+_com K;
            reflexivity
          }
          {
            assume j k2 ys ih2;
            simplify;
            refine ind_Comp (Î» u, (compN i j) = u â‡’ val (case_Comp (compN i j) (Var i (k1 áµ£+ k2) â¸¬ merge xs ys) (Var i k1 â¸¬ merge xs (Var j k2 â¸¬ ys)) (Var j k2 â¸¬ merge (Var i k1 â¸¬ xs) ys) â€š l) = (((nth l i *áµ£ k1) áµ£+ val (xs â€š l)) áµ£+ ((nth l j *áµ£ k2) áµ£+ val (ys â€š l)))) _ _ _ (compN i j) _
            {
              simplify;
              assume heq;
              rewrite heq;
              simplify;
              rewrite compN_correct i j heq;
              rewrite distr*áµ£áµ£+;
              rewrite ih1;
              rewrite áµ£+_assoc;              
              set XS â‰” val (xs â€š l);
              set YS â‰” val (ys â€š l);
              rewrite  left .[x in _ áµ£+ x = _] áµ£+_assoc;
              rewrite .[x in _ áµ£+ (x áµ£+ _) = _] áµ£+_com; 
              rewrite .[x in _ áµ£+ x = _] áµ£+_assoc;
              rewrite left .[x in x = _] áµ£+_assoc;
              reflexivity
            }
            {
              simplify;
              assume hlt;
              rewrite hlt;
              simplify;
              rewrite ih1;
              simplify;
              rewrite áµ£+_assoc;
              rewrite left áµ£+_assoc;
              reflexivity
            }
            {
              assume hgt;
              rewrite hgt;
              simplify;
              rewrite ih2;
              simplify;
              rewrite áµ£+_com;
              rewrite áµ£+_assoc;
              rewrite áµ£+_com (val (ys â€š l));
              reflexivity
            }
            {reflexivity}
          }
        }
      }  
  }
end;


symbol mergesort:  Ï„ (list grp) â†’  Ï„ (list grp);
rule mergesort â–¡ â†ª â–¡
with mergesort ($x â¸¬ â–¡) â†ª ($x â¸¬ â–¡)
with mergesort ($x â¸¬ $y â¸¬ $l) â†ª 
    let s â‰” split ($x â¸¬ $y â¸¬ $l) in
    let l1 â‰” s â‚ in
    let l2 â‰” s â‚‚ in
        merge (mergesort l1) (mergesort l2);      

opaque symbol rec_ğ•ƒ : Î  [a: Set], Î  l: ğ•ƒ a, Î  p: (ğ•ƒ a â†’ Prop), Ï€ (p â–¡) â†’ (Î  x0: Ï„ a, Î  l': ğ•ƒ a, Ï€ (p (x0 â¸¬ l'))) â†’ Ï€ (p l) â‰” 
begin
  assume a l P H1 H2;
  refine @ind_ğ•ƒ a P H1 (Î» x l' ih, H2 x l') l
end;

opaque symbol case_l [a] x (l: ğ•ƒ a) n : Ï€ ((size (x â¸¬ l)) Stdlib.Nat.â‰¤ (n +1)) â†’ Ï€ (size l Stdlib.Nat.â‰¤ n) â‰”
begin
  assume a x l n;
  refine Î» x, x;
end;

opaque symbol size_split [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚) Stdlib.Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚) Stdlib.Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol size_split2 [a] (l: ğ•ƒ a) : Ï€ (size ((split l) â‚‚) Stdlib.Nat.â‰¤ size l) â‰”
begin
  assume a;
  refine list_ind2_principle (Î» u, istrue (size (split u â‚‚) Stdlib.Nat.â‰¤ size u)) _ _ _
  {apply âŠ¤áµ¢}
  {assume y; apply âŠ¤áµ¢}
  {
    simplify;
    assume x y l ih;
    apply @leq_trans (size (split l â‚‚)) (size l) (size l +1) ih _;
    refine leqnSn (size l)
  }
end;

opaque symbol mergesort_correct_aux n l g : Ï€ (size g Stdlib.Nat.â‰¤ n)  â†’  Ï€ (val ((mergesort g) â€š l ) = val ( g â€š l)) â‰”
begin
    induction
    {
        assume l;
        assume g h;
        type â‰¤0 (size g) h;
        rewrite size0nil g (â‰¤0 (size g) h);
        reflexivity
    }
    {
      assume n ihn l g;
      refine rec_ğ•ƒ g (Î» u, (size u Stdlib.Nat.â‰¤ (n +1)) â‡’ ((val ( (mergesort u) â€š l) = val ( u â€š l)))) _ _
      {
        simplify;
        reflexivity
      }
      {
        assume x g';
        refine rec_ğ•ƒ g' (Î» u, (size (x â¸¬ u) Stdlib.Nat.â‰¤ (n +1)) â‡’ ((val ( (mergesort (x â¸¬ u)) â€š l) = val ( (x â¸¬ u) â€š l)))) _ _
        {reflexivity}
        {
          assume y g'' inv1;
          simplify;
          rewrite (merge_correct l (mergesort (x â¸¬ ((split g'') â‚))) (mergesort (y â¸¬ ((split g'') â‚‚))));
          have tmp3x: Ï€ (istrue (size (x â¸¬ (split g'' â‚)) Stdlib.Nat.â‰¤ n)) {
            apply @leq_trans
            (size (split g'' â‚) +1)
            (size g'' +1)
            n
            _
            inv1;
            apply size_split g''
          };
          rewrite ihn l (x â¸¬ (split g'' â‚)) tmp3x;
          have tmp3y: Ï€ (istrue (size (y â¸¬ (split g'' â‚‚)) Stdlib.Nat.â‰¤ n)) {
            simplify;
            apply @leq_trans
            (size (split g'' â‚‚) +1)
            (size g'' +1)
            n
            _
            inv1;
            simplify;
            apply size_split2 g''
          };
          rewrite ihn l (y â¸¬ (split g'' â‚‚)) tmp3y;
          simplify;
          rewrite áµ£+_assoc;
          rewrite left .[x in (_ áµ£+ x) = _] áµ£+_assoc;
          rewrite áµ£+_com  (val ((split g'' â‚) â€š l)) (val_grp y l);
          rewrite  áµ£+_assoc;
          rewrite left ++_eq_+ l (split g'' â‚) (split g'' â‚‚);
          rewrite split_correct;
          reflexivity
        }
      }
    }
end;

symbol mergesort_correct l g â‰” mergesort_correct_aux (size g) l g (Stdlib.Nat.â‰¤_refl (size g));


symbol remove0 : Ï„(list grp) â†’ Ï„(list grp);

rule remove0 â–¡ â†ª â–¡
with remove0 (Cst (0 / _) â¸¬ $l) â†ª remove0 $l
with remove0 (Cst (Zpos H / Zpos $d) â¸¬ $l) â†ª Cst (Zpos H / Zpos $d) â¸¬ remove0 $l
with remove0 (Cst (Zpos $n / Zpos $d) â¸¬ $l) â†ª Cst (Zpos $n / Zpos $d) â¸¬ remove0 $l
with remove0 (Cst (Zneg $n / Zpos $d) â¸¬ $l) â†ª Cst (Zneg $n / Zpos $d) â¸¬ remove0 $l
with remove0 (Var _ (0 / _) â¸¬ $l) â†ª remove0 $l
with remove0 (Var $i (Zpos H / Zpos $d) â¸¬ $l) â†ª Var $i (Zpos H / Zpos $d) â¸¬ remove0 $l
with remove0 (Var $i (Zpos $n / Zpos $d) â¸¬ $l) â†ª Var $i (Zpos $n / Zpos $d) â¸¬ remove0 $l
with remove0 (Var $i (Zneg $n / Zpos $d) â¸¬ $l) â†ª Var $i (Zneg $n / Zpos $d) â¸¬ remove0 $l
;


opaque symbol remove0_correct l gs : Ï€ (val ((remove0 gs) â€š l) = val (gs â€š l)) â‰”
begin
  assume l;
  induction // on l
  {
    simplify;
    reflexivity
  }
  {
    induction // on g
    {
      // // Case Cst k
      // induction 
      // // Case Z0
      // { assume  gs ih;  simplify; apply ih }
      // // Case Zpos
      // { assume c gs ih; simplify; rewrite ih; reflexivity }
      // // Case Zneg
      // { assume c gs ih; simplify;  rewrite ih; reflexivity }
    }
    {
      // Case Var i k
      // assume i;
      // induction // on k
      // {assume gs ih; simplify; rewrite ih; reflexivity} // Case Z0
      // { assume c gs ih; simplify; rewrite ih; reflexivity } // Case Zpos
      // { assume c gs ih; simplify; rewrite ih; reflexivity } // Case Zneg
    }
  }
admitted;

//compute mergesort ((Var Nat._3 2) â¸¬ (Var Nat._2 2) â¸¬ (Var Nat._1 2) â¸¬ Cst 10 â¸¬ â–¡);

symbol norm_speed x â‰” (remove0 (mergesort x));

symbol varmax : ğ•ƒ grp â†’ â„•;

rule varmax ((Cst _) â¸¬ $xs) â†ª (varmax $xs)
with varmax ((Var $k _) â¸¬ $xs) â†ª max $k (varmax $xs)
with varmax â–¡ â†ª _0;

opaque symbol eq_trans [a] (x y z:Ï„ a) : Ï€(x = y â‡’ y = z â‡’ x = z) â‰”
begin
assume a x y z xy yz; rewrite xy; refine yz
end;

opaque symbol norm_correct (x: ğ•ƒ grp) l : Ï€(val((norm_speed x) â€š l) = val(x â€š l)) â‰”
begin
  assume x l; simplify; apply eq_trans (val (remove0 (mergesort x) â€š l)) (val (mergesort x â€š l)) (val (x â€š l))
  { apply remove0_correct l (mergesort x) }
  {
    apply eq_trans (val ((mergesort (x)) â€š l)) (val (( x) â€š l)) (val (x â€š l))
    {apply mergesort_correct l x}
    {reflexivity}
  }
end;

symbol â‰_decides_neq [x y] : Ï€ ((x áµ£â‰ y) â‰  Eq â‡’ x â‰  y) â‰”
begin
admit
end;

symbol eta_prod [a b] (x:Ï„(a Ã— b)): Ï€(x = (x â‚) â€š (x â‚‚));

opaque symbol reify_correct x: Ï€(val(reify x) = x) â‰”
begin
refine ind_Rat (Î» u, (val (reify u) = u)) _;
induction
{assume y; simplify; rewrite div_0_num (sign y * sign y); reflexivity }
{assume p y; simplify reify; simplify rfy;
  change Ï€ (val (case (index Stdlib.Nat._0 (frac (Zpos p) y) â–¡) (Î» i, (Var i (1 / 1) â¸¬ â–¡) â€š â–¡) (Î» i, (Var i (1 /1 ) â¸¬ â–¡) â€š ((frac (Zpos p) y) â¸¬ â–¡))) = frac (Zpos p) y);
  simplify val; simplify val_grp; simplify nth;  simplify val; 
  simplify 0â«½1;
  rewrite áµ£+_neutral_div_r;
  rewrite áµ£*_neutral_div_r;
  reflexivity
}
{
  assume p y; simplify reify; simplify rfy;
  change Ï€ (val (case (index Stdlib.Nat._0 (frac (Zneg p) y) â–¡) (Î» i, (Var i (1 / 1) â¸¬ â–¡) â€š â–¡) (Î» i, (Var i (1 /1 ) â¸¬ â–¡) â€š ((frac (Zneg p) y) â¸¬ â–¡))) = frac (Zneg p) y);
  simplify val; simplify val_grp; simplify nth;  simplify val; 
  simplify 0â«½1;
  rewrite áµ£+_neutral_div_r;
  rewrite áµ£*_neutral_div_r;
  reflexivity
}
end;


symbol l1 x y : Ï€(((2 *áµ£ x) áµ£+ y) áµ£- ((2 *áµ£ x) áµ£+ y) â‰  (1 /1 )) â‰”
begin
  assume x y;
  refine â‰_decides_neq _;
  rewrite left .[z in z áµ£â‰ _] reify_correct;
  set e â‰” reify (((2 *áµ£ x) áµ£+ y) áµ£- ((2 *áµ£ x) áµ£+ y));
  compute e;
  rewrite .[z in val z] eta_prod;
  rewrite left norm_correct (e â‚) (e â‚‚);
  simplify;
  refine Ltâ‰ Eq
end;