/**********
The standard library use this rewrites rules in Z and Pos that has been prove confluent.

(VAR
  a: Z
  b: Z
  x : P
  q : P
  y : P
)
(THEORY (AC addG))
(RULES
  â€”(Z0) -> Z0
  â€”(Zpos(p)) -> Zneg(p)
  â€”(Zneg(p)) -> Zpos(p)
  â€”(â€”(a)) -> a

  double(Z0) -> Z0
  double(Zpos(p)) -> Zpos(O(p))
  double(Zneg(p)) -> Zneg(O(p))
  
  succ_double(Z0) -> Zpos(H)
  succ_double(Zpos(p)) -> Zpos(I(p))
  succ_double(Zneg(p)) -> Zneg(pos_pred_double(p))
  
  pred_double(Z0) -> Zneg(H)
  pred_double(Zpos(p)) -> Zpos(pos_pred_double(p))
  pred_double(Zneg(p)) -> Zneg(I(p))

  sub(I(p), I(q)) -> double(sub(p, q))
  sub(I(p), O(q)) -> succ_double(sub(p, q))
  sub(I(p), H) -> Zpos(O(p))
  sub(O(p), I(q)) -> pred_double(sub(p, q))
  sub(O(p), O(q)) -> double(sub(p, q))
  sub(O(p), H) -> Zpos(pos_pred_double(p))
  sub(H, I(q)) -> Zneg(O(q))
  sub(H, O(q)) -> Zneg(pos_pred_double(q))
  sub(H, H) -> Z0

  +(Z0,a) -> a
  +(a,Z0) -> a
  +(Zpos(x), Zpos(y)) -> Zpos(add(x, y))
  +(Zpos(x), Zneg(y)) -> sub(x, y)
  +(Zneg(x), Zpos(y)) -> sub(y, x)
  +(Zneg(x), Zneg(y)) -> Zneg(add(x, y))
  
  mult(Z0, a) -> Z0
  mult(a, Z0) -> Z0
  mult(Zpos(x), Zpos(y)) -> Zpos(mul(x, y))
  mult(Zpos(x), Zneg(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zpos(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zneg(y)) -> Zpos(mul(x, y))


  succ(I(x)) -> O(succ(x))
  succ(O(x)) -> I(x)
  succ(H) -> O(H)
  add(I(x), I(q)) -> O(addcarry(x, q))
  add(I(x), O(q)) -> I(add(x, q))
  add(O(x), I(q)) -> I(add(x, q))
  add(O(x), O(q)) -> O(add(x, q))
  add(x, H) -> succ(x)
  add(H, y) -> succ(y)

  addcarry(I(x), I(q)) -> I(addcarry(x, q))
  addcarry(I(x), O(q)) -> O(addcarry(x, q))
  addcarry(O(x), I(q)) -> O(addcarry(x, q))
  addcarry(O(x), O(q)) -> I(add(x, q))
  addcarry(x, H) -> add(x, O(H))
  addcarry(H, y) -> add(O(H), y)
  
  pos_pred_double(I(x)) -> I(O(x))
  pos_pred_double(O(x)) -> I(pos_pred_double(x))
  pos_pred_double(H) -> H
  
  mul(I(x), y) -> add(x, O(mul(x,y)))
  mul(O(x), y) -> O(mul(x, y))
  mul(H, y) -> y

  add(var(k,x), var(l,x)) -> var(+(k,l), x)
  add(var(k,x), add(var(l,x),y)) -> add(var(+(k,l),x), y)
  add(cst(k), cst(l)) -> cst(+(k,l))
  add(cst(k), add(cst(l), y)) -> add(cst(+(k,l)), y)
  add(cst(Z0), x) -> x
  add(x, cst(Z0)) -> x
)
***********/

require open Stdlib.Pos Stdlib.Nat Stdlib.Z Stdlib.Set Stdlib.Prop Stdlib.Eq Stdlib.Bool Stdlib.Comp Stdlib.List;
require open lambdapi.Classic;
require open lambdapi.Alethe;
require open lambdapi.Ring;

notation â‰¥ infix 10;

constant symbol R : TYPE;
constant symbol ring: Set;
rule Ï„ ring â†ª R;

constant symbol cst: â„¤ â†’ R;

symbol var : â„¤ â†’ â„¤ â†’ R;
/* semantics: [var k x] = k * x
note that the second argument could be any type that has a ring structure
(we then would take R : TYPE â†’ TYPE) */
symbol opp:R â†’ R;
symbol add:R â†’ R â†’ R;
symbol mul: â„¤ â†’ R â†’ R;

symbol R_ind: Î  p: (R â†’ Prop), 
  (Î  x0: â„¤, Ï€á¶œ ( p (cst x0))) â†’
  (Î  x0: R, Ï€á¶œ ( p (opp x0))) â†’
  (Î  x0: â„¤, Î  y0: â„¤, Ï€á¶œ (p (var x0 y0))) â†’
  (Î  x0: R, Î  y0: R, Ï€á¶œ (p (add x0 y0))) â†’
  (Î  x0: â„¤, Î  y0: R, Ï€á¶œ (p (mul x0 y0))) â†’
  Ï€á¶œ (`âˆ€á¶œ x: R, p x);

rule var _ 0 â†ª cst 0;

rule opp (var $k $x) â†ª var (â€” $k) $x 
with opp (cst $k) â†ª cst (â€” $k)
with opp (opp $x) â†ª $x
with opp (add $x $y) â†ª add (opp $x) (opp $y)
// // // note that opp is totally defined on terms built with var, cst, opp and add, i.e. no normal form contains opp
with add (var $k $x) (var $c $x) â†ª var ($k + $c) $x
with add (var $k $x) (add (var $l $x) $y) â†ª add (var ($k + $l) $x) $y
with add (cst $k) (cst $l) â†ª cst ($k + $l)
with add (cst $k) (add (cst $l) $y) â†ª add (cst ($k + $l)) $y
with add (cst 0) $x â†ª $x
with add $x (cst 0) â†ª $x

//multiplication by a constant (optional)

with mul $k (var $c $x) â†ª var ($k * $c) $x
with mul $k (opp $r) â†ª mul (â€” $k) $r
with mul $k (add $r $s) â†ª add (mul $k $r) (mul $k $s)
with mul $k (cst $z) â†ª cst ($k * $z)
with mul $k (mul $l $z) â†ª mul ($k * $l) $z;
// // note that mul is totally defined on terms built from var, cst, opp, add and mul, i.e. no normal form contains mul

// // reification
// // WARNING: this symbol is declared as sequential
// // and the reduction relation is not stable by substitution
sequential symbol reify : â„¤ â†’ R;
rule reify 0 â†ª cst 0
with reify (Zpos $x) â†ª cst (Zpos $x)
with reify (Zneg $x) â†ª cst (Zneg $x)
with reify (â€” $x) â†ª opp (reify $x)
with reify ($x + $y) â†ª add (reify $x) (reify $y)

with reify (0 * $y) â†ª mul 0 (reify $y)
with reify (Zpos $x * $y) â†ª mul (Zpos $x) (reify $y)
with reify (Zneg $x * $y) â†ª mul (Zneg $x) (reify $y)
with reify ($y * 0) â†ª mul 0 (reify $y)
with reify ($y * Zpos $x) â†ª mul (Zpos $x) (reify $y)
with reify ($y * Zneg $x) â†ª mul (Zneg $x) (reify $y)

with reify $x â†ª var 1 $x; // must be the last rule for reify

print eq_refl;

// eval function
symbol denote: R â†’ â„¤;
rule denote (var $k $i) â†ª $k * $i
with denote (cst $k) â†ª $k
with denote (opp $x) â†ª â€” (denote $x)
with denote (add $x $y) â†ª (denote $x) + (denote $y)
;

// Lemma Zle_not_gt n m : n <= m -> â€” n > m.
symbol Zle_not_gt n m:  Ï€á¶œ ((n â‰¤ m) = Â¬ (n > m));

symbol Zlt_not_ge n m:  Ï€á¶œ ((n < m) = Â¬ (n â‰¥ m));

symbol Zge_not_lt : Î  n: â„¤, Î  m: â„¤, Ï€á¶œ ((n â‰¥ m) = Â¬ (n < m));

symbol Zgt_not_le : Î  n: â„¤, Î  m: â„¤, Ï€á¶œ ((n > m) = Â¬ (n â‰¤ m));

// Lemma Zmult_gt_compat_r n m p : p > 0 -> n > m -> n * p > m * p.
symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c * a > c * b) ;

// Lemma Zmult_ge_compat_r n m p : n >= m -> p >= 0 -> n * p >= m * p.
symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c * a â‰¥ c * b);

symbol Zgt_le_succ_r a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a â‰¥ b + 1);

symbol Zinv_lt a b: Ï€á¶œ (a < b) â†’ Ï€á¶œ (â€” a > â€” b);

symbol Zsum_geq_s a b c d : Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (c â‰¥ d) â†’ Ï€á¶œ (a + c â‰¥ b + d);

symbol Z_diff_geq_Z0 a b: Ï€á¶œ (a â‰¥ b) â†’ Ï€á¶œ (a - b â‰¥ 0);
symbol Z_diff_gt_Z0 a b: Ï€á¶œ (a > b) â†’ Ï€á¶œ (a - b > 0);



symbol ind_â„¤á¶œ' x : Î  p0: (â„¤ â†’ Prop), Ï€á¶œ (p0 0) â†’ (Î  x0: â„™, Ï€á¶œ (p0 (Zpos x0))) â†’ (Î  x0: â„™, Ï€á¶œ (p0 (Zneg x0))) â†’ Ï€á¶œ (p0 x);

opaque symbol neutral_H_* a : Ï€á¶œ (Zpos H * a = a) â‰”
begin
assume a;
apply ind_â„¤á¶œ' a (Î» u, Zpos H * u = u)
{ reflexivity }
{ reflexivity }
{ reflexivity }
end;

symbol ind_ð”¹á¶œ x : Î  p0: (ð”¹ â†’ Prop), Ï€á¶œ (p0 true) â†’ Ï€á¶œ (p0 false) â†’ Ï€á¶œ (p0 x);

opaque symbol âˆ¨_istrueá¶œ [p q] : Ï€á¶œ (istrue (p Stdlib.Bool.or q)) â†’ Ï€á¶œ (istrue p âˆ¨á¶œ istrue q) â‰”
begin
admit
end;

symbol ind_Compá¶œ x : Î  p0: (Comp â†’ Prop), Ï€á¶œ (p0 Eq) â†’ Ï€á¶œ (p0 Lt) â†’ Ï€á¶œ (p0 Gt) â†’ Ï€á¶œ (p0 x);

symbol Zgt_le_succ_r_eq a b: Ï€á¶œ ((a > b) = (a â‰¥ b + 1));

symbol Zinv_lt_eq a b: Ï€á¶œ ((a < b) = (â€” a > â€” b));

symbol Zinv_le_eq a b: Ï€á¶œ ((a â‰¤ b) = (â€” a â‰¥ â€” b));

symbol Z_diff_geq_Z0_eq a b: Ï€á¶œ ((a â‰¥ b) = (a - b â‰¥ 0));

symbol Z_diff_gt_Z0_eq a b: Ï€á¶œ ((a > b) = (a - b > 0));

symbol Z_diff_eq_Z0_eq a b: Ï€á¶œ ((a = b) = (a - b = 0));

//Axioms
symbol Z_eq_antisym (a b: Ï„ int):  Ï€á¶œ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));

symbol Z_eq_implies_ge [a b: Ï„ int]:  Ï€á¶œ (a = b) â†’  Ï€á¶œ (a â‰¥ b);

symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€á¶œ ((Â¬ (a = b)) = Â¬ (c * a = c * b));
symbol Zmult_gt_compat_eq c a b : Ï€á¶œ (Â¬ (a > b) = Â¬ (c * a > c * b)) ;
symbol Zmult_ge_compat_eq c a b : Ï€á¶œ (Â¬ (a â‰¥ b) = Â¬ (c * a â‰¥ c * b)) ;

symbol la_mult_neg_eq [t1 t2 t3] : Ï€á¶œ ((t1 < 0) â‡’á¶œ (t2 = t3) â‡’á¶œ (t1 * t2) = (t1 * t3)) â‰”
begin
  assume t1 t2 t3; apply â‡’á¶œáµ¢; assume H; apply â‡’á¶œáµ¢; assume H2; rewrite H2; reflexivity
end;

//FIXME: give proof
symbol la_mult_neg_lt t1 t2 t3 : Ï€á¶œ (t1 < 0) â†’ Ï€á¶œ (t2 < t3) â†’ Ï€á¶œ ((t1 * t2) > (t1 * t3));
symbol la_mult_neg_leq [t1 t2 t3] : Ï€á¶œ ((t1 < 0) â‡’á¶œ (t2 â‰¤ t3) â‡’á¶œ (t1 * t2) â‰¥ (t1 * t3));

symbol ind_â„¤á¶œ : Î  p0: (â„¤ â†’ Prop), Ï€á¶œ (p0 0) â†’ (Î  x0: â„™, Ï€á¶œ (p0 (Zpos x0))) â†’ (Î  x0: â„™, Ï€á¶œ (p0 (Zneg x0))) â†’ Ï€á¶œ (`âˆ€á¶œ x, p0 x);

opaque symbol inj2 : Ï€á¶œ (`âˆ€á¶œ x, (denote (reify x)) = x) â‰” begin
apply ind_â„¤á¶œ (Î» u,  (denote (reify u)) = u)
{reflexivity}
{reflexivity}
{reflexivity}
end;

symbol inj: Î  x: â„¤, Ï€á¶œ ((denote (reify  x)) = x);

sequential symbol =R: R â†’ R â†’ Ï„ bool; notation =R infix 10;
rule (var $x $c1) =R (var $x $c2) â†ª isEq ($c1 â‰ $c2)
with (var $x $c1) =R (var $y $c2) â†ª false
with (var $x $c1) =R add _ _ â†ª false
with (var $x $c1) =R mul _ _ â†ª false
with (var $x $c1) =R cst _ â†ª false
with (var $x $c1) =R opp _ â†ª false
with add $x1 $y1 =R add $x2 $y2 â†ª ($x1 =R $x2) Stdlib.Bool.and ($y1 =R $y2)
with add _ _ =R mul _ _ â†ª false
with add _ _ =R cst _ â†ª false
with add _ _ =R var _ _ â†ª false
with add _ _ =R opp _ â†ª false
with (mul $x1 $y1) =R (mul $x2 $y2) â†ª (isEq ($x1 â‰ $x2)) Stdlib.Bool.and ($y1 =R $y2)
with mul _ _ =R add _ _ â†ª false
with mul _ _ =R cst _ â†ª false
with mul _ _ =R var _ _ â†ª false
with mul _ _ =R opp _ â†ª false
with cst $x =R cst $y â†ª isEq ($x â‰ $y)
with cst _ =R mul _ _ â†ª false
with cst _ =R add _ _ â†ª false
with cst _ =R opp _ â†ª false
with cst _ =R var _ _ â†ª false
with opp $x =R opp $y â†ª ($x =R $y)
with opp _ =R mul _ _ â†ª false
with opp _ =R add _ _ â†ª false
with opp _ =R cst _ â†ª false
with opp _ =R var _ _ â†ª false
;

sequential symbol >R: R â†’ R â†’ Ï„ bool; notation >R infix 20;
rule (var $x $c1) >R (var $x $c2) â†ª isGt ($c1 â‰ $c2)
with (var $x $c1) >R (var $y $c2) â†ª false
with (var $x $c1) >R add _ _ â†ª false
with (var $x $c1) >R mul _ _ â†ª false
with (var $x $c1) >R cst _ â†ª false
with (var $x $c1) >R opp _ â†ª false
with add $x1 $y1 >R add $x2 $y2 â†ª ($x1 >R $x2) Stdlib.Bool.and ($y1 >R $y2)
with add _ _ >R mul _ _ â†ª false
with add _ _ >R cst _ â†ª false
with add _ _ >R var _ _ â†ª false
with add _ _ >R opp _ â†ª false
with (mul $x1 $y1) >R (mul $x2 $y2) â†ª (isGt ($x1 â‰ $x2)) Stdlib.Bool.and ($y1 >R $y2)
with mul _ _ >R add _ _ â†ª false
with mul _ _ >R cst _ â†ª false
with mul _ _ >R var _ _ â†ª false
with mul _ _ >R opp _ â†ª false
with cst $x >R cst $y â†ª isGt ($x â‰ $y)
with cst _ >R mul _ _ â†ª false
with cst _ >R add _ _ â†ª false
with cst _ >R opp _ â†ª false
with cst _ >R var _ _ â†ª false
with opp $x >R opp $y â†ª ($x >R $y)
with opp _ >R mul _ _ â†ª false
with opp _ >R add _ _ â†ª false
with opp _ >R cst _ â†ª false
with opp _ >R var _ _ â†ª false
;

symbol â‰¥R â‰” Î» x, Î» y,  (x =R y) Stdlib.Bool.or (x >R y);

opaque symbol Radd_correct : Ï€á¶œ (`âˆ€á¶œ (x : R), `âˆ€á¶œ (y : R), denote (add x y) = denote x + denote y) â‰” begin
  apply âˆ€á¶œáµ¢; assume x; apply âˆ€á¶œáµ¢; assume y; reflexivity
end;

opaque symbol Ropp_correct : Ï€á¶œ (`âˆ€á¶œ (x : R), `âˆ€á¶œ (y : R), denote (opp x) = â€” denote x) â‰” begin
  apply âˆ€á¶œáµ¢; assume x; apply âˆ€á¶œáµ¢; assume y; reflexivity
end;


opaque symbol correct_liaAC : Ï€á¶œ (`âˆ€á¶œ (x : R), `âˆ€á¶œ (y : R), istrue (x =R y) â‡’á¶œ denote x = denote y) â‰” begin
apply R_ind (Î» u, `âˆ€á¶œ (y : R), istrue (u =R y) â‡’á¶œ denote u = denote y)
{
  assume c1;
  apply R_ind (Î» u, istrue (cst c1 =R u) â‡’á¶œ denote (cst c1) = denote u)
  { assume c2; simplify isEq; apply â‡’á¶œáµ¢; assume H; simplify; admit  } //CASE
  { simplify; assume x; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume x y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume x y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume x y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
}
{
  assume x;
  apply R_ind (Î» u, istrue (opp x =R u) â‡’á¶œ denote (opp x) = denote u)
  { assume c2; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { assume y; simplify =R;  apply â‡’á¶œáµ¢; assume H; admit } //CASE
  { simplify; assume c y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume c y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume c y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
}
{
  assume c1 x;
  apply R_ind (Î» u, istrue (var c1 x =R u) â‡’á¶œ denote (var c1 x) = denote u)
  { assume c2; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { assume y; simplify =R;  apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H } 
  { assume c2 y; apply â‡’á¶œáµ¢;  assume H; apply âŠ¥á¶œâ‚‘ H } //CASE
  { simplify; assume c y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
  { simplify; assume c y; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H }
}
{
  assume x1 y1;
  apply R_ind (Î» u, istrue (add x1 y1 =R u) â‡’á¶œ denote (add x1 y1) = denote u)
  {assume c2; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  {assume x; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  {assume c2 y; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  { assume x2 y2; apply â‡’á¶œáµ¢; assume H;  admit } //CASE
  { assume c2 y2; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
}
{
  assume c1 x;
  apply R_ind (Î» u, istrue (mul c1 x =R u) â‡’á¶œ denote (mul c1 x) = denote u)
  {assume c2; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  {assume y; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  {assume c2 y; simplify; apply â‡’á¶œáµ¢; assume H; apply âŠ¥á¶œâ‚‘ H}
  { assume x2 y2; apply â‡’á¶œáµ¢; assume H;  apply âŠ¥á¶œâ‚‘ H } 
  { assume c2 y2; apply â‡’á¶œáµ¢; simplify; assume H; admit} //CASE
};
end;
