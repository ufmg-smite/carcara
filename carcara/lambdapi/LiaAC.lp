/**********
The standard library use this rewrites rules in Z and Pos that has been prove confluent.

(VAR
  a: Z
  b: Z
  x : P
  q : P
  y : P
)
(THEORY (AC addG))
(RULES
  â€”(Z0) -> Z0
  â€”(Zpos(p)) -> Zneg(p)
  â€”(Zneg(p)) -> Zpos(p)
  â€”(â€”(a)) -> a

  double(Z0) -> Z0
  double(Zpos(p)) -> Zpos(O(p))
  double(Zneg(p)) -> Zneg(O(p))
  
  succ_double(Z0) -> Zpos(H)
  succ_double(Zpos(p)) -> Zpos(I(p))
  succ_double(Zneg(p)) -> Zneg(pos_pred_double(p))
  
  pred_double(Z0) -> Zneg(H)
  pred_double(Zpos(p)) -> Zpos(pos_pred_double(p))
  pred_double(Zneg(p)) -> Zneg(I(p))

  sub(I(p), I(q)) -> double(sub(p, q))
  sub(I(p), O(q)) -> succ_double(sub(p, q))
  sub(I(p), H) -> Zpos(O(p))
  sub(O(p), I(q)) -> pred_double(sub(p, q))
  sub(O(p), O(q)) -> double(sub(p, q))
  sub(O(p), H) -> Zpos(pos_pred_double(p))
  sub(H, I(q)) -> Zneg(O(q))
  sub(H, O(q)) -> Zneg(pos_pred_double(q))
  sub(H, H) -> Z0

  +(Z0,a) -> a
  +(a,Z0) -> a
  +(Zpos(x), Zpos(y)) -> Zpos(add(x, y))
  +(Zpos(x), Zneg(y)) -> sub(x, y)
  +(Zneg(x), Zpos(y)) -> sub(y, x)
  +(Zneg(x), Zneg(y)) -> Zneg(add(x, y))
  
  mult(Z0, a) -> Z0
  mult(a, Z0) -> Z0
  mult(Zpos(x), Zpos(y)) -> Zpos(mul(x, y))
  mult(Zpos(x), Zneg(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zpos(y)) -> Zneg(mul(x, y))
  mult(Zneg(x), Zneg(y)) -> Zpos(mul(x, y))


  succ(I(x)) -> O(succ(x))
  succ(O(x)) -> I(x)
  succ(H) -> O(H)
  add(I(x), I(q)) -> O(addcarry(x, q))
  add(I(x), O(q)) -> I(add(x, q))
  add(O(x), I(q)) -> I(add(x, q))
  add(O(x), O(q)) -> O(add(x, q))
  add(x, H) -> succ(x)
  add(H, y) -> succ(y)

  addcarry(I(x), I(q)) -> I(addcarry(x, q))
  addcarry(I(x), O(q)) -> O(addcarry(x, q))
  addcarry(O(x), I(q)) -> O(addcarry(x, q))
  addcarry(O(x), O(q)) -> I(add(x, q))
  addcarry(x, H) -> add(x, O(H))
  addcarry(H, y) -> add(O(H), y)
  
  pos_pred_double(I(x)) -> I(O(x))
  pos_pred_double(O(x)) -> I(pos_pred_double(x))
  pos_pred_double(H) -> H
  
  mul(I(x), y) -> add(x, O(mul(x,y)))
  mul(O(x), y) -> O(mul(x, y))
  mul(H, y) -> y

  add(var(k,x), var(l,x)) -> var(+(k,l), x)
  add(var(k,x), add(var(l,x),y)) -> add(var(+(k,l),x), y)
  add(cst(k), cst(l)) -> cst(+(k,l))
  add(cst(k), add(cst(l), y)) -> add(cst(+(k,l)), y)
  add(cst(Z0), x) -> x
  add(x, cst(Z0)) -> x
)
***********/

require open Stdlib.Nat Stdlib.Z Stdlib.List;

notation â‰¥ infix 10;

constant symbol R : TYPE;
constant symbol ring: Set;
rule Ï„ ring â†ª R;

constant symbol cst: â„¤ â†’ R;

symbol var : â„¤ â†’ â„¤ â†’ R;
/* semantics: [var k x] = k * x
note that the second argument could be any type that has a ring structure
(we then would take R : TYPE â†’ TYPE) */
symbol opp:R â†’ R;
right associative commutative symbol add:R â†’ R â†’ R;
symbol mul: â„¤ â†’ R â†’ R;

symbol R_ind: Î  p: (R â†’ Prop), 
  (Î  x0: â„¤, Ï€ ( p (cst x0))) â†’
  (Î  x0: R, Ï€ ( p (opp x0))) â†’
  (Î  x0: â„¤, Î  y0: â„¤, Ï€ (p (var x0 y0))) â†’
  (Î  x0: R, Î  y0: R, Ï€ (p (add x0 y0))) â†’
  (Î  x0: â„¤, Î  y0: R, Ï€ (p (mul x0 y0))) â†’
  Ï€ (`âˆ€ x: R, p x);


rule opp (var $k $x) â†ª var (â€” $k) $x 
with opp (cst $k) â†ª cst (â€” $k)
with opp (opp $x) â†ª $x
with opp (add $x $y) â†ª add (opp $x) (opp $y)
// // // note that opp is totally defined on terms built with var, cst, opp and add, i.e. no normal form contains opp
with add (var $k $x) (var $c $x) â†ª var ($k + $c) $x
with add (var $k $x) (add (var $l $x) $y) â†ª add (var ($k + $l) $x) $y
with add (cst $k) (cst $l) â†ª cst ($k + $l)
with add (cst $k) (add (cst $l) $y) â†ª add (cst ($k + $l)) $y
with add (cst 0) $x â†ª $x
with add $x (cst 0) â†ª $x

//multiplication by a constant (optional)
with mul $k (var $c $x) â†ª var ($k * $c) $x
with mul $k (opp $r) â†ª mul (â€” $k) $r
with mul $k (add $r $s) â†ª add (mul $k $r) (mul $k $s)
with mul $k (cst $z) â†ª cst ($k * $z)
with mul $k (mul $l $z) â†ª mul ($k * $l) $z

with var _ 0 â†ª cst 0;
// // note that mul is totally defined on terms built from var, cst, opp, add and mul, i.e. no normal form contains mul

// // reification
// // WARNING: this symbol is declared as sequential
// // and the reduction relation is not stable by substitution
sequential symbol reify : â„¤ â†’ R;
rule reify 0 â†ª cst 0
with reify (Zpos $x) â†ª cst (Zpos $x)
with reify (Zneg $x) â†ª cst (Zneg $x)
with reify (â€” $x) â†ª opp (reify $x)
with reify ($x + $y) â†ª add (reify $x) (reify $y)

with reify (0 * $y) â†ª mul 0 (reify $y)
with reify (Zpos $x * $y) â†ª mul (Zpos $x) (reify $y)
with reify (Zneg $x * $y) â†ª mul (Zneg $x) (reify $y)
with reify ($y * 0) â†ª mul 0 (reify $y)
with reify ($y * Zpos $x) â†ª mul (Zpos $x) (reify $y)
with reify ($y * Zneg $x) â†ª mul (Zneg $x) (reify $y)

with reify $x â†ª var 1 $x; // must be the last rule for reify

print eq_refl;

// eval function
symbol denote: R â†’ â„¤;
rule denote (var $k $i) â†ª $k * $i
with denote (cst $k) â†ª $k
with denote (opp $x) â†ª â€” (denote $x)
with denote (add $x $y) â†ª (denote $x) + (denote $y)
;

// Lemma Zle_not_gt n m : n <= m -> â€” n > m.
symbol Zle_not_gt n m:  Ï€ ((n â‰¤ m) = Â¬ (n > m));

symbol Zlt_not_ge n m:  Ï€ ((n < m) = Â¬ (n â‰¥ m));

symbol Zge_not_lt : Î  n: â„¤, Î  m: â„¤, Ï€ ((n â‰¥ m) = Â¬ (n < m));

symbol Zgt_not_le : Î  n: â„¤, Î  m: â„¤, Ï€ ((n > m) = Â¬ (n â‰¤ m));

// Lemma Zmult_gt_compat_r n m p : p > 0 -> n > m -> n * p > m * p.
symbol Zmult_gt_compat c a b : Ï€ (c > 0) â†’ Ï€ (a > b) â†’ Ï€ (c * a > c * b) ;

// Lemma Zmult_ge_compat_r n m p : n >= m -> p >= 0 -> n * p >= m * p.
symbol Zmult_ge_compat c a b : Ï€ (c > 0) â†’ Ï€ (a â‰¥ b) â†’ Ï€ (c * a â‰¥ c * b);

symbol Zgt_le_succ_r a b: Ï€ (a > b) â†’ Ï€ (a â‰¥ b + 1);

symbol Zinv_lt a b: Ï€ (a < b) â†’ Ï€ (â€” a > â€” b);

symbol Zsum_geq_s a b c d : Ï€ (a â‰¥ b) â†’ Ï€ (c â‰¥ d) â†’ Ï€ (a + c â‰¥ b + d);

symbol Z_diff_geq_Z0 a b: Ï€ (a â‰¥ b) â†’ Ï€ (a - b â‰¥ 0);
symbol Z_diff_gt_Z0 a b: Ï€ (a > b) â†’ Ï€ (a - b > 0);



opaque symbol neutral_H_* a : Ï€ (Zpos H * a = a) â‰”
begin
induction
{ reflexivity }
{ reflexivity }
{ reflexivity }
end;

symbol ind_ð”¹ x : Î  p0: (ð”¹ â†’ Prop), Ï€ (p0 true) â†’ Ï€ (p0 false) â†’ Ï€ (p0 x);

opaque symbol âˆ¨_istrue [p q] : Ï€ (istrue (p Stdlib.Bool.or q)) â†’ Ï€ (istrue p âˆ¨ istrue q) â‰”
begin
admit
end;

symbol ind_Comp x : Î  p0: (Comp â†’ Prop), Ï€ (p0 Eq) â†’ Ï€ (p0 Lt) â†’ Ï€ (p0 Gt) â†’ Ï€ (p0 x);

symbol Zgt_le_succ_r_eq a b: Ï€ ((a > b) = (a â‰¥ b + 1));

symbol Zinv_lt_eq a b: Ï€ ((a < b) = (â€” a > â€” b));

symbol Zinv_le_eq a b: Ï€ ((a â‰¤ b) = (â€” a â‰¥ â€” b));

symbol Z_diff_geq_Z0_eq a b: Ï€ ((a â‰¥ b) = (a - b â‰¥ 0));

symbol Z_diff_gt_Z0_eq a b: Ï€ ((a > b) = (a - b > 0));

symbol Z_diff_eq_Z0_eq a b: Ï€ ((a = b) = (a - b = 0));

//Axioms
symbol Z_eq_antisym (a b: Ï„ int):  Ï€ ((Â¬ (a = b)) = Â¬ (a â‰¥ b));

symbol Z_eq_implies_ge [a b: Ï„ int]:  Ï€ (a = b) â†’  Ï€ (a â‰¥ b);

symbol Zmult_eq_compat_eq (c a b: Ï„ int) : Ï€ ((Â¬ (a = b)) = Â¬ (c * a = c * b));
symbol Zmult_gt_compat_eq c a b : Ï€ (Â¬ (a > b) = Â¬ (c * a > c * b)) ;
symbol Zmult_ge_compat_eq c a b : Ï€ (Â¬ (a â‰¥ b) = Â¬ (c * a â‰¥ c * b)) ;

symbol la_mult_neg_eq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 = t3) â‡’ (t1 * t2) = (t1 * t3)) â‰”
begin
  assume t1 t2 t3; assume H H2; rewrite H2; reflexivity
end;

//FIXME: give proof
symbol la_mult_neg_lt t1 t2 t3 : Ï€ (t1 < 0) â†’ Ï€ (t2 < t3) â†’ Ï€ ((t1 * t2) > (t1 * t3));
symbol la_mult_neg_leq [t1 t2 t3] : Ï€ ((t1 < 0) â‡’ (t2 â‰¤ t3) â‡’ (t1 * t2) â‰¥ (t1 * t3));

symbol ind_â„¤ : Î  p0: (â„¤ â†’ Prop), Ï€ (p0 0) â†’ (Î  x0: â„™, Ï€ (p0 (Zpos x0))) â†’ (Î  x0: â„™, Ï€ (p0 (Zneg x0))) â†’ Ï€ (`âˆ€ x, p0 x);

opaque symbol inj2 : Ï€ (`âˆ€ x, (denote (reify x)) = x) â‰” begin
induction
{reflexivity}
{reflexivity}
{reflexivity}
end;

symbol inj: Î  x: â„¤, Ï€ ((denote (reify  x)) = x);
