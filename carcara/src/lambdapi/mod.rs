#[allow(warnings)]
use crate::ast::{
    polyeq,
    pool::{self, TermPool},
    AnchorArg, Binder, Operator, PrimitivePool, ProblemPrelude, Proof as ProofElaborated,
    ProofCommand, ProofIter, ProofStep as AstProofStep, Rc, Sort, Subproof, Term as AletheTerm,
};
use indexmap::IndexMap;
use itertools::Itertools;
use thiserror::Error;
use try_match::unwrap_match;

use std::{
    collections::HashSet,
    fmt::{self},
    ops::Deref,
    time::Duration,
    vec,
};

mod dsl;
pub mod output;
pub mod printer;
pub mod proof;
mod simp;
#[macro_use]
mod tautology;
mod lia;
pub mod term;

use dsl::*;
use lia::*;
use output::*;
use proof::*;
use simp::*;
use tautology::*;
use term::*;

#[derive(Debug, Error)]
pub enum TranslatorError {
    #[error("the pivot is not in the clause")]
    PivotNotInClause,
    #[error("the premises are incorrect")]
    PremisesError,
}

pub type TradResult<T> = Result<T, TranslatorError>;

pub struct Config {
    pub no_elab: bool,
    pub why3: bool,
}

#[derive(Default)]
pub struct Context {
    prelude: Vec<Command>,
    /// Sharing map contains all the dagify common sub expression generated by the SMT-solver
    /// with the `:named` annotation. This feature make step more compact and easier to debug.
    /// We do not propose an option to disable this feature because it is enough to run Carcara translation
    /// by providing a proof file without `:named` annotation.
    pub term_indices: IndexMap<Rc<AletheTerm>, (usize, String)>,
    pub term_sharing: IndexMap<Rc<AletheTerm>, (String, Term)>,

    pub global_variables: HashSet<Rc<AletheTerm>>,
}

impl Context {
    /// Convert dagify subexpression into `Term::TermId` otherwise just apply a canonical conversion
    fn get_or_convert(&self, term: &Rc<AletheTerm>) -> (Term, HashSet<String>) {
        term::conv(term, self)
    }
}

/// Corresponding to the symbol application π̇ₗ x,
/// where π̇ₗ: π̇ (a ⟇ □)  → π a
pub fn unary_clause_to_prf(premise_id: &str) -> Term {
    Term::Terms(vec![Term::from("π̇ₗ"), Term::from(premise_id)])
}

fn translate_sort_function(sort: &Sort) -> Term {
    match sort {
        Sort::Bool => omicron(),
        Sort::Int => "int".into(),
        Sort::Function(params) => {
            let sorts = params
                .into_iter()
                .map(|t| unwrap_match!(**t, AletheTerm::Sort(ref s) => s))
                .map(|s| translate_sort_function(s))
                .collect_vec();

            sorts
                .into_iter()
                .reduce(|acc, e| Term::Sort(BuiltinSort::Arrow(Box::new(acc), Box::new(e))))
                .unwrap()
        }
        Sort::Atom(ref a, args) => {
            if args.is_empty() {
                a.as_ref().into()
            } else {
                let mut args: Vec<Term> = args.into_iter().map(Into::into).collect_vec();
                let mut sort = vec![a.as_ref().into()];
                sort.append(&mut args);
                Term::Terms(sort)
            }
        }
        ref e => unreachable!("{:?}", e),
    }
}

/// Translate the SMT declaration symbol of sort and function into Lambdapi symbol.
/// The type Prop is used a default to be polymorphic.
/// ex:
/// (declare-sort S 0)
/// become
/// symbol S: Prop;
fn translate_prelude(prelude: ProblemPrelude) -> Vec<Command> {
    let mut sort_declarations_symbols = prelude
        .sort_declarations
        .into_iter()
        .map(|(id, arity)| {
            let sorts = itertools::repeat_n(set(), arity + 1).collect_vec();
            Command::Definition(id.to_string(), vec![], Some(Term::Function(sorts)), None)
        })
        .collect::<Vec<Command>>();

    let mut function_declarations_symbols = prelude
        .function_declarations
        .into_iter()
        .enumerate()
        .map(|(_counter, (id, term))| {
            let sort = match *term {
                AletheTerm::Sort(ref s) => tau(translate_sort_function(s)),
                _ => unreachable!(),
            };

            Command::Definition(id.to_string(), vec![], Some(sort), None)
        })
        .collect::<Vec<Command>>();

    sort_declarations_symbols.append(&mut function_declarations_symbols);

    sort_declarations_symbols
}

#[inline]
fn gen_required_module() -> Vec<Command> {
    vec![
        Command::RequireOpen("lambdapi.Alethe".to_string()),
        Command::RequireOpen("lambdapi.Simplify".to_string()),
        Command::RequireOpen("lambdapi.Rare".to_string()),
        Command::RequireOpen("lambdapi.Lia".to_string()),
        Command::RequireOpen("lambdapi.Clause".to_string()),
    ]
}

fn gen_shared_term(ctx: &Context) -> Vec<Command> {
    ctx.term_indices
        .iter()
        .filter(|(_, (counter, _))| *counter >= 2)
        .map(|(t, (..))| ctx.term_sharing[t].clone())
        .map(|(id, term)| Command::Definition(id.to_string(), vec![], None, Some(term)))
        .collect_vec()
}

pub fn produce_lambdapi_proof<'a>(
    prelude: ProblemPrelude,
    proof_elaborated: ProofElaborated,
    mut pool: pool::PrimitivePool,
    config: Config,
) -> TradResult<ProofFile> {
    let mut proof_file = ProofFile::new();

    proof_file.requires = gen_required_module();

    let global_variables: HashSet<_> = prelude
        .function_declarations
        .iter()
        .map(|var| pool.add(var.clone().into()))
        .collect();

    proof_file.definitions = translate_prelude(prelude);

    let mut context = Context::default();

    context.global_variables = global_variables;

    let commands = translate_commands(
        &mut context,
        &mut proof_elaborated.iter(),
        &mut pool,
        |id, t, ps| {
            let modifier = ps.is_some().then(|| Modifier::Opaque);
            Command::Symbol(
                modifier,
                normalize_name(id),
                vec![],
                t,
                ps.map(|ps| Proof(ps)),
            )
        },
    )?;

    let shared_terms = gen_shared_term(&context);

    proof_file.definitions.extend(shared_terms);

    proof_file.content.extend(commands);

    Ok(proof_file)
}

fn get_premises_clause<'a>(
    proof_iter: &'a ProofIter,
    premises: &'a [(usize, usize)],
) -> Vec<(String, &'a [Rc<AletheTerm>])> {
    premises
        .into_iter()
        .map(|p| proof_iter.get_premise(*p))
        .map(|c| (normalize_name(c.id()), c.clause()))
        .collect_vec()
}

fn get_pivots_from_args(args: &Vec<Rc<AletheTerm>>) -> Vec<(Rc<AletheTerm>, bool)> {
    args.into_iter()
        .tuples()
        .map(|(x, y)| match (x, y) {
            (pivot, flag) if flag.is_bool_true() => ((*pivot).clone(), true),
            (pivot, flag) if flag.is_bool_false() => ((*pivot).clone(), false),
            _ => panic!("Pivot are not a tuple of term and bool anymore"),
        })
        .collect_vec()
}

/// Returns a new clause containing all literals of the resolvent premises after the pivot and its negation have been removed.
///
/// convention for the pivot polarity:
/// * If `flag` is `true`, the positive pivot must occur in `clause_left` and its negation in `clause_right`.
/// * If `flag` is `false`, the negated pivot must occur in `clause_left` and the positive pivot in `clause_right`.
///
/// Exactly one occurrence is removed from each side if present; the remaining literals are
/// concatenated in order (left part first, then right part), preserving the original left-to-right
/// order except for the single deletions.
///
/// This function does **not** panic if the pivot is missing; it simply leaves the clause
/// unchanged on that side. (Sanity of pivot presence is enforced in `make_resolution`.
fn remove_pivot_in_clause<'a>(
    (pivot, flag): &(Rc<AletheTerm>, bool),
    clause_left: &[Rc<AletheTerm>],
    clause_right: &[Rc<AletheTerm>],
    pool: &mut PrimitivePool,
) -> Vec<Rc<AletheTerm>> {
    let mut duration = Duration::ZERO;

    //FIXME: pivot should be or there is a bug
    if *flag {
        let mut filtered_clause_left = clause_left.into_iter().map(|t| t.clone()).collect_vec();
        let index = filtered_clause_left
            .iter()
            .position(|t| polyeq(pivot, t, &mut duration));

        if let Some(index) = index {
            filtered_clause_left.remove(index);
        }

        let mut filtered_clause_right = clause_right.into_iter().map(|t| t.clone()).collect_vec();
        let index = filtered_clause_right
            .iter()
            .position(|t| polyeq(&term_negated(pivot, pool), t, &mut duration));
        if let Some(index) = index {
            filtered_clause_right.remove(index);
        }

        filtered_clause_left.append(&mut filtered_clause_right);
        filtered_clause_left
    } else {
        let mut filtered_clause_left = clause_left.into_iter().map(|t| t.clone()).collect_vec();
        let index = filtered_clause_left
            .iter()
            .position(|t| polyeq(&term_negated(pivot, pool), t, &mut duration));

        if let Some(index) = index {
            filtered_clause_left.remove(index);
        }

        let mut filtered_clause_right = clause_right.into_iter().map(|t| t.clone()).collect_vec();
        let index = filtered_clause_right
            .iter()
            .position(|t| polyeq(&pivot, t, &mut duration));

        if let Some(index) = index {
            filtered_clause_right.remove(index);
        }

        filtered_clause_left.append(&mut filtered_clause_right);
        filtered_clause_left
    }
}

/// Build the Lambdapi proof step that performs binary resolution over a given pivot.
///
///
/// t1: p,A     t2: ¬p,B
/// ---------------------- (:rule resolution :premises (t1 t2) :args (p true))
///    A,B
///
/// This function constructs the application of one of the two resolution lemmas
/// `disj_resolutionN1` or `disj_resolutionN2` in Lambdapi, depending on where the negated
/// occurrence of the pivot appears. The choice follows Carcara’s flag convention:
/// - If `flag_position_pivot` is `true`, the positive pivot is in the **left** premise and the
///   negated pivot is in the **right** premise; `disj_resolutionN2` is applied.
/// - If `flag_position_pivot` is `false`, the negated pivot is in the **left** premise and the
///   positive pivot is in the **right** premise; `disj_resolutionN1` is applied.
///
/// The function:
/// 1) locates the pivot indices `i` and `j` inside the left and right clauses,
/// 2) converts both clauses to Lambdapi terms using `ctx.get_or_convert`,
/// 3) applies the appropriate lemma with the clauses, indices, hypotheses (step names),
///    and trivial introductions of `⊤ᵢ` together with `eq_refl`.
///
/// ```text
/// have t1_t2 : π̇ (a1 ⟇ ...⟇ p ⟇... ⟇ an ⟇ b1 ⟇ ...⟇ ¬ p ⟇... ⟇ bn ⟇ ▩) {
///     apply disj_resolutionN1
///         (a1 ⟇ ...⟇ p ⟇... ⟇ an ⟇ ▩)
///         (b1 ⟇ ...⟇ ¬ p ⟇... ⟇ an ⟇ ▩)
///         i
///         j
///         t1 t2
///         ⊤ᵢ ⊤ᵢ (eq_refl _);
/// };
/// ```
fn make_resolution(
    (pivot, flag_position_pivot): &(Rc<AletheTerm>, bool),
    (left_step_name, left_clause): &(&str, &[Rc<AletheTerm>]),
    (right_step_name, right_clause): &(&str, &[Rc<AletheTerm>]),
    ctx: &mut Context,
    pool: &mut PrimitivePool,
) -> Vec<ProofStep> {
    let hyp_left_arg = Term::TermId(left_step_name.to_string());
    let hyp_right_arg = Term::TermId(right_step_name.to_string());

    let neg_pivot = term_negated(pivot, pool);

    let (i, j) = if *flag_position_pivot {
        let i = left_clause
            .into_iter()
            .position(|x| polyeq(pivot, x, &mut Duration::ZERO) == true)
            .expect("1");
        let j = right_clause
            .into_iter()
            .position(|x| polyeq(&neg_pivot, x, &mut Duration::ZERO) == true)
            .expect("2");
        (i, j)
    } else {
        // flag at `false` so negation of the pivot is on the first premise and positive pivot on the 2nd.
        let i = left_clause
            .into_iter()
            .position(|x| polyeq(&neg_pivot, x, &mut Duration::ZERO) == true)
            .expect("3");
        let j = right_clause
            .into_iter()
            .position(|x| polyeq(pivot, x, &mut Duration::ZERO) == true)
            .expect("4");
        (i, j)
    };

    let ps = Term::Alethe(LTerm::Clauses(
        (left_clause
            .into_iter()
            .map(|c| ctx.get_or_convert(c).0)
            .collect_vec()),
    ));
    let qs = Term::Alethe(LTerm::Clauses(
        (right_clause
            .into_iter()
            .map(|c| ctx.get_or_convert(c).0)
            .collect_vec()),
    ));

    // apply disj_resolutionN (p_29 ⟇ (p_11 ⟇ (p_10 ⟇ ▩))) (p_12 ⟇ ▩) (int2nat 1 ⊤ᵢ) Stdlib.Nat._0 t14_t0 t14_t9 ⊤ᵢ ⊤ᵢ (eq_refl _);
    if *flag_position_pivot {
        vec![ProofStep::Apply(
            "disj_resolutionN2".into(),
            vec![
                ps,
                qs,
                int2nat(i),
                int2nat(j),
                hyp_left_arg,
                hyp_right_arg,
                intro_top(),
                intro_top(),
                Term::Terms(vec!["eq_refl".into(), Term::Underscore]),
            ],
            SubProofs(None),
        )]
    } else {
        vec![ProofStep::Apply(
            "disj_resolutionN1".into(),
            vec![
                ps,
                qs,
                int2nat(i),
                int2nat(j),
                hyp_left_arg,
                hyp_right_arg,
                intro_top(),
                intro_top(),
                Term::Terms(vec!["eq_refl".into(), Term::Underscore]),
            ],
            SubProofs(None),
        )]
    }
    //left_clause.pos
}

/// Create the negation of a term
#[inline]
fn term_negated(term: &Rc<AletheTerm>, pool: &mut PrimitivePool) -> Rc<AletheTerm> {
    pool.add(AletheTerm::Op(Operator::Not, vec![term.clone()]))
}

#[inline]
/// Lambdapi does not support symbol name containing dot so
/// they are replace by underscore.
/// SMTLIB quoted symbols `|x|` allow to have pretty much any character in a symbol.
/// However that is incompatible with identifier of Lambdapi.
fn normalize_name<S: AsRef<str>>(name: S) -> String {
    // call as_ref() to get a &str
    name.as_ref()
        .replace(".", "_")
        .replace(printer::WHITE_SPACE, "")
        .replace("$", "")
}

/// Map some rule name to their corresponding symbol in the Lambdapi stdlib
fn translate_rule_name(rule: &str) -> Term {
    match rule {
        "refl" => Term::TermId("⟺_refl".to_string()),
        "symm" => Term::TermId("⟺_sym".to_string()),
        "trans" => Term::TermId("⟺_trans".to_string()),
        r => Term::TermId(r.to_string()),
    }
}

/// Translate (anchor :step ti) and its steps
/// A subproof is translated into an opaque symbol
/// added to the prelude of the file.
fn translate_subproof<'a>(
    context: &mut Context,
    iter: &mut ProofIter<'a>,
    commands: &[ProofCommand],
    assignment_args: Vec<(&(String, Rc<AletheTerm>), &Rc<AletheTerm>)>,
    pool: &mut PrimitivePool,
) -> TradResult<(String, Vec<Term>, Vec<ProofStep>)> {
    let subproof = commands.last().unwrap();

    //Get the last step of the proof
    let (id, clause, rule) = unwrap_match!(
        subproof,
        ProofCommand::Step(AstProofStep { id, clause, rule,.. }) => (normalize_name(id), clause, rule)
    );

    let clause = clause
        .iter()
        .map(|t| context.get_or_convert(t).0)
        .collect_vec();

    let mut fresh_ctx = Context::default();
    fresh_ctx.global_variables = context.global_variables.clone();
    fresh_ctx.term_indices = context.term_indices.clone();
    fresh_ctx.term_sharing = context.term_sharing.clone();

    let mut proof_cmds = translate_commands(&mut fresh_ctx, iter, pool, |id, t, ps| {
        ProofStep::Have(normalize_name(id), t, ps.unwrap_or(admit()))
    })?;

    proof_cmds
        .iter_mut()
        .filter(|cmd| matches!(cmd, ProofStep::Have(_, _, _)))
        .for_each(|cmd| match cmd {
            ProofStep::Have(name, cl, steps) => {
                cl.visit(&assignment_args);
                *cmd = ProofStep::Have(name.to_string(), cl.clone(), steps.to_vec());
            }
            _ => {}
        });

    let assignment_args = assignment_args
        .into_iter()
        .map(|(_, term)| Term::from(term))
        .collect_vec();

    //TODO: Remove this side effect by append the prelude in translate_commands and return the  pair Subproof + Axioms in subproof
    context.prelude.append(&mut fresh_ctx.prelude); // Add subproof of current subproof to the prelude

    let subproof_have_wrapper = if rule == "bind" {
        let mut proof = vec![];

        let last_step_id = unwrap_match!(commands.get(commands.len() - 2), Some(ProofCommand::Step(AstProofStep{id, ..})) => normalize_name(id));

        let bind_lemma = match subproof.clause().first().expect("clause is empty").deref() {
            AletheTerm::Op(Operator::Equals, args)
                if matches!(args[0].deref(), AletheTerm::Binder(Binder::Forall, _, _))
                    && matches!(args[1].deref(), AletheTerm::Binder(Binder::Forall, _, _)) =>
            {
                "bind_∀"
            }
            AletheTerm::Op(Operator::Equals, args)
                if matches!(args[0].deref(), AletheTerm::Binder(Binder::Exists, _, _))
                    && matches!(args[1].deref(), AletheTerm::Binder(Binder::Exists, _, _)) =>
            {
                "bind_∃"
            }
            _ => unreachable!(),
        };

        proof.push(ProofStep::Apply(Term::from("∨ᵢ₁"), vec![], SubProofs(None)));
        assignment_args.into_iter().for_each(|term| {
            proof.push(ProofStep::Apply(
                Term::from(bind_lemma),
                vec![],
                SubProofs(None),
            ));
            proof.push(ProofStep::Assume(vec![format!("{}", term)]));
        });
        proof.append(&mut proof_cmds);

        proof.push(ProofStep::Apply(
            Term::from("π̇ₗ"),
            vec![Term::from(last_step_id)],
            SubProofs(None),
        ));

        proof
    } else if rule == "sko_forall" {
        let last_step_id = unwrap_match!(commands.get(commands.len() - 1), Some(ProofCommand::Step(AstProofStep{id, ..})) => normalize_name(id));

        //FIXME: hahah
        // end of the script
        // proof_cmds.append(&mut lambdapi! {
        //     apply "∨ᵢ₁";
        //     apply "π̇ₗ" (@last_step_id.into());
        // });
        // proof_cmds.push(ProofStep::Admit);

        // proof_cmds
        admit()
    } else {
        proof_cmds
    };

    context.term_indices.extend(fresh_ctx.term_indices);
    context.term_sharing.extend(fresh_ctx.term_sharing);

    Ok((id, clause, subproof_have_wrapper))
}

/// Create a proof step for the resolution
fn translate_resolution(
    proof_iter: &mut ProofIter<'_>,
    premises: &[(usize, usize)],
    args: &Vec<Rc<AletheTerm>>,
    context: &mut Context,
    pool: &mut PrimitivePool,
) -> TradResult<Vec<ProofStep>> {
    let premises = get_premises_clause(&proof_iter, premises);

    let pivots = get_pivots_from_args(args);

    let (last_goal_name, _, mut steps) = match premises.as_slice() {
        [h1, h2, tl_premises @ ..] => match pivots.as_slice() {
            [pivot, tl_pivot @ ..] => tl_premises.into_iter().zip(tl_pivot.into_iter()).fold(
                (
                    format!("{}_{}", h1.0, h2.0),
                    remove_pivot_in_clause(&pivot, h1.1, h2.1, pool),
                    vec![ProofStep::Have(
                        format!("{}_{}", h1.0, h2.0),
                        proof(Term::Alethe(LTerm::Clauses(
                            remove_pivot_in_clause(&pivot, h1.1, h2.1, pool)
                                .into_iter()
                                .map(|t| context.get_or_convert(&t).0)
                                .collect::<Vec<Term>>(),
                        ))),
                        make_resolution(pivot, &(&h1.0, h1.1), &(&h2.0, h2.1), context, pool),
                    )],
                ),
                |(previous_goal_name, previous_goal, mut proof_steps), (premise, pivot)| {
                    let goal_name = format!("{}_{}", previous_goal_name, premise.0);

                    let current_goal =
                        remove_pivot_in_clause(&pivot, previous_goal.as_slice(), premise.1, pool);

                    let resolution = make_resolution(
                        pivot,
                        &(format!("{}", previous_goal_name).as_str(), &previous_goal),
                        &(&premise.0, premise.1),
                        context,
                        pool,
                    );

                    proof_steps.push(ProofStep::Have(
                        goal_name.clone(),
                        proof(Term::Alethe(LTerm::Clauses(
                            current_goal
                                .iter()
                                .map(|t| context.get_or_convert(&t).0)
                                .collect::<Vec<Term>>(),
                        ))),
                        resolution,
                    ));

                    (goal_name, current_goal, proof_steps)
                },
            ),
            _ => unreachable!(),
        },
        _ => unreachable!(),
    };

    steps.push(ProofStep::Refine(
        Term::TermId(last_goal_name),
        vec![],
        SubProofs(None),
    ));

    Ok(steps)
}

// Create a proof step for tautology step (equiv_pos1, and_neg, etc)
fn translate_tautology(
    proof_iter: &mut ProofIter<'_>,
    clause: &[Rc<AletheTerm>],
    premises: &[(usize, usize)],
    rule: &str,
    args: &Vec<Rc<AletheTerm>>,
) -> Option<TradResult<Proof>> {
    let mut premises: Vec<_> = get_premises_clause(&proof_iter, &premises);

    match rule {
        "bind" | "subproof" => None,
        "false" => Some(translate_false()),
        "forall_inst" => Some(translate_forall_inst(args)),
        "cong" => Some(translate_cong(clause, premises.as_slice())),

        // Nary rules
        "and_neg" => Some(translate_and_neg(clause)),
        "and_pos" => Some(translate_and_pos(clause, args)),
        "or_neg" => Some(translate_or_neg(clause, args)),
        "or_pos" => Some(Ok(Proof(vec![ProofStep::Admit]))),
        "not_and" => Some(translate_not_and(clause, premises.first()?.0.as_str())),
        "not_or" => Some(translate_not_or(premises.first()?, args)),

        "implies" => Some(translate_implies(premises.first()?.0.as_str())),
        "not_implies1" => Some(translate_not_implies1(premises.first()?.0.as_str())),
        "not_implies2" => Some(translate_not_implies2(premises.first()?.0.as_str())),
        "not_symm" => Some(translate_not_symm(premises.first()?.0.as_str())),
        "trans" => Some(translate_trans(&mut premises)),
        "symm" => Some(translate_sym(premises.first()?.0.as_str())),
        "refl" => Some(translate_refl()),
        "and" => Some(translate_and(premises.first()?, args)),
        "or" => Some(translate_or(premises.first()?)),
        "sko_forall" => Some(translate_sko_forall()),
        "ite1" => Some(translate_ite1(premises.first()?)),
        "ite2" => Some(translate_ite2(premises.first()?)),
        "contraction" => Some(translate_contraction(clause, premises.first()?)),
        "reordering" | "hole" => Some(Ok(Proof(admit()))), // specific rules of CVC5
        "la_mult_neg" => Some(Ok(Proof(admit()))),
        "la_mult_pos" => Some(Ok(Proof(admit()))),
        "la_disequality" => Some(translate_la_disequality(clause)),
        "connective_def" => Some(Ok(Proof(vec![ProofStep::Admit]))),
        _ => Some(translate_simple_tautology(rule, premises.as_slice())),
    }
}

fn translate_commands<'a, F, T>(
    ctx: &mut Context,
    proof_iter: &mut ProofIter<'a>,
    pool: &mut PrimitivePool,
    f: F,
) -> TradResult<Vec<T>>
where
    F: Fn(String, Term, Option<Vec<ProofStep>>) -> T,
{
    let mut proof_steps = Vec::new();

    while let Some(command) = proof_iter.next() {
        let clause = command.clause();
        clause.into_iter().for_each(|c| c.visit(ctx, pool));

        match command {
            ProofCommand::Assume { id, term } => proof_steps.push(f(
                id.into(),
                term::clauses(vec![ctx.get_or_convert(term).0]),
                None,
            )),
            ProofCommand::Step(AstProofStep {
                id,
                clause,
                premises,
                rule,
                args,
                discharge: _,
            }) if rule == "resolution" || rule == "th_resolution" => {
                let proof = translate_resolution(proof_iter, premises, args, ctx, pool)?;

                let clauses = Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(
                    clause
                        .into_iter()
                        .map(|a| ctx.get_or_convert(a).0)
                        .collect(),
                )))));

                proof_steps.push(f(normalize_name(id), clauses, Some(proof)));
            }
            ProofCommand::Step(AstProofStep {
                id, clause, premises: _, rule, args, ..
            }) if rule == "rare_rewrite" => {
                //let mut dag_terms: HashSet<_> =  HashSet::new();

                let (terms, hs): (Vec<Term>, Vec<HashSet<_>>) = clause
                    .into_iter()
                    .map(|a| {
                        ctx.get_or_convert(a)
                        //dag_terms.union(&h);
                    })
                    .unzip();

                let dag_terms: HashSet<_> = hs.into_iter().flatten().collect();

                let proof_script = translate_rare_simp(clause, args, dag_terms);

                let step = f(
                    normalize_name(id),
                    Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(terms))))),
                    Some(proof_script.0),
                );

                proof_steps.push(step);
            }
            ProofCommand::Step(AstProofStep { id, clause, rule, .. }) if rule.contains("simp") => {
                let terms: Vec<Term> = clause
                    .into_iter()
                    .map(|a| ctx.get_or_convert(a).0)
                    .collect();

                let proof_script = translate_simplify_step(rule);

                let step = f(
                    normalize_name(id),
                    Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(terms))))),
                    Some(proof_script.0),
                );
                proof_steps.push(step);
            }
            ProofCommand::Step(AstProofStep {
                id, clause, premises: _, rule, args, ..
            }) if rule == "la_generic" => {
                let proof = gen_proof_la_generic(&clause, args, pool);

                let clause = clause
                    .into_iter()
                    .map(|term| ctx.get_or_convert(term).0)
                    .collect_vec();

                proof_steps.push(f(
                    normalize_name(id),
                    Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(clause))))),
                    Some(proof),
                ));
            }
            ProofCommand::Step(AstProofStep {
                id, clause, premises, rule, args, ..
            }) => {
                let step = translate_tautology(proof_iter, clause, premises, rule, args);

                let clause = clause
                    .into_iter()
                    .map(|term| ctx.get_or_convert(term).0)
                    .collect();

                if let Some(step) = step {
                    proof_steps.push(f(
                        normalize_name(id),
                        Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(clause))))),
                        Some(step?.0),
                    ));
                }

                // Iteration is flatten with the ProofIter, so we need to break the looping if we
                // are in a subproof because the Subproof case use a recursive call.
                if proof_iter.is_end_step() {
                    break;
                }
            }
            ProofCommand::Subproof(Subproof { commands, args, .. }) => {
                let (id, clause, subproof) = translate_subproof(
                    ctx,
                    proof_iter,
                    commands.as_slice(),
                    args.into_iter()
                        .filter(|a| matches!(a, AnchorArg::Assign(_, _)))
                        .map(|a| unwrap_match!(a, AnchorArg::Assign(s, t) => (s, t)))
                        .collect_vec(),
                    pool,
                )?;

                let sub = commands.last().unwrap();

                //Get the last step of the proof
                let (id, cl, rule) = unwrap_match!(
                    sub,
                    ProofCommand::Step(AstProofStep { id, clause, rule,.. }) => (normalize_name(id), clause, rule)
                );

                if rule.contains("subproof") {
                    //HACK: we convert all the Have proof step into symbols to improve lambdapi check performance.
                    // We only do this for proof that use the `subproof` rule because `bind` and `sko_forall` for example
                    // creates temporary free variable in their context making the split of steps into `symbol` instead of `have` impossible.
                    // Lambdapi seems to be very slow on proof that have a large context.
                    let res = subproof.into_iter().map(|s| unwrap_match!(s, ProofStep::Have(id, r#type, proof) =>  f(id, r#type, Some(proof)))).collect_vec();
                    proof_steps.extend(res);

                    let discharge = unwrap_match!(commands.last(), Some(ProofCommand::Step(AstProofStep{id: _, clause:_, rule:_, premises:_, args:_, discharge})) => discharge);

                    let premises_discharge = get_premises_clause(proof_iter, discharge);

                    let mut script = std::iter::repeat(ProofStep::Apply(
                        Term::TermId("∨ᵢ₂".to_string()),
                        vec![],
                        SubProofs(None),
                    ))
                    .take(premises_discharge.len())
                    .collect_vec();

                    let (psy_id, trailing_false_on_last_step) = unwrap_match!(commands.get(commands.len() - 2), Some(ProofCommand::Step(AstProofStep{id, clause, ..})) => {
                        (normalize_name(id), clause.iter().last().map(|t| t.is_bool_false()).unwrap_or(false))
                    });

                    let trailing_false_on_conclusion_clause =
                        cl.iter().last().map(|t| t.is_bool_false()).unwrap_or(false);

                    // Some subproof can add a trailing false in their clause and also for the step just before the clonclusion of the subproof.
                    // We detect if there is a trailing false if the number of the element in the clause and the discharge are different
                    if trailing_false_on_conclusion_clause && trailing_false_on_last_step {
                        script.push(ProofStep::Apply(
                            psy_id.as_str().into(),
                            vec![],
                            SubProofs(None),
                        ));
                    } else if trailing_false_on_conclusion_clause {
                        // Case with a trailing false
                        script.push(ProofStep::Apply(
                            Term::TermId("∨ᵢ₂".to_string()),
                            vec![],
                            SubProofs(None),
                        ));
                        script.push(ProofStep::Apply(
                            psy_id.as_str().into(),
                            vec![],
                            SubProofs(None),
                        ));
                    } else if trailing_false_on_last_step {
                        // Case with a trailing false
                        script.push(ProofStep::Apply(
                            Term::TermId("∨ᵢ₁".to_string()),
                            vec![],
                            SubProofs(None),
                        ));
                        script.push(ProofStep::Apply(
                            unary_clause_to_prf(psy_id.as_str()),
                            vec![],
                            SubProofs(None),
                        ));
                    } else {
                        // Case without a trailing false
                        script.push(ProofStep::Apply(
                            Term::TermId("∨ᵢ₁".to_string()),
                            vec![],
                            SubProofs(None),
                        ));

                        script.push(ProofStep::Apply(
                            unary_clause_to_prf(psy_id.as_str()),
                            vec![],
                            SubProofs(None),
                        ));
                    }

                    proof_steps.push(f(
                        normalize_name(id),
                        Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(clause))))),
                        Some(script),
                    ));
                } else {
                    proof_steps.push(f(
                        normalize_name(id),
                        Term::Alethe(LTerm::Proof(Box::new(Term::Alethe(LTerm::Clauses(clause))))),
                        Some(subproof),
                    ));
                }
            }
        };
    }

    Ok(proof_steps)
}

#[cfg(test)]
mod tests_translation {
    use super::*;
    use crate::parser::{self, parse_instance};

    #[test]
    fn test_resolution() {
        let problem: &[u8] = b"
           (declare-fun a () Bool)
            (declare-fun b () Bool)
            (declare-fun c () Bool)
        ";
        let proof = b"
            (assume a4 (not (= a a)))
            (step t1 (cl (= a a) (= b b)) :rule hole)
            (step t2 (cl (= c c) (not (= a a))) :rule hole)
            (step t3 (cl (= b b) (= c c)) :rule resolution :premises (t1 t2) :args ((= a a) true))
        ";
        let (problem, proof, _, mut pool) =
            parse_instance(problem, proof, None, parser::Config::new()).unwrap();

        let global_variables: HashSet<_> = problem
            .prelude
            .function_declarations
            .iter()
            .map(|var| pool.add(var.clone().into()))
            .collect();

        let mut ctx = Context::default();

        ctx.global_variables = global_variables;

        let res = translate_commands(&mut ctx, &mut proof.iter(), &mut pool, |id, t, ps| {
            let modifier = ps.is_some().then(|| Modifier::Opaque);
            Command::Symbol(
                modifier,
                normalize_name(id),
                vec![],
                t,
                ps.map(|ps| Proof(ps)),
            )
        })
        .expect("translate trans");

        let t3 = res.last().unwrap().clone();

        //println!("{}", t3);
    }
}
