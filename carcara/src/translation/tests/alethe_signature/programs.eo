(include "./theory.eo")

;; Library of auxiliary programs, useful to manipulate propositions.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLAUSES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Removes the top @cl if any
(program from_cl ((T Bool))
    (Bool) Bool
    (
        ((from_cl (@cl T)) T)
        ((from_cl T) T)
    )
)

; Add a @cl if there is none
(program to_cl ((T Bool))
    (Bool) Bool
    (
        ((to_cl (@cl T)) (@cl T))
        ((to_cl T) (@cl T))
    )
)

;TODO
(program contains ((inList Bool) (phi Bool))
  (Bool Bool) Bool
  (
   ((contains inList phi) true)
  )
)

;TODO true if CL2 is a permuation of CL1
(program clEqual ((CL1 Bool) (CL2 Bool))
  (Bool Bool) Bool
  (
   ((clEqual CL1 CL2) true)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CONJUNCTIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: could we define something more generic, to totally replace eo::list_nth?
; define: index_conjunction
; args:
; - conjunction Bool: A conjunction of terms to be indexed, built with "and".
; - index Int: >
;   An integer, from 0 to the number of conjunctions - 1 in "conjunction".
; return: The conjunct number "index".
(program index_conjunction ((conjunction Bool) (index Int))
  (Bool Int) Bool
  (
   ((index_conjunction conjunction index)       
    (eo::list_nth and conjunction index))
  )
)

; TODO: see if we can pass the proposition constructor as an argument
; define: index_disjunction
; args:
; - disjunction Bool: A disjunction of terms to be indexed, built with "and".
; - index Int: >
;   An integer, from 0 to the number of disjunctions - 1 in "disjunction".
; return: The conjunct number "index".
(program index_disjunction ((disjunction Bool) (index Int))
  (Bool Int) Bool
  (
   ((index_disjunction disjunction index)       
    (eo::list_nth or disjunction index))
  )
)
