(include "./theory.eo")

;; Library of auxiliary programs, useful to manipulate propositions.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLAUSES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; program: from_cl
; args:
; - T Bool: A proposition.
; return: >
;   For a unit clause, built with @cl, removes the top @cl if 
;   any, returning the only disjunct. Otherwise, returns T.
(program from_cl ((T Bool))
    (Bool) Bool
    (
        ((from_cl (@cl T)) T)
        ((from_cl T) T)
    )
)

; program: to_cl
; args:
; - T Bool: A proposition.
; return: >
;   Embeds T within a unit clause built with @cl, only
;   if T is not a unit clause built with @cl itself. 
(program to_cl ((T Bool))
    (Bool) Bool
    (
        ((to_cl (@cl T)) (@cl T))
        ((to_cl T) (@cl T))
    )
)

; program: cl_contains_prop
; args:
; - phi Bool: A proposition.
; - clause Bool: A clause, built with @cl.
; return: A boolean indicating if "phi" is a disjunct from "clause".
(program cl_contains_prop ((phi Bool) (hd Bool) (tl Bool :list))
  (Bool Bool) Bool
  (
   ((cl_contains_prop phi (@cl phi tl)) true)

   ;; { head of list is not phi}
   ((cl_contains_prop phi (@cl hd tl)) (cl_contains_prop phi tl))

   ((cl_contains_prop phi phi) true)

   ;; { hd != phi}
   ((cl_contains_prop phi hd) false)
  )
)

; program: cl_contains_cl
; args:
; - cl_1 Bool: A clause, built with @cl.
; - cl_2 Bool: A clause, built with @cl.
; return: >
;   A boolean indicating if cl_1's disjuncts are also present
;   in cl_2
(program cl_contains_cl ((hd Bool) (tl Bool :list) (cl_2 Bool))
  (Bool Bool) Bool
  (
   ((cl_contains_cl (@cl hd tl) cl_2)
    ;; TODO: I need some way to build boolean values
    ;; combining other boolean values, but I would like
    ;; to avoid built-in operators.
    (eo::and (cl_contains_prop hd cl_2)
             (cl_contains_cl tl cl_2)))

 
   ;; { cl_1 is not a clause built with @cl }
   ((cl_contains_cl hd cl_2)
    (cl_contains_prop hd cl_2))
  )
)

; program: cl_equal
; args:
; - cl_1 Bool: A clause, built with @cl.
; - cl_2 Bool: A clause, built with @cl.
; return: >
;   A boolean indicating if cl_1 and cl_2 are equal modulo permutations.
(program cl_equal ((cl_1 Bool) (cl_2 Bool))
  (Bool Bool) Bool
  (
   ((cl_equal cl_1 cl_2) (eo::and (cl_contains_cl cl_1 cl_2)
                                  (cl_contains_cl cl_2 cl_1)))
  )
)

; program: convert_or_to_cl
; args:
; - or_clause Bool : >
;   Clause to convert, built with the "or" operator.
; - accum Bool : Partial result accumulator
; return: >
;   A clause equivalent to "or_clause", built exclusively with @cl.
(program convert_or_to_cl ((or_clause Bool) (disjunct_1 Bool) (disjunct_2 Bool))
  (Bool) Bool
  (((convert_or_to_cl (or disjunct_1 disjunct_2))
    (@cl disjunct_1 (from_cl (convert_or_to_cl disjunct_2))))

   ; { disjunct_1 is not built with "or" }
   ((convert_or_to_cl disjunct_1)
    (@cl disjunct_1))
   )
)

; program: transform_not_and
; args:
; - ls Bool: A conjunction of terms.
; return: >
;   Applies De Morgan's law over the conjuncts of "ls", returning a new clause
;   built with @cl.
(program transform_not_and ((l Bool) (ls Bool))
  (Bool) Bool
  (
   ((transform_not_and (and l ls))
    (@cl (not l) (from_cl (transform_not_and ls)))
    )

   ((transform_not_and l) (@cl (not l)))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; List computations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; define: index_list
; args:
; - cons (-> A A A): >
;   Right/left assoc. operator used to construct the given cons-list
;   (see definition of f-list, for a given operator f, in ethos
;   manual: https://github.com/cvc5/ethos/blob/main/user_manual.md#list-computations)
; - list (A): A cons-list: a term of the form (cons t1 ... tn)
; - index Int: >
;   An integer, from 0 to the number of parameters - 1 in (cons t1 ... tn) 
;   (i.e., "list)
; return: The parameter number "index" - 1, from (cons t1 ... tn) (i.e., "list")
(program index_list ((A Type) (cons (-> A A A)) (hd A) (tail (-> A A)) (index Int))
  ((-> A A A) A Int) A
  (
   ((index_list cons (cons hd tail) 0) hd)

   ;; { index > 0 }
   ((index_list cons (cons hd tail) index)
    ;; TODO: using eo::add
    (index_list cons tail (eo::add index -1)))
  )
)
