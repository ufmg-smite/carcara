(include "./theory.eo")

;; Library of auxiliary programs, useful to manipulate propositions.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; f-lists computations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; define: f_list_index
; args:
; - f (-> A A A): >
;   Right/left assoc. operator used to construct the given f-list
;   (see definition of f-list, for a given operator f, in ethos
;   manual: https://github.com/cvc5/ethos/blob/main/user_manual.md#list-computations)
; - list (A): An f-list: a term of the form (f t1 ... tn)
; - index Int: >
;   An integer, from 0 to the number of parameters - 1 in (f t1 ... tn) 
;   (i.e., "list)
; return: The parameter number "index", from (f t1 ... tn) (i.e., "list")
(program f_list_index ((A Type) (f (-> A A A)) (hd A) (tail A :list) (index Int))
  ((-> A A A) A Int) A
  (
   ((f_list_index f (f hd tail) 0) hd)

   ;; { index > 0 }
   ((f_list_index f (f hd tail) index)
    ;; TODO: using eo::add
    (f_list_index f tail (eo::add index -1)))
  )
)

; program: f_list_contains_elem
; args:
; - f (-> A A A): Operator used to build the f-list.
; - elem A: Some element of type A, for which we want to test membership.
; - list A: An f-list.
; return:
; A boolean indicating if "elem" appears in f-list "list".
(program f_list_contains_elem ((A Type) (f (-> A A A))
                               (elem A) (hd A) (tl A :list))
  ((-> A A A) A A) Bool
  (
   ((f_list_contains_elem f elem (f elem tl))

    true)

   ; { hd =/= elem}
   ((f_list_contains_elem f elem (f hd tl))

    (f_list_contains_elem f elem tl))

   ; { elem is not an f-list}
   ((f_list_contains_elem f elem elem)

    true)
   
   ((f_list_contains_elem f elem hd)

    false)
  )
)

; program: f_list_contains_elem
; args:
; - f (-> A A A): Operator used to build the f-list.
; - list_1 A: An f-list.
; - list_2 A: An f-list.
; return:
; A boolean indicating if the elements from list_1 also appear in list_2.
(program f_list_contains_f_list ((A Type) (f (-> A A A))
                                 (hd A) (tl A :list)
                                 (f_list_2 A))
  ((-> A A A) A A) Bool
  (
   ((f_list_contains_f_list f (@cl hd tl) f_list_2)
    ;; TODO: I need some way to build boolean values
    ;; combining other boolean values, but I would like
    ;; to avoid built-in operators.
    (eo::and (f_list_contains_elem f hd f_list_2)
             (f_list_contains_f_list f tl f_list_2)))

 
   ;; { f_list_1 is not a term built with f }
   ((f_list_contains_f_list f hd f_list_2)
    (f_list_contains_elem f hd f_list_2))
  )
)

; program: f_list_equal
; args:
; - f (-> A A A): Operator used to build the f-list.
; - list_1 A: An f-list.
; - list_2 A: An f-list.
; return: >
; A boolean indicating if the operands from list_1 and list_2 are the 
; same, regardless of the order.
(program f_list_equal ((A Type) (f (-> A A A))
                       (f_list_1 A) (f_list_2 A))
  ((-> A A A) A A) Bool
  (
   ((f_list_equal f f_list_1 f_list_2)
    (eo::and (f_list_contains_f_list f f_list_1 f_list_2)
             (f_list_contains_f_list f f_list_2 f_list_1)))
  )
)

; program: f_list_concat
; args:
; - f (-> A A A): Operator used to build the f-list.
; - elem A: An element of type A.
; - flist A: An f-list.
; return: >
; Returns an f-list, with first operand "elem", followed by operands of flist_2.
(define f_list_cons ((A Type :implicit) (f (-> A A A)) (elem A)
                   (tail A :list))
    (f elem tail)
)

;; (program f_list_cons ((A Type :implicit) (f (-> A A A))
;;                       (elem A)
;;                       (hd_2 A) (tl_2 A :list))
;;   ((-> A A A) A A) A
;;   (
;;    ((f_list_cons f elem (f hd_2 tl_2))

;;     (f elem (f hd_2 tl_2)))
   
;;    ((f_list_cons f elem hd_2)

;;     (f elem hd_2))
;;   )
;; )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLAUSES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; program: from_cl
; args:
; - T Bool: A proposition.
; return: >
;   For a unit clause, built with @cl, removes the top @cl if 
;   any, returning the only disjunct. Otherwise, returns T.
(program from_cl ((T Bool))
    (Bool) Bool
    (
        ((from_cl (@cl T)) T)
        ((from_cl T) T)
    )
)

; program: to_cl
; args:
; - T Bool: A proposition.
; return: >
;   Embeds T within a unit clause built with @cl, only
;   if T is not a unit clause built with @cl itself. 
(program to_cl ((T Bool))
    (Bool) Bool
    (
        ((to_cl (@cl T)) (@cl T))
        ((to_cl T) (@cl T))
    )
)

; TODO: is it ok?
; program: prop_syntax_eq
; args:
; - phi_1 Bool: A proposition.
; - phi_2 Bool: A proposition.
; return: A boolean indicating if phi_1 and phi_2 are syntactically equal.
(program prop_syntax_eq ((phi Bool))
  (Bool Bool) Bool
  (
   ((prop_syntax_eq phi phi) true)

   ((prop_syntax_eq _ _) false)
   )
)

; program: cl_equal
; args:
; - cl_1 Bool: A clause, built with @cl.
; - cl_2 Bool: A clause, built with @cl.
; return: >
;   A boolean indicating if cl_1 and cl_2 are equal modulo permutations.
(program cl_equal ((cl_1 Bool) (cl_2 Bool))
  (Bool Bool) Bool
  (
   ((cl_equal cl_1 cl_2)
    (f_list_equal @cl cl_1 cl_2))
  )
)

; program: convert_or_to_cl
; args:
; - or_clause Bool : >
;   Clause to convert, built with the "or" operator.
; - accum Bool : Partial result accumulator
; return: >
;   A clause equivalent to "or_clause", built exclusively with @cl.
(program convert_or_to_cl ((or_clause Bool) (disjunct_1 Bool) (disjunct_2 Bool :list))
  (Bool) Bool
  (((convert_or_to_cl (or disjunct_1 disjunct_2))
    (f_list_cons @cl disjunct_1 (convert_or_to_cl disjunct_2)))
   ; { disjunct_1 is not built with "or" }
   ((convert_or_to_cl disjunct_1)
    disjunct_1))
)

; program: transform_not_and
; args:
; - ls Bool: A conjunction of terms.
; return: >
;   Applies De Morgan's law over the conjuncts of "ls", returning a new clause
;   built with @cl.
(program de_morgan_not_and ((l Bool) (ls Bool))
  (Bool) Bool
  (
   ((de_morgan_not_and (and l ls))
    (@cl (not l) (from_cl (de_morgan_not_and ls)))
    )

   ((de_morgan_not_and l) (@cl (not l)))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; implication
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; program: rewrite_implication
; args:
; - implication Bool: >
;   An implication over which we want to apply simplifying rewrites.
; return:
;   A proposition that is equivalent to "implication", but that is
;   not built with =>.
(program rewrite_implication ((phi_1 Bool) (phi_2 Bool))
         (Bool) Bool
         (; We apply semantics preserving rewrites.
          ((rewrite_implication (=> (not phi_1) (not phi_2)))
          
          (rewrite_implication (=> phi_2 phi_1)))

          
          ((rewrite_implication (=> false phi_1))
          
          true)

          ((rewrite_implication (=> phi_1 true))
          
          true)

          ((rewrite_implication (=> true phi_1))
          
          phi_1)

          ((rewrite_implication (=> phi_1 false))
          
          (not phi_1))

          ((rewrite_implication (=> phi_1 phi_1))
          
          true)

          ((rewrite_implication (=> (not phi_1) phi_1))
          
          phi_1)

          ((rewrite_implication (=> (not phi_1) (not phi_1)))
          
          (not phi_1))
          )
)

; program: rewrite_equivalence
; args:
; - equivalence Bool: >
;   An equivalence over which we want to apply simplifying rewrites.
; return:
;   A proposition that is equivalent to "equivalence", but that is
;   not built with =.
(program rewrite_equivalence ((phi_1 Bool) (phi_2 Bool))
         (Bool) Bool
         (; We apply semantics preserving rewrites.
          ((rewrite_equivalence (= (not phi_1) (not phi_2)))
          
          (rewrite_equivalence (= phi_2 phi_1)))

          
          ((rewrite_equivalence (= phi_1 phi_1))
          
          true)

          ((rewrite_equivalence (= phi_1 (not phi_1)))
          
          false)

          ((rewrite_equivalence (= (not phi_1) phi_1))
          
          false)

          ((rewrite_equivalence (= true phi_1))
          
          phi_1)

          ((rewrite_equivalence (= phi_1 true))
          
          phi_1)

          ((rewrite_equivalence (= phi_1 false))
          
          (not phi_1))

          ((rewrite_equivalence (= false phi_1))
          
          (not phi_1))

          )
)
