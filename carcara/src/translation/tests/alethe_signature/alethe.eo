(include "./theory.eo")
(include "./programs.eo")

; Rule: assume is native

; TODO: what would the checker do in this case?
(program check_hole ((conclusion Bool))
    (Bool) Bool
    (
    ((check_hole conclusion) true)
    )
)

; Note: The hole here does not allow for args or premises.
(declare-rule hole ()
  :requires (((check_hole eo::conclusion) true))
  :conclusion-given
)

(declare-rule true ()
  :args ((@cl true))
  :conclusion (@cl true)
)

(program check_false ((conclusion Bool))
    (Bool) Bool
    (
    ((check_false (@cl (not false))) true)
    )
)

(declare-rule false ()
  :requires (((check_false eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 5: not_not
;;;;;;;;;;;;;;;;;;;;;;;

; program: check_not_not
; args:
; - conclusion Bool: Conclusion given to rule not_not.
; return: >
;   A boolean indicating if conclusion is equivalent to the proposition
;   ¬¨(¬¨¬¨ùúë), ùúë, for some proposition ùúë
(program check_not_not ((phi Bool))
    (Bool) Bool
    (
    ((check_not_not (@cl (not (not (not phi))) phi)) true)
    ((check_not_not (@cl phi (not (not (not phi))))) true)
    )
)

; rule: not_not
; implements: TODO?
; requires: >
;   The conclusion should be equivalent to the proposition
;   ¬¨(¬¨¬¨ùúë), ùúë, for some proposition ùúë
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_not ()
  :requires (((check_not_not eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 6: th_resolution
;;;;;;;;;;;;;;;;;;;;;;;
; TODO
(program check_resolution ((Cs Bool) (CL Bool))
  (Bool Bool) Bool
  (
   ((check_resolution Cs CL) true)
  )
)

(declare-rule th_resolution ((Cs Bool))
  :premise-list Cs and
  :requires (((check_resolution Cs eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 7: resolution
;;;;;;;;;;;;;;;;;;;;;;;

;TRUST
(declare-rule resolution ((Cs Bool))
  :premise-list Cs and
  :requires (((check_resolution Cs eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_tautology ((CL1 Bool))
  (Bool) Bool
  (
   ((check_tautology CL1) true)
  )
)

;TRUST
(declare-rule tautology ((CL1 Bool))
  :premises (CL1)
  :args ((@cl true))
  :requires (((check_tautology CL1) true))
  :conclusion (@cl true)
)

;TODO
(program check_contraction ((CL1 Bool) (CL Bool))
  (Bool Bool) Bool
  (
   ((check_contraction CL1 CL) true)
  )
)

;TRUST
(declare-rule contraction ((CL1 Bool))
  :premises (CL1)
  :requires (((check_contraction CL1 eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_subproof ((Premises Bool) (Conclusion Bool) (Conclusion_given Bool))
  (Bool Bool Bool) Bool
  (
   ((check_subproof Premises Conclusion Conclusion_given) true)
  )
)

;TODO: test if the list here works well
(declare-rule subproof ((F Int) (G Bool))
  ; TODO: why is it an assumption?
  :assumption F ;has no cl!
  :premises (G)
  :requires (((check_subproof (not F) G eo::conclusion) true))
  :conclusion-given
)

;TODO
; From "The Alethe Proof Format":
; "Checking the validity of this clause amounts to checking the unsatisfiability 
; of the system of linear equations ùúë1, ùúë2, ‚Ä¶ , ùúëùëõ. The annotation of an 
; la_generic step contains a coefficient for each (in)equality. The result of 
; forming the linear combination of the literals with the coefficients is a trivial 
; inequality between constants".
(program check_la_generic ((coeffs Real) (CL Bool))
  (Real Bool) Bool
  (
   ((check_la_generic coeffs CL) true)
  )
)

; NOTE: The coefficients are one single argument.  This means they must be
;       be wrapped in a single function call using an n-ary function.  See
;       the example `small.smt3`.
;TRUST
(declare-rule la_generic ((coeffs Real))
  :args (coeffs)
  :requires (((check_la_generic coeffs eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_lia_generic ((CL Bool))
  (Bool) Bool
  (
   ((check_lia_generic CL) true)
  )
)

;TRUST
(declare-rule lia_generic ((CL Bool))
  :args (CL)
  :requires (((check_lia_generic CL) true))
  :conclusion CL
)

(declare-rule la_disequality ((t1 Real) (t2 Real))
  :args ((@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1)))))
  :conclusion (@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1))))
)

(declare-rule la_totality ((t1 Real) (t2 Real))
  :args ((@cl (or (<= t1 t2) (<= t2 t1))))
  :conclusion (@cl (or (<= t1 t2) (<= t2 t1)))
)

;TODO
(program check_la_tautology ((CL Bool))
  (Bool) Bool
  (
   ((check_la_tautology CL) true)
  )
)

;TRUST
(declare-rule la_tautology ((CL Bool))
  :args (CL)
  :requires (((check_la_tautology CL) true))
  :conclusion CL
)

;TODO
(program check_la_mult_neg ((CL Bool))
  (Bool) Bool
  (
   ((check_la_mult_neg CL) true)
  )
)

;TRUST
(declare-rule la_mult_neg ()
  :requires (((check_la_mult_neg eo::conclusion) true))
  :conclusion-given
)

; NOTE: Rules like `bind` can have multiple forms: without and with
; @var.  In the first case the bind rule is
;                @var xs. œÜ = @var ys. œÜ'
;              --¬≠¬≠------¬≠¬≠¬≠¬≠¬≠------------¬≠ bind
;                   ‚àÄ xs. œÜ = ‚àÄ ys. œÜ'
; This means that the variable that are free in the premise get bound by
; a @var.  However, since `bind` and other context-extending steps can
; be nested, it could also have the form
;              @var xs‚ÇÅ ‚à™ xs‚ÇÇ. œÜ = @var ys‚ÇÅ ‚à™ ys‚ÇÇ. œÜ'
;        --¬≠¬≠¬≠¬≠¬≠¬≠¬≠--------------------------------¬≠ bind
;             @var xs‚ÇÅ. ‚àÄ xs‚ÇÇ. œÜ = @var ys‚ÇÅ. ‚àÄ ys‚ÇÇ. œÜ'
; In situations where `bind` is combined with rules like `sko_ex`, the
; @var could occur on only one side.
; Since this signature would check the binders in the side condition,
; the binders are invisible here.
; This affects the rules `bind`, `sko_ex`, `sko_forall`, `let`,
; and `onepoint`.

;TODO
(program check_bind ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  (Bool T T T T) Bool
  (
   ((check_bind ctx l r l1 r1) true)
  )
)

;TRUST
(declare-rule bind ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  ;:premises (old_ctx (@cl (= l1 r1))) ; this is never a direct assumption
  ;; :premises (old_ctx) ; TODO: fix this
  ;; :requires (((context_extended cztx old_ctx) true) ((check_bind ctx l r l1 r1) true))
  ;; :requires (((context_extended ctx old_ctx) true) 
  ;;            ;; ((check_bind ctx l r l1 r1) true)
  ;;            )
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 19: sko_ex
;;;;;;;;;;;;;;;;;;;;;;;
; TODO: to preserve previous def.
;; (program check_sko_ex ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
;;   (Bool T T T T) Bool
;;   (
;;    ((check_sko_ex ctx l r l1 r1) true)
;;   )
;; )

;; ;TRUST
;; (declare-rule sko_ex ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
;;   :assumption ctx
;;   :premises (old_ctx (@cl (= l1 r1)))
;;   :args ((@cl (= l r)))
;;   :requires (((context_extended ctx old_ctx) true) ((check_sko_ex ctx l r l1 r1) true))
;;   :conclusion (@cl (= l r))
;; )

(program check_sko_ex ((conclusion Bool))
  (Bool) Bool
  (
   ((check_sko_ex conclusion) true)
  )
)

;TRUST
(declare-rule sko_ex ((ctx Bool))
  :assumption ctx
  :requires (((check_sko_ex eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_sko_forall ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  (Bool T T T T) Bool
  (
   ((check_sko_forall ctx l r l1 r1) true)
  )
)

;TRUST
(declare-rule sko_forall ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  :premises (old_ctx (@cl (= l1 r1)))
  :args ((@cl (= l r)))
  :requires (((context_extended ctx old_ctx) true) ((check_sko_forall ctx l r l1 r1) true))
  :conclusion (@cl (= l r))
)

;TODO: changing this for the tests to pass!
(program check_forall_inst ((Conclusion Bool))
  (Bool) Bool
  (
   ((check_forall_inst Conclusion) true)
  )
)

;TRUST
;TODO: changing this for the tests to pass!
(declare-rule forall_inst ()
  :requires (((check_forall_inst eo::conclusion) true))
  :conclusion-given
)

;TODO: why is type T not mentioned in the body of check_refl?
(program check_refl ((ctx Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_refl ctx conclusion) true)
  )
)

;TRUST
(declare-rule refl ((ctx Bool))
  :args (ctx)
  :requires (((check_refl ctx eo::conclusion) true))
  :conclusion-given
)

(program last_eq_right ((T Type) (t1 T) (t2 T) (eqs Bool))
  (Bool) Bool
  (; TODO: not clear why we need to consider all of these different scenarios
   ; (with and without and)
   ((last_eq_right (@cl (= t1 t2))) t2)

   ((last_eq_right (and (@cl (= t1 t2)))) t2)
    ((last_eq_right (and (@cl (= t1 t2)) eqs)) (last_eq_right eqs))
   ; TODO: are they always clauses? (seems that it is not the
   ; case if the premises where just "assume"s)
    ((last_eq_right (and (= t1 t2))) t2)
    ((last_eq_right (and (= t1 t2) eqs)) (last_eq_right eqs))
  )
)

(program make_trans ((T Type) (t1 T) (t2 T) (eqs Bool :list))
  (Bool) Bool
  (((make_trans (and (@cl (= t1 t2)))) (= t1 t2))
   ((make_trans (and (@cl (= t1 t2)) eqs)) (= t1 (last_eq_right eqs)))
   ; TODO: if they are 'assume's, they could be term not built with @cl
   ((make_trans (and (= t1 t2))) (= t1 t2))
   ((make_trans (and (= t1 t2) eqs)) (= t1 (last_eq_right eqs)))
  )
)

;TODO what about scopes here? can a premise come from an outers scope
;TODO: implement mkTrans
(declare-rule trans ((Eqs Bool))
  :premise-list Eqs and
  ; TODO: is this correct?
  ;; (((check_cong Eqs eo::conclusion) true))
  ; TODO: add remaining cases in make_trans
  ;; :requires (((@cl (make_trans Eqs)) eo::conclusion))
  :conclusion-given
)

;TODO
(program check_cong ((Eqs Bool) (CEq Bool))
  (Bool Bool) Bool
  (
   ((check_cong Eqs CEq) true)
  )
)

;TRUST
;; (declare-rule cong ((Eqs Bool) (CEq Bool))
(declare-rule cong ((Eqs Bool))
  :premise-list Eqs and
  ;; :args ((@cl CEq)) ; CEq is an equality
  :requires (((check_cong Eqs eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_eq_reflexive ((conclusion Bool))
  (Bool) Bool
  (
   ((check_eq_reflexive conclusion) true)
  )
)
; TODO: to preserve previous attempt
;; (declare-rule eq_reflexive ((T Type) (t T))
;;   :args ((@cl (= t t)))
;;   :conclusion (@cl (= t t))
;; )

(declare-rule eq_reflexive ()
  :requires (((check_eq_reflexive eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_eq_transitive ((conclusion Bool))
  (Bool) Bool
  (
   ((check_eq_transitive conclusion) true)
  )
)

;TRUST
(declare-rule eq_transitive ()
  :requires (((check_eq_transitive eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_eq_congruent ((conclusion Bool))
  (Bool) Bool
  (
   ((check_eq_congruent conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent ()
  :requires (((check_eq_congruent eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_eq_congruent_pred ((conclusion Bool))
  (Bool) Bool
  (
   ((check_eq_congruent_pred conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent_pred ()
  :requires (((check_eq_congruent_pred eo::conclusion) true))
  :conclusion-given
)

;TODO: to preserve previous def
;; 
;; (program check_qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;;   (@VarList Bool @VarList Bool) Bool
;;   (
;;    ((check_qnt_cnf xs phi xsP phiP) true)
;;   )
;; )

;; ;TRUST
;; (declare-rule qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;;   :args ((@cl (or (not (forall xs phi)) (forall xsP phiP))))
;;   :requires (((check_qnt_cnf xs phi xsP phiP) true))
;;   :conclusion (@cl (or (not (forall xs phi)) (forall xsP phiP)))
;; )

;TODO
(program check_qnt_cnf ((conclusion Bool))
  (Bool) Bool
  (
   ((check_qnt_cnf conclusion) true)
  )
)

;TRUST
(declare-rule qnt_cnf ()
  :requires (((check_qnt_cnf eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table 7: Clausification rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Rule 30: and
;;;;;;;;;;;;;;;;;;

; program: check_and
; args:
; - premise Bool       : >
;   Premise of the "and" rule: a conjunction of terms. 
;   It could be embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from 
;   "premise", with index "index".
(program check_and ((premise Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  (((check_and premise index conclusion)
    (cl_equal (to_cl (f_list_index and (from_cl premise) index))
               conclusion))
  )
)

; TODO: this overloads PandP
; rule: and
; premises:
; - premise: The conjunctions over which "and elimination" is applied.
; args:
; - index Int: >
;   The index of the conjunct being selected. 0 <= index <= number of conjuncts - 1.
; requires: >
;   The conclusion should be one conjunct from the premise,
;   in the position indicated by index.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and ((premise Bool) (index Int))
  :premises (premise)
  :args (index)
  :requires (((check_and premise index eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 31: not_or
;;;;;;;;;;;;;;;;;;

; program: check_not_or
; args:
; - premise Bool       : >
;   Premise of the "not_or" rule: a negation of a disjunction of terms.
;   It could be embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from "premise" (after
;   applying DeMorgan's law), in position "index".
(program check_not_or ((disjuncts Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  (;; To facilitate the use of the program, we allow 
   ;; the presence of a @cl constructor
   ((check_not_or (@cl premise_non_cl) index conclusion)
    (check_not_or premise_non_cl index conclusion))

   ((check_not_or (not disjuncts) index conclusion)
    (cl_equal (to_cl (not (f_list_index or disjuncts index)))
               conclusion))
   )
)

; rule: not_or
; premises:
; - premise: The negated disjunction over which "not_or" is applied.
; args:
; - index Int: The index of the conjunct being selected.
;              0 <= index <= number of conjuncts - 1
; requires: >
;   The conclusion should be one disjunct from the result
;   of applying DeMorgan's rule over the premise. The disjunct
;   position must correspond to what is specified by the index
;   parameter
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_or ((premise Bool) (index Int))
  :premises (premise)
  :args (index)
  :requires (((check_not_or premise index eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 32: or
;;;;;;;;;;;;;;;;;;

; program: check_or
; args:
; - premise Bool: >
;   Premise of the "or" rule: a disjunction of terms, built with "or" operator. 
;   It could be embedded within a single-term clause built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is equivalent to "premise", but built 
;   with @cl.
(program check_or ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (((check_or (@cl premise) conclusion)
    (cl_equal (convert_or_to_cl premise)
               conclusion)
    )

   ; { premise is not built with @cl }
   ((check_or premise conclusion)
    (cl_equal (convert_or_to_cl premise) conclusion))
  )
)

; rule: or
; premises:
; - premise: >
;   The clause, built with the "or" operator, over which the rule is applied. 
;   It could be embedded within a single-term clause built with @cl.
; requires: >
;   The conclusion should be a clause equivalent to "premise", 
;   but built with @cl.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or ((premise Bool))
  :premises (premise)
  :requires (((check_or premise eo::conclusion) true))
  :conclusion-given 
)

;;;;;;;;;;;;;;;;;;
; Rule 37: not_and
;;;;;;;;;;;;;;;;;;

; program: check_not_and
; args:
; - premise Bool: Premise of the not_and rule: a negated conjunction of propositions.
; - conclusion Bool: >
;   The conclusion provided to the not_and rule.
; return: >
;   A boolean indicating if "conclusion" is a clause built with
;   @cl, where each disjunct is negated and corresponds to some conjunct from
;   "premise".
(program check_not_and ((conjunction Bool) (conclusion Bool))
  (Bool Bool) Bool
  (((check_not_and (not conjunction) conclusion)
     (cl_equal (de_morgan_not_and conjunction) conclusion)
     )
  )
)

; rule: not_and
; premises:
; - premise Bool: >
;  The premise clause: a negated conjunction of propositions.
; requires: >
;  For "conclusion" to be a clause built with @cl, that results from applying
;  DeMorgan's rule over "premise".
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_and ((premise Bool))
  :premises (premise)
  :requires (((check_not_and (from_cl premise) eo::conclusion) true))
  :conclusion-given
)

(program check_xor1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_xor1 (@cl (xor phi1 phi2)) refCL)
     (cl_equal (@cl phi1 phi2) refCL)
   )
   ((check_xor1 (xor phi1 phi2) refCL)
     (cl_equal (@cl phi1 phi2) refCL)
   )
  )
)

(declare-rule xor1 ((CL Bool))
  :premises (CL)
  :requires (((check_xor1 CL eo::conclusion) true))
  :conclusion-given
)

(program check_xor2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_xor2 (@cl (xor phi1 phi2)) refCL)
     (cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
   ((check_xor2 (xor phi1 phi2) refCL)
     (cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
  )
)

(declare-rule xor2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_xor2 CL refCL) true))
  :conclusion refCL
)

(program check_not_xor1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_xor1 (@cl (xor phi1 phi2)) refCL)
     (cl_equal (@cl phi1 (not phi2)) refCL)
   )
   ((check_not_xor1 (xor phi1 phi2) refCL)
     (cl_equal (@cl phi1 (not phi2)) refCL)
   )
  )
)

(declare-rule not_xor1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_xor1 CL refCL) true))
  :conclusion refCL
)


(program check_not_xor2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_xor2 (@cl (xor phi1 phi2)) refCL)
     (cl_equal (@cl (not phi1) phi2) refCL)
   )
   ((check_not_xor2 (xor phi1 phi2) refCL)
     (cl_equal (@cl (not phi1) phi2) refCL)
   )
  )
)

(declare-rule not_xor2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_xor2 CL refCL) true))
  :conclusion refCL
)

;;;;;;;;;;;;;;;;;;
; Rule 41: implies
;;;;;;;;;;;;;;;;;;

; program: check_implies
; args:
; - premise Bool: >
;   Premise of the implies rule. Should be an implication,
;   built with the => constructor. The premise could be embedded
;   within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   of the "premise" implication (i.e., "not antecedent or consequent" form).
(program check_implies ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_implies (@cl (=> phi1 phi2)) conclusion)
     (cl_equal (@cl (not phi1) phi2) conclusion)
   )
   ((check_implies (=> phi1 phi2) conclusion)
     (cl_equal (@cl (not phi1) phi2) conclusion)
   )
  )
)

; rule: implies
; implements: TODO?
; premises:
; - premise Bool: >
;   Premise of the implies rule. Should be an implication,
;   built with the => constructor. The premise could be embedded
;   within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication given as premise of the rule.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies ((premise Bool))
  :premises (premise)
  :requires (((check_implies premise eo::conclusion) true))
  :conclusion-given
)

(program check_not_implies1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_implies1 (@cl (not (=> phi1 phi2))) refCL)
     (cl_equal (@cl phi1) refCL)
   )
   ((check_not_implies1 (not (=> phi1 phi2)) refCL)
     (cl_equal (@cl phi1) refCL)
   )
  )
)

(declare-rule not_implies1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_implies1 CL refCL) true))
  :conclusion refCL
)

(program check_not_implies2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_implies2 (@cl (not (=> phi1 phi2))) refCL)
     (cl_equal (@cl phi1) refCL)
   )
   ((check_not_implies2 (not (=> phi1 phi2)) refCL)
     (cl_equal (@cl phi1) refCL)
   )
  )
)

(declare-rule not_implies2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_implies2 CL refCL) true))
  :conclusion refCL
)

;;;;;;;;;;;;;;;;;;
; Rule 44: equiv1
;;;;;;;;;;;;;;;;;;

; program: check_equiv1
; args:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   (i.e., "not antecedent or consequent" form) of the implication 
;   phi1 => phi2.
(program check_equiv1 ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_equiv1 (@cl (= phi1 phi2)) conclusion)
     (cl_equal (@cl (not phi1) phi2) conclusion)
   )
   ((check_equiv1 (= phi1 phi2) conclusion)
     (cl_equal (@cl (not phi1) phi2) conclusion)
   )
  )
)

; rule: equiv1
; implements: TODO?
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi1 => phi2.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
; conclusion:
(declare-rule equiv1 ((premise Bool))
  :premises (premise)
  :requires (((check_equiv1 premise eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 45: equiv2
;;;;;;;;;;;;;;;;;;

; program: check_equiv2
; args:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule.
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   (i.e., "not antecedent or consequent" form) of the implication 
;   phi2 => phi1.
(program check_equiv2 ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_equiv2 (@cl (= phi1 phi2)) conclusion)
     (cl_equal (@cl phi1 (not phi2)) conclusion)
   )
   ((check_equiv2 (= phi1 phi2) conclusion)
     (cl_equal (@cl phi1 (not phi2)) conclusion)
   )
  )
)

; rule: equiv2
; implements: TODO?
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi2 => phi1.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
; conclusion:
(declare-rule equiv2 ((premise Bool))
  :premises (premise)
  :requires (((check_equiv2 premise eo::conclusion) true))
  :conclusion-given
)

(program check_not_equiv1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_equiv1 (@cl (not (= phi1 phi2))) refCL)
     (cl_equal (@cl phi1 phi2) refCL)
   )
   ((check_not_equiv1 (not (= phi1 phi2)) refCL)
     (cl_equal (@cl phi1 phi2) refCL)
   )
  )
)

(declare-rule not_equiv1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_equiv1 CL refCL) true))
  :conclusion refCL
)

;;;;;;;;;;;;;;;;;;
; Rule 48: and_pos
;;;;;;;;;;;;;;;;;;

; program: check_and_pos
; args:
; - pos Int: Position of the selected conjunct. 
;            0 <= pos <= number of conjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, where the antecedent is 
;   a conjunction.
(program check_and_pos ((pos Int) (antecedent Bool) (consequent Bool))
  (Int Bool) Bool
  (
   ((check_and_pos pos (@cl (not antecedent) consequent))
    (cl_equal (f_list_index and antecedent pos) consequent))

   ;; To simplify the use of the checker
   ((check_and_pos pos (@cl consequent (not antecedent)))
    (cl_equal (f_list_index and antecedent pos) consequent))
  )
)

;TRUST
; rule: and_pos
; implements: TODO?
; args:
; - pos Int: Position of the conjunct selected in the weakening. 
;            0 <= pos <= number of conjuncts - 1
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of an instance of the weakening rule for implication,
;   where the antecedent is a conjunction.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and_pos ((pos Int))
  :args (pos)
  :requires (((check_and_pos pos eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 49: and_neg
;;;;;;;;;;;;;;;;;;

; program: check_and_neg
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of and_neg. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
(program check_and_neg ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   ((check_and_neg (@cl left_disjunct right_disjunct))
    (cl_equal (de_morgan_not_and left_disjunct)
              right_disjunct))
  )
)

; rule: and_neg
; implements: TODO?
; requires: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and_neg ()
  :requires (((check_and_neg eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 50: or_pos
;;;;;;;;;;;;;;;;;;

; program: check_or_pos
; args:
; - conclusion Bool: >
;   Conclusion given to rule or_pos. It is expected to be built with @cl.
; return: >
;   A boolean indicating if conclusion is of the form
;   ¬¨(ùúë1 ‚à®‚ãØ‚à®ùúëùëõ), ùúë1, ‚Ä¶ , ùúëùëõ, for some given propositions ùúë1, ..., ùúëùëõ.
(program check_or_pos ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   ((check_or_pos (@cl (not left_disjunct) right_disjunct))
    (cl_equal (convert_or_to_cl left_disjunct)
              (@cl right_disjunct))
    )
  )
)

; rule: or_pos
; implements: TODO?
; requires: >
;   For the conclusion to be of the form
;   ¬¨(ùúë1 ‚à®‚ãØ‚à®ùúëùëõ), ùúë1, ‚Ä¶ , ùúëùëõ, for some given propositions ùúë1, ..., ùúëùëõ.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or_pos ()
  :requires (((check_or_pos eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;
; Rule 51: or_neg
;;;;;;;;;;;;;;;;;;

; program: check_or_neg
; args:
; - pos Int: Position of the selected disjunct.
;            0 <= pos <= number of disjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, with the form 
;   not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
(program check_or_neg ((index Int) (left_disjunct Bool) (right_disjunct Bool))
  (Int Bool) Bool
  (
   ((check_or_neg index (@cl left_disjunct (not right_disjunct)))
    (prop_syntax_eq (f_list_index or left_disjunct index) right_disjunct))
   
   ((check_or_neg index (@cl (not left_disjunct) right_disjunct))
    (prop_syntax_eq right_disjunct (f_list_index or left_disjunct index)))
  )
)

; rule: or_neg
; implements: TODO?
; args:
; - index Int: The index of the disjunct which is weakened in the conclusion.
; requires: >
;   Th conclusion must be an instance of the weakening rule for implication, 
;   with the form not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or_neg ((index Int))
  :args (index)
  :requires (((check_or_neg index eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_xor_pos1 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_pos1 CL) true)
  )
)

;TRUST
(declare-rule xor_pos1 ((CL Bool))
  :args (CL)
  :requires (((check_xor_pos1 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_pos2 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_pos2 CL) true)
  )
)

;TRUST
(declare-rule xor_pos2 ((CL Bool))
  :args (CL)
  :requires (((check_xor_pos2 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_neg1 CL) true)
  )
)

;TRUST
(declare-rule xor_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_xor_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_neg2 CL) true)
  )
)

;TRUST
(declare-rule xor_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_xor_neg2 CL) true))
  :conclusion CL
)

;;;;;;;;;;;;;;;;;;;;;;
; Rule 56: implies_pos
;;;;;;;;;;;;;;;;;;;;;;

; program: check_implies_pos; 
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of implies_pos. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is an instance of excluded middle,
;   for a proposition of the form phi_1 -> phi_2.
(program check_implies_pos ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   ((check_implies_pos (@cl (not (=> phi_1 phi_2)) phi_3 phi_4))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   ((check_implies_pos (@cl phi_3 (not (=> phi_1 phi_2)) phi_4))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   ((check_implies_pos (@cl phi_3 phi_4 (not (=> phi_1 phi_2))))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
  )
)

; rule: implies_pos
; implements: TODO?
; requires: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form phi_1 -> phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_pos ()
  :requires (((check_implies_pos eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 57: implies_neg1
;;;;;;;;;;;;;;;;;;;;;;;

; program: check_implies_neg1
; args:
; - CL Bool: >
;   This should be the conclusion to the application of implies_neg1. It must be
;   a clause built with @cl.
; return:
;   A boolean indicating if "conclusion" is cl_equal to phi_1 -> phi_2, phi1,
;   for some propositions phi_1 and phi_2.
(program check_implies_neg1 ((phi_1 Bool) (phi_2 Bool))
  (Bool) Bool
  (
   ((check_implies_neg1 (@cl (=> phi_1 phi_2) phi_1))
    true)

   ((check_implies_neg1 (@cl phi_1 (=> phi_1 phi_2)))
    true)

   ((check_implies_neg1 _)
    false)
  )
)

; rule: implies_neg1
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be cl_equal to phi_1 -> phi_2, phi1,
;   for some propositions phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_neg1 ()
  :requires (((check_implies_neg1 eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 58: implies_neg2
;;;;;;;;;;;;;;;;;;;;;;;

; program: check_implies_neg2
; args:
; - CL Bool: >
;   This should be the conclusion to the application of implies_neg2. It must be
;   a clause built with @cl.
; return:
;   A boolean indicating if "conclusion" is cl_equal to phi_1 -> phi_2, not phi2,
;   for some propositions phi_1 and phi_2.
(program check_implies_neg2 ((phi_1 Bool) (phi_2 Bool))
  (Bool) Bool
  (
   ((check_implies_neg2 (@cl (=> phi_1 phi_2) (not phi_2)))
    true)

   ((check_implies_neg2 (@cl (not phi_2) (=> phi_1 phi_2)))
    true)

   ((check_implies_neg2 _)
    false)
  )
)

; rule: implies_neg2
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be cl_equal to phi_1 -> phi_2, not phi2,
;   for some propositions phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_neg2 ()
  :requires (((check_implies_neg2 eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 59: equiv_pos1
;;;;;;;;;;;;;;;;;;;;;;;

; program: check_equiv_pos1
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of equiv_pos1. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is cl_equal to the clause 
;   not (phi_1 = phi2), phi_1, not phi_2, for some props. phi_1 and phi_2.
(program check_equiv_pos1 ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   ((check_equiv_pos1 (@cl (not (= phi_1 phi_2)) phi_3 phi_4))
    (cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))
   
   ((check_equiv_pos1 (@cl phi_3 (not (= phi_1 phi_2)) phi_4))
    (cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))
   
   ((check_equiv_pos1 (@cl phi_3 phi_4 (not (= phi_1 phi_2))))
    (cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))

   ((check_equiv_pos1 _)
    false)
  )
)

; rule: equiv_pos1
; implements: TODO?
; requires: >
;   Requires for the conclusion to be cl_equal to the clause 
;   not (phi_1 = phi2), phi_1, not phi_2, for some props. phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_pos1 ()
  :requires (((check_equiv_pos1 eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;
; Rule 60: equiv_pos2
;;;;;;;;;;;;;;;;;;;;;;;

; program: check_equiv_pos2
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of equiv_pos2. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is cl_equal to the clause 
;   not (phi_1 = phi2), not phi_1, phi_2, for some props. phi_1 and phi_2.
(program check_equiv_pos2 ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   ((check_equiv_pos2 (@cl (not (= phi_1 phi_2)) phi_3 phi_4))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
   
   ((check_equiv_pos2 (@cl phi_3 (not (= phi_1 phi_2)) phi_4))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
   
   ((check_equiv_pos2 (@cl phi_3 phi_4 (not (= phi_1 phi_2))))
    (cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   ((check_equiv_pos2 _)
    false)
  )
)

; rule: equiv_pos2
; implements: TODO?
; requires: >
;   Requires for the conclusion to be cl_equal to the clause 
;   not (phi_1 = phi2), not phi_1, phi_2, for some props. phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_pos2 ()
  :requires (((check_equiv_pos2 eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_equiv_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_neg1 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_equiv_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_neg2 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_neg2 CL) true))
  :conclusion CL
)

(program check_ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_ite1 (@cl (ite phi1 phi2 phi3)) refCL)
     (cl_equal (@cl phi1 phi3) refCL)
   )
   ((check_ite1 (ite phi1 phi2 phi3) refCL)
     (cl_equal (@cl phi1 phi3) refCL)
   )
  )
)

(declare-rule ite1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_ite1 CL refCL) true))
  :conclusion refCL
)

(program check_ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_ite2 (@cl (ite phi1 phi2 phi3)) refCL)
     (cl_equal (@cl (not phi1) phi2) refCL)
   )
   ((check_ite2 (ite phi1 phi2 phi3) refCL)
     (cl_equal (@cl (not phi1) phi2) refCL)
   )
  )
)

(declare-rule ite2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :requires (((check_ite2 CL eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_ite_pos1 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_pos1 CL) true)
  )
)

;TRUST
(declare-rule ite_pos1 ((CL Bool))
  :args (CL)
  :requires (((check_ite_pos1 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_pos2 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_pos2 CL) true)
  )
)

;TRUST
(declare-rule ite_pos2 ((CL Bool))
  :args (CL)
  :requires (((check_ite_pos2 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_neg1 CL) true)
  )
)

;TRUST
(declare-rule ite_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_ite_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_neg2 CL) true)
  )
)

;TRUST
(declare-rule ite_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_ite_neg2 CL) true))
  :conclusion CL
)

(program check_not_ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_ite1 (@cl (not (ite phi1 phi2 phi3))) refCL)
     (cl_equal (@cl phi1 (not phi3)) refCL)
   )
   ((check_not_ite1 (not (ite phi1 phi2 phi3)) refCL)
     (cl_equal (@cl phi1 (not phi3)) refCL)
   )
  )
)

(declare-rule not_ite1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires (((check_not_ite1 CL refCL) true))
  :conclusion refCL
)

(program check_not_ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   ((check_not_ite2 (@cl (not (ite phi1 phi2 phi3))) refCL)
     (cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
   ((check_not_ite2 (not (ite phi1 phi2 phi3)) refCL)
     (cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
  )
)

;TODO
(program check_connective_def ((conclusion Bool))
  (Bool) Bool
  (
   ((check_connective_def conclusion) true)
  )
)

;TRUST
(declare-rule connective_def ((conclusion Bool))
  :requires (((check_connective_def eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_and_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_and_simplify l r) true)
  )
)

;TRUST
(declare-rule and_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_and_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_or_simplify ((conclusion Bool))
  (Bool) Bool
  (
   ((check_or_simplify conclusion) true)
  )
)

;TRUST
(declare-rule or_simplify ()
  :requires (((check_or_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_not_simplify ((conclusion Bool))
  (Bool) Bool
  (
   ((check_not_simplify conclusion) true)
  )
)

;TRUST
(declare-rule not_simplify ()
  :requires (((check_not_simplify eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rule 75: implies_simplify
;;;;;;;;;;;;;;;;;;;;;;;;;;;

; program: check_implies_simplify
; args:
; - conclusion Bool: Conclusion provided to rule implies_simplify.
; return: >
;   A boolean indicating if conclusion has the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_implication".
(program check_implies_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   ((check_implies_simplify (@cl (= (=> phi_1 phi_2) psy)))
                            ; TODO: use proper comparison for props
                            (cl_equal (@cl (rewrite_implication (=> phi_1 phi_2)))
                                      (@cl psy)))
  )
)

; rule: implies_simplify
; implements: TODO?
; requires: >
;   For the conclusion to be of the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì 
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_implication".
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_simplify ()
  :requires (((check_implies_simplify eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rule 76: equiv_simplify
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; program: check_equiv_simplify
; args:
; - conclusion Bool: Conclusion provided to rule equiv_simplify.
; return: >
;   A boolean indicating if conclusion has the form (ùúë1 ‚âà ùúë2) ‚âà ùúì, where ùúì 
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_equivalence".
(program check_equiv_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   ((check_equiv_simplify (@cl (= (= phi_1 phi_2) psy)))
                            ; TODO: use proper comparison for props
                            (cl_equal (@cl (rewrite_equivalence (= phi_1 phi_2)))
                                      (@cl psy)))
  )
)

; rule: equiv_simplify
; implements: TODO?
; requires: >
;   For the conclusion to be of the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_equivalence".
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_simplify ()
  :requires (((check_equiv_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_bool_simplify ((conclusion Bool))
  (Bool) Bool
  (
   ((check_bool_simplify conclusion) true)
  )
)

;TRUST
(declare-rule bool_simplify ()
  :requires (((check_bool_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_ac_simp ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_ac_simp l r) true)
  )
)

;TRUST
(declare-rule ac_simp ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_ac_simp l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_ite_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_ite_simplify l r) true)
  )
)

;TRUST
(declare-rule ite_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_ite_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_qnt_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_qnt_simplify l r) true)
  )
)

;TRUST
(declare-rule qnt_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_qnt_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_onepoint ((conclusion Bool))
  (Bool) Bool
  (
   ((check_onepoint conclusion) true)
  )
)
;; (program check_onepoint ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
;;   (Bool T T T T) Bool
;;   (
;;    ((check_onepoint ctx l r l1 r1) true)
;;   )
;; )

;TRUST
(declare-rule onepoint ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  ;; :premises (old_ctx (@cl (= l1 r1)))
  ;; :args ((@cl (= l r)))
  ;; :requires (((context_extended ctx old_ctx) true) ((check_onepoint ctx l r l1 r1) true))
  :requires (((check_onepoint eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_qnt_join ((conclusion Bool))
  (Bool) Bool
  (
   ((check_qnt_join conclusion) true)
  )
)

;TRUST
(declare-rule qnt_join ()
  :requires (((check_qnt_join eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_qnt_rm_unused ((conclusion Bool))
  (Bool) Bool
  (
   ((check_qnt_rm_unused conclusion) true)
  )
)

;TRUST
(declare-rule qnt_rm_unused ()
  :requires (((check_qnt_rm_unused eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_eq_simplify ((conclusion Bool))
  (Bool) Bool
  (
   ((check_eq_simplify conclusion) true)
  )
)

;TRUST
(declare-rule eq_simplify ()
  :requires (((check_eq_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_div_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_div_simplify l r) true)
  )
)

;TRUST
(declare-rule div_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_div_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_prod_simplify ((conclusion Bool))
  (Bool) Bool
  (
   ((check_prod_simplify conclusion) true)
  )
)

;TRUST
(declare-rule prod_simplify ()
  :requires (((check_prod_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_unary_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_unary_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule unary_minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_unary_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_sum_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_sum_simplify l r) true)
  )
)

;TRUST
(declare-rule sum_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_sum_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_comp_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_comp_simplify l r) true)
  )
)

;TRUST
(declare-rule comp_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_comp_simplify l r) true))
  :conclusion (@cl (= l r))
)

;;;;;;;;;;;;;;;
; Rule 91: let
;;;;;;;;;;;;;;;

(program verify_let_premises ((context Bool) (premises Bool) 
                              (A Type) (var A)
                              (B Type) (value B)
                              (tl @VarList :list))
  (Bool Bool @VarList) Bool
  (
   (
    (verify_let_premises context premises 
                         (f_list_cons @varlist 
                                      (f_list_cons @varlist var value) 
                                      tl))
    (eo::or (f_list_contains_elem 
             and 
             (@cl (= value (context_get_substitute context var)))
             premises)
            (verify_let_premises context premises tl)
            )
    )

   (
    (verify_let_premises context premises @varlist.nil)
    
    true
    )
   )
)

; This has to traverse the lets and the premises. Also has to check the
; context extension.
; program: check_let_elim
; args:
; - ctx Bool:
; - Cs Bool:
; - conclusion Bool:
; return:
(program check_let_elim ((context Bool) (premises Bool) 
                         (let_type Type) (let_def let_type)
                         (var_defs @VarList) 
                         (A Type) (lhs A) (rhs A)
                         (B Type)
                         (var_values B))
  (Bool Bool let_type) Bool
  (
   (
    (check_let_elim context premises
                    (@cl (= let_def rhs)))

    (eo::and 
     ; There should be a conclusion of the form (@cl (= lhs rhs))
     ; TODO: this conclusion must be just of the previous step
     (f_list_contains_elem and (@cl (= (let_get_body let_def) rhs)) premises)
     (verify_let_premises context premises 
                          (let_get_vars_substitutes (let_get_vars let_def)
                                                    (let_get_values let_def)))
     )
    )
   )
)

; rule: let_elim
; assumption:
; - ctx: Context from the actual subproof.
; premise-list:
; - Cs: Surrounding context 
; conclusion: >
;   
; note: >
(declare-rule let_elim ((ctx Bool) (premises Bool))
  :assumption ctx
  :premise-list premises and
  :requires (((check_let_elim ctx premises eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;
; Rule 93: distinct_elim
;;;;;;;;;;;;;;;;;;;;;;;;

; program: build_distinct_list
; args:
; - list Bool: An and-list of distinct-list elements.
; return:
; Returns the reinterpretation of the given and-list of distinct-list elements,
; as a conjunction of inequalities.
(program build_distinct_list ((A Type) (lhs A) (rhs A) (tl Bool :list))
  (Bool) Bool
  (
   ((build_distinct_list (and (distinct lhs rhs) tl))

    (f_list_cons and 
                 (not (= lhs rhs)) 
                 (build_distinct_list tl)))

   ; Only one proposition
   ((build_distinct_list (distinct lhs rhs)) 

    (not (= lhs rhs)))

   ; Only one proposition
   ((build_distinct_list (distinct lhs)) 

    true)
   
   ((build_distinct_list true) 

    true)
  )
)

; TODO: DELETE THIS IF WE FIND A GENERIC WAY TO IMPLEMENT THIS

; program: conjunction_contains_ineq
; args:
; - ineq Bool: >
;   An inequality of the form (not (= lhs rhs)), for some terms lhs and rhs of
;   type A.
; - conjunctions Bool: A conjunctions of inequalities of the form (not (= lhs' rhs'))
; return:
;   A boolean indicating if ineq appears in "conjunctions".
(program conjunction_contains_ineq ((A Type) (lhs A) (rhs A) (hd Bool) (tl Bool :list))
  (Bool Bool) Bool
  (
   ((conjunction_contains_ineq (not (= lhs rhs)) (and (not (= lhs rhs)) tl))

    true)

   ((conjunction_contains_ineq (not (= lhs rhs)) (and (not (= rhs lhs)) tl))

    true)

   ; { hd =/= not (= rhs lhs))}
   ((conjunction_contains_ineq (not (= lhs rhs)) (and hd tl))

    (conjunction_contains_ineq (not (= lhs rhs)) tl))

   
   ((conjunction_contains_ineq (not (= lhs rhs)) (not (= lhs rhs)))

    true)

   ((conjunction_contains_ineq (not (= lhs rhs)) (not (= rhs lhs)))

    true)

   ; { hd =/= (not (= lhs rhs))}
   ((conjunction_contains_ineq (not (= lhs rhs)) hd)

    false)
  )
)

; program: conjunction_contains_conjunction
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return:
; A boolean indicating if the elements from list_1 also appear in list_2.
(program conjunction_contains_conjunction ((hd Bool) (tl Bool :list)
                                           (f_list_2 Bool))
  (Bool Bool) Bool
  (
   ((conjunction_contains_conjunction (and hd tl) f_list_2)
    ;; TODO: I need some way to build boolean values
    ;; combining other boolean values, but I would like
    ;; to avoid built-in operators.
    (eo::and (conjunction_contains_ineq hd f_list_2)
             (conjunction_contains_conjunction tl f_list_2)))

 
   ; { f_list_1 is not an and-list}
   ((conjunction_contains_conjunction true f_list_2)
    true)
   
   ; { hd must be an inequaity }
   ((conjunction_contains_conjunction hd f_list_2)
    (conjunction_contains_ineq hd f_list_2))
  )
)

; program: conjunctions_equal
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return: >
; A boolean indicating if the conjuncts from list_1 and list_2 are the 
; same, regardless of the order.
(program conjunctions_equal ((list_1 Bool) (list_2 Bool))
  (Bool Bool) Bool
  (
   ((conjunctions_equal list_1 list_2)
    (eo::and (conjunction_contains_conjunction list_1 list_2)
             (conjunction_contains_conjunction list_2 list_1)))
  )
)

; program: check_distinct_elim
; args:
; - conclusion Bool: The conclusion give to the distinct_elim rule.
; return:
; A Boolean indicating if the given "conclusion" has the shape
; (distinct ùë°1 ‚Ä¶ ùë°ùëõ) ‚âà ‚ãÄ ùë°ùëñ ‚âà/‚âà ùë°ùëó.
(program check_distinct_elim ((A Type) (hd A) (inequalities Bool) (conjunctions Bool))
  (Bool) Bool
  (; TODO: assuming that inequalities come first
   ((check_distinct_elim (@cl (= inequalities conjunctions)))
    (conjunctions_equal (build_distinct_list inequalities)
                        conjunctions))

   ; Only one proposition
   ((check_distinct_elim (@cl (= (distinct hd) true))) true)
  )
)

; rule: distinct_elim
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be of the shape
;   (distinct ùë°1 ‚Ä¶ ùë°ùëõ) ‚âà ‚ãÄ ùë°ùëñ ‚âà/‚âà ùë°ùëó.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule distinct_elim ()
  :requires (((check_distinct_elim eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;
; Rule 94: la_rw_eq
;;;;;;;;;;;;;;;;;;;

; program: check_la_rw_eq
; args:
; - conclusion Bool: >
;   The conclusion provided to the la_rw_eq rule. Must be build with @cl.
; return: >
;   A boolean indicating if "conclusion" is a clause of the form 
;   (= (= t u) (and (<= t u) (<= u t))), for some numbers t and u.
(program check_la_rw_eq ((t Real) (u Real))
  (Bool) Bool
  (
   ((check_la_rw_eq (@cl (= (= t u) (and (<= t u) (<= u t))))) true)
  )
)

; TODO: other number types. Can the equality be flipped?
; rule: la_rw_eq
; implements: TODO?
; requires: >
;   Requires for the conclusion to be a clause of the form 
;   (= (= t u) (and (<= t u) (<= u t))), for some numbers t and u.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule la_rw_eq ()
  :requires (((check_la_rw_eq eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;
; Rule 95: nary_elim
;;;;;;;;;;;;;;;;;;;

; program: check_nary_elim
; args:
; - conclusion Bool: >
;   Conclusion given to rule nary_elim. It must be built with @cl.
; return:
;   - A boolean indicating if conclusion has one of the following forms:
;     ‚óã ùë°ùëñ ‚âà (‚Ä¶ ((ùë°1 ‚àòùë°2) ‚àòùë°3) ‚àò‚ãØùë°ùëõ) (for a left assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àò‚ãØ‚àò(ùë°ùëõ‚àí2 ‚àò(ùë°ùëõ‚àí1 ‚àòùë°ùëõ) ‚Ä¶ ) (for a right assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àòùë°2) ‚àß(ùë°2 ‚àòùë°3) ‚àß‚ãØ‚àß (ùë°ùëõ‚àí1 ‚àòùë°ùëõ) (for a chainable operator ‚àò)
;   - ‚àò cannot be ‚àß or ‚à®.
(program check_nary_elim ((A Type) (hd A) (tl A :list))
  (Bool) Bool
  (; TODO: check that op is not /\ nor \/
   ; TODO: do we have reflection mechanisms, useful to inspect properties
   ; of each operator, and define this program in a generic way?
   ((check_nary_elim (@cl (= (=> hd tl) (=> hd tl))))
    ; right-assoc operator
    ; We leverage the desugaring process, that turns both lists
    ; into the folded application of the operator, already
    ; associated to the right.
    true
    )
  )
)

; rule: nary_elim
; implements: TODO?
; requires: >
;   - The conclusion should have one of the following forms:
;     ‚óã ùë°ùëñ ‚âà (‚Ä¶ ((ùë°1 ‚àòùë°2) ‚àòùë°3) ‚àò‚ãØùë°ùëõ) (for a left assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àò‚ãØ‚àò(ùë°ùëõ‚àí2 ‚àò(ùë°ùëõ‚àí1 ‚àòùë°ùëõ) ‚Ä¶ ) (for a right assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àòùë°2) ‚àß(ùë°2 ‚àòùë°3) ‚àß‚ãØ‚àß (ùë°ùëõ‚àí1 ‚àòùë°ùëõ) (for a chainable operator ‚àò)
;    - ‚àò cannot be ‚àß or ‚à®.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule nary_elim ()
  :requires (((check_nary_elim eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_bfun_elim ((psi Bool) (phi Bool))
  (Bool Bool) Bool
  (
   ((check_bfun_elim (@cl psi) phi) true)
  )
)

;TRUST
(declare-rule bfun_elim ((psi Bool) (phi Bool))
  :premises (psi)
  :args ((@cl phi))
  :requires (((check_bfun_elim (to_cl psi) phi) true))
  :conclusion (@cl phi)
)

;TODO
(program check_ite_intro ((conclusion Bool))
  (Bool) Bool
  (
   ((check_ite_intro conclusion) true)
  )
)

;TRUST
(declare-rule ite_intro ()
  :requires (((check_ite_intro eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table 10: Rules used by cvc5, but not by veriT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;TODO
(program check_symm ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_symm premise conclusion) true)
  )
)
; TODO: should we delegate the whole responsibility to the checker or
; should we share responsibilities?
;TRUST
(declare-rule symm ((premise Bool))
  :premises (premise)
  :requires (((check_symm premise eo::conclusion) true))
  :conclusion-given
)

;TODO
(program check_reordering ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   ((check_reordering premise conclusion) true)
  )
)

;TRUST
(declare-rule reordering ((premise Bool))
  :premises (premise)
  :requires (((check_symm premise eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rare
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;TODO
(program check_rare_rewrite ((Flag Bool) (CL Bool))
  (Bool Bool) Bool
  (
   ((check_rare_rewrite Flag CL) true)
  )
)

;TRUST
(declare-rule rare_rewrite ((flag Bool))
  :args (flag)
  :requires (((check_rare_rewrite flag eo::conclusion) true))
  :conclusion-given
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Misc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program check_discard_context ((CL Bool))
  (Bool) Bool
  (
   ((check_discard_context CL) true)
  )
)

; TODO: dummy step-pop step, to discard contexts
(declare-rule discard_context ((ctx Bool))
  :assumption ctx
  ;; :requires (((check_discard_context eo::conclusion) true))
  :conclusion-given
)
