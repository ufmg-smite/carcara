(include "./theory.eo")
(include "./programs.eo")

; Rule: assume is native

; TODO: what would the checker do in this case?
(program $check_hole ((conclusion Bool))
    (Bool) Bool
    (
    (($check_hole conclusion) true)
    )
)

; Note: The hole here does not allow for args or premises.
(declare-rule hole ()
  :requires ((($check_hole eo::conclusion) true))
  :conclusion-given
)

(declare-rule true ()
  :args ((@cl true))
  :conclusion (@cl true)
)

;-------------
; Rule 4: false
;-------------

; rule: false
; conclusion: Conclusion must be of the form (@cl (not false)).
(declare-rule false ()
  :conclusion (@cl (not false))
)

;-------------
; Rule 5: not_not
;-------------

; program: check_not_not
; args:
; - conclusion Bool: Conclusion given to rule not_not.
; return: >
;   A boolean indicating if conclusion is equivalent to the proposition
;   ¬¨(¬¨¬¨ùúë), ùúë, for some proposition ùúë
(program $check_not_not ((phi Bool))
    (Bool) Bool
    (
    (($check_not_not (@cl (not (not (not phi))) phi)) true)
    (($check_not_not (@cl phi (not (not (not phi))))) true)
    )
)

; rule: not_not
; implements: TODO?
; requires: >
;   The conclusion should be equivalent to the proposition
;   ¬¨(¬¨¬¨ùúë), ùúë, for some proposition ùúë
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_not ()
  :requires ((($check_not_not eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 6: th_resolution
;-------------
; TODO
(program $check_resolution ((Cs Bool) (CL Bool))
  (Bool Bool) Bool
  (
   (($check_resolution Cs CL) true)
  )
)

(declare-rule th_resolution ((Cs Bool))
  :premise-list Cs and
  :requires ((($check_resolution Cs eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 7: resolution
;-------------

;TRUST
(declare-rule resolution ((Cs Bool))
  :premise-list Cs and
  :requires ((($check_resolution Cs eo::conclusion) true))
  :conclusion-given
  :sorry
)

;TODO
(program $check_tautology ((CL1 Bool))
  (Bool) Bool
  (
   (($check_tautology CL1) true)
  )
)

;TRUST
(declare-rule tautology ((CL1 Bool))
  :premises (CL1)
  :args ((@cl true))
  :requires ((($check_tautology CL1) true))
  :conclusion (@cl true)
)

;-------------
; Rule 9: contraction
;-------------

; program: check_contraction
; args:
; - premise Bool: Premise given to rule "contraction". Must be a @cl.
; - conclusion Bool: Conclusion given to rule "contraction". Must be a @cl.
; return:
;   A boolean indicating if conclusion is equivalent to premise, without 
;   duplicated disjuncts.
(program $check_contraction ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (
    ; Check that both clauses contain the same elements, regardless of order
    ; and possible repetitions.
    ($check_contraction premise conclusion)

    ($f_list_equal @cl ($cl_remove_duplicates premise) conclusion)
    )
   )
  )

; rule: contraction
; implements: TODO?
; premises:
; - premise Bool: A clause from which we want to eliminate duplicated literals.
; requires: >
;   For the conclusion to be equivalent to premise, without duplicated disjuncts.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule contraction ((premise Bool))
  :premises (premise)
  :requires ((($check_contraction premise eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 10: subproof
;-------------

; program: $check_subproof
; args:
; - assumption Bool: Assumption passed to "subproof", not built with @cl.
; - premise Bool: Last step before the application of "subproof".
; - conclusion Bool: Conclusion of the "subproof" step.
; return: >
;   A boolean indicating if "conclusion" is of the form 
;   (@cl (not assumption), premise)
(program $check_subproof ((assumption Bool) (premise Bool) 
                          (conclusion Bool))
  (Bool Bool Bool) Bool
  (
   (
    ($check_subproof assumption @empty_cl conclusion)

    (eo::and
     ($f_list_contains_elem @cl (not assumption) conclusion)
     ; To deal with the inclusion of @empty_cl within conclusion
     ($f_list_contains_elem @cl false conclusion))
    )

   (; { premise =/= @empty_cl }
    ($check_subproof assumption premise conclusion)

    (eo::and
     ($f_list_contains_elem @cl (not assumption) conclusion)
     ($f_list_contains_f_list @cl premise conclusion))
    )
  )
)

;TODO: test if the list here works well
; rule: subproof
; implements: TODO?
; assumption:
; - assumption Bool: Assumption passed to "subproof", not built with @cl.
; premises:
; - premise Bool: Last step before the application of "subproof".
; requires: >
;   For conclusion to be of the form (@cl (not assumption) premise).
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule subproof ((assumption Bool) (premise Bool))
  :assumption assumption
  :premises (premise)
  :requires ((($check_subproof assumption premise eo::conclusion) true))
  :conclusion-given
)

;TODO
; From "The Alethe Proof Format":
; "Checking the validity of this clause amounts to checking the unsatisfiability 
; of the system of linear equations ùúë1, ùúë2, ‚Ä¶ , ùúëùëõ. The annotation of an 
; la_generic step contains a coefficient for each (in)equality. The result of 
; forming the linear combination of the literals with the coefficients is a trivial 
; inequality between constants".
(program $check_la_generic ((coeffs Real) (CL Bool))
  (Real Bool) Bool
  (
   (($check_la_generic coeffs CL) true)
  )
)

; NOTE: The coefficients are one single argument.  This means they must be
;       be wrapped in a single function call using an n-ary function.  See
;       the example `small.smt3`.
;TRUST
(declare-rule la_generic ((coeffs Real))
  :args (coeffs)
  :requires ((($check_la_generic coeffs eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_lia_generic ((CL Bool))
  (Bool) Bool
  (
   (($check_lia_generic CL) true)
  )
)

;TRUST
(declare-rule lia_generic ((CL Bool))
  :args (CL)
  :requires ((($check_lia_generic CL) true))
  :conclusion CL
)

(declare-rule la_disequality ((t1 Real) (t2 Real))
  :args ((@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1)))))
  :conclusion (@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1))))
)

(declare-rule la_totality ((t1 Real) (t2 Real))
  :args ((@cl (or (<= t1 t2) (<= t2 t1))))
  :conclusion (@cl (or (<= t1 t2) (<= t2 t1)))
)

;TODO
(program $check_la_tautology ((CL Bool))
  (Bool) Bool
  (
   (($check_la_tautology CL) true)
  )
)

;TRUST
(declare-rule la_tautology ((CL Bool))
  :args (CL)
  :requires ((($check_la_tautology CL) true))
  :conclusion CL
)

;TODO
(program $check_la_mult_neg ((CL Bool))
  (Bool) Bool
  (
   (($check_la_mult_neg CL) true)
  )
)

;TRUST
(declare-rule la_mult_neg ()
  :requires ((($check_la_mult_neg eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 18: bind
;-------------

; NOTE: Rules like `bind` can have multiple forms: without and with
; @var.  In the first case the bind rule is
;                @var xs. œÜ = @var ys. œÜ'
;              --¬≠¬≠------¬≠¬≠¬≠¬≠¬≠------------¬≠ bind
;                   ‚àÄ xs. œÜ = ‚àÄ ys. œÜ'
; This means that the variable that are free in the premise get bound by
; a @var.  However, since `bind` and other context-extending steps can
; be nested, it could also have the form
;              @var xs‚ÇÅ ‚à™ xs‚ÇÇ. œÜ = @var ys‚ÇÅ ‚à™ ys‚ÇÇ. œÜ'
;        --¬≠¬≠¬≠¬≠¬≠¬≠¬≠--------------------------------¬≠ bind
;             @var xs‚ÇÅ. ‚àÄ xs‚ÇÇ. œÜ = @var ys‚ÇÅ. ‚àÄ ys‚ÇÇ. œÜ'
; In situations where `bind` is combined with rules like `sko_ex`, the
; @var could occur on only one side.
; Since this signature would check the binders in the side condition,
; the binders are invisible here.
; This affects the rules `bind`, `sko_ex`, `sko_forall`, `let`,
; and `onepoint`.
(program $check_bind ((old_context Bool) (new_context Bool)
                      (T Type) (l T) (r T) (l1 T) (r1 T)
                      (premise Bool) 
                      (lhs_vars @VarList) (lhs_body Bool) 
                      (rhs_vars @VarList) (rhs_body Bool))
  (Bool Bool Bool Bool) Bool
  (
   (
    ($check_bind old_context new_context
                 (@cl (= lhs_body rhs_body))
                 (@cl (= (forall lhs_vars lhs_body) 
                         (forall rhs_vars rhs_body))))

    (eo::and

     ; Every variable in rhs_vars appear fixed in "new_context".
     ($context_vars_are_fixed new_context rhs_vars)

     ; Vars in lhs_vars are susbtitued by rhs_vars
     ($f_list_equal @varlist 
                    ($varlist_zip lhs_vars rhs_vars)
                    ($context_get_var_subst_pairs new_context lhs_vars))

     ; rhs_vars should not appear free in (forall lhs_vars lhs_body_unbound)
     ($f_list_equal @varlist
                    ($fv (forall lhs_vars lhs_body))
                    ; TODO: duplicating calculations
                    ($f_list_filter @varlist
                                    @varlist.nil
                                    ($fv (forall lhs_vars lhs_body))
                                    ($varlist_flag_members ($fv (forall lhs_vars lhs_body))
                                                   rhs_vars)))

     ; rhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context rhs_vars))

     ; lhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context lhs_vars))

     ; new_context must be just an extension of old_context
     ($context_is_extended new_context old_context)
     )
    )

   (
    ($check_bind old_context new_context
                 (@cl (= lhs_body rhs_body))
                 (@cl (= (exists lhs_vars lhs_body) (exists rhs_vars rhs_body))))

    (eo::and

     ; Every variable in rhs_vars appear fixed in "context".
     ($context_vars_are_fixed new_context rhs_vars)

     ; Vars in lhs_vars are susbtitued by rhs_vars
     ($f_list_equal @varlist 
                    ($varlist_zip lhs_vars rhs_vars)
                    ($context_get_var_subst_pairs new_context lhs_vars))

     ; rhs_vars should not appear free in (forall lhs_vars lhs_body)
     ($f_list_equal @varlist
                    ($fv (forall lhs_vars lhs_body))
                    ; TODO: duplicating calculations
                    ($f_list_filter @varlist
                                    @varlist.nil
                                    ($fv (forall lhs_vars lhs_body))
                                    ($varlist_flag_members ($fv (forall lhs_vars lhs_body))
                                                   rhs_vars)))
    
     ; rhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context rhs_vars))

     ; lhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context lhs_vars))

      ; new_context must be just an extension of old_context
      ($context_is_extended new_context old_context)
     )
    )
   )
  )

(declare-rule bind ((old_context Bool) (new_context Bool) (premise Bool))
  :assumption new_context
  :premises (premise)
  :args (old_context)
  :requires ((($check_bind old_context new_context premise eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 19: sko_ex
;-------------

; program: $check_sko_build_skolem_vars
; args:
; - choice_body Bool: Body of the choice operator to be built.
; - exist_vars @VarList: @VarList containing the existentially quantified variables.
; return: >
;    A @VarList containing pairs (also as @VarList) of the form (ùë•ùëñ, ùúÄùë•ùëñ.(‚àÉùë•ùëñ+1, ‚Ä¶ , ùë•ùëõ.ùúë).)
(program $check_sko_ex_build_skolem_vars ((choice_body Bool) (A Type) (x A) 
                                       (tail @VarList :list))
         (Bool @VarList) @VarList
         (
          (
           ($check_sko_ex_build_skolem_vars choice_body (@varlist x))

           ($f_list_cons @varlist 
                         ($f_list_cons @varlist 
                                       x
                                       (@varlist (choice (@varlist x) x choice_body)
                                                 @varlist.nil))
                         @varlist.nil)
           )

          (; { tail <> @varlist.nil }
           ($check_sko_ex_build_skolem_vars choice_body (@varlist x tail))

           ($f_list_cons @varlist 
                         ($f_list_cons @varlist 
                                       x
                                       (@varlist (choice (@varlist x) x (exists tail choice_body)) 
                                                 @varlist.nil))
                         ($check_sko_ex_build_skolem_vars choice_body tail))
           )

          (; { tail <> @varlist.nil }
           ($check_sko_ex_build_skolem_vars choice_body @varlist.nil)

           @varlist.nil
           )
          )
)

; program: $check_sko_ex_new_context
; args:
; - ex_body Bool: Body of the existential quantification.
; - new_context Bool: Context of sko_ex premise.
; - ex_vars @VarList: List of existentially quantified variables.
; return: >
;    Checks that "new_context" contains the expected mapping between each variable in
;    "ex_vars" and its corresponding skolem term.
(program $check_sko_ex_new_context ((ex_body Bool) (new_context Bool) (ex_vars @VarList))
         (Bool Bool @VarList) Bool
         (
          (
           ($check_sko_ex_new_context ex_body new_context ex_vars)

           ($f_list_equal @varlist 
                          ($check_sko_ex_build_skolem_vars ex_body ex_vars)
                          ($context_get_var_subst_pairs new_context ex_vars))
           )
          )
)

; program: $check_sko_ex
; args:
; - old_context Bool: Context used outside of the current subproof.
; - new_context Bool: Context within the subproof.
; - premise Bool: Premise passed to sko_ex rule.
; - conclusion Bool: Conclusion passed to sko_ex rule.
; return:
;    A boolean indicating if conclusion has the form
;    ùëÑùë•1, ‚Ä¶ , ùë•ùëõ.ùúë ‚âà ùëÑùë¶1, ‚Ä¶ , ùë¶ùëõ.ùúë‚Ä≤, for a premise ùúë ‚âà ùúë‚Ä≤. It also indicates
;    if the context within the subproof has the form 
;    Œì, ùë¶1, ‚Ä¶ , ùë¶ùëõ, ùë•1 ‚Ü¶ ùë¶1, ‚Ä¶ , ùë•ùëõ ‚Ü¶ ùë¶ùëõ, where Œì should be the context
;    outside of the subproof being closed by sko_ex.
(program $check_sko_ex ((old_context Bool) (new_context Bool) (lhs Bool) (rhs Bool) 
                                                 (conclusion Bool) (ex_vars @VarList))
  (Bool Bool Bool Bool) Bool
  (
   (
    ($check_sko_ex old_context new_context 
                   (@cl (= lhs rhs)) (@cl (= (exists ex_vars lhs) rhs)))

    (eo::and
     ; new_context should be just an extension of old_context.
     ($context_is_extended new_context old_context)

     ; new_context should contain the expected mapping between each variable in
     ; "ex_vars" and its corresponding skolem term.
     ($check_sko_ex_new_context lhs new_context ex_vars)

     ; ex_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context ex_vars))
     )
    )
  )
)

; rule: sko_ex
; implements: TODO?
; assumption:
; - new_context Bool: The subproof context, built with @ctx.
; premises:
; - premise Bool: Premise passed to rule sko_ex.
; args:
; - old_context Bool: >
;    Context from the outside of current subproof, built with @ctx.
; requires: >
;    Conclusion should have the form ùëÑùë•1, ‚Ä¶ , ùë•ùëõ.ùúë ‚âà ùëÑùë¶1, ‚Ä¶ , ùë¶ùëõ.ùúë‚Ä≤, for a 
;    premise ùúë ‚âà ùúë‚Ä≤. Also, if the context within the subproof has the form 
;    Œì, ùë¶1, ‚Ä¶ , ùë¶ùëõ, ùë•1 ‚Ü¶ ùë¶1, ‚Ä¶ , ùë•ùëõ ‚Ü¶ ùë¶ùëõ, Œì should be the context
;    outside of the subproof being closed by sko_ex.
; conclusion-given: >
;    Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule sko_ex ((old_context Bool) (new_context Bool) (premise Bool))
  :assumption new_context
  :premises (premise)
  :args (old_context)
  :requires ((($check_sko_ex old_context new_context premise eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_sko_forall ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  (Bool T T T T) Bool
  (
   (($check_sko_forall ctx l r l1 r1) true)
  )
)

;TRUST
(declare-rule sko_forall ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  :premises (old_ctx (@cl (= l1 r1)))
  :args ((@cl (= l r)))
  :requires ((($context_is_extended ctx old_ctx) true) (($check_sko_forall ctx l r l1 r1) true))
  :conclusion (@cl (= l r))
)

;--------------------
; Rule 21: forall_inst
;--------------------

; program: $check_forall_inst
; args:
; - Conclusion Bool:
; return:
(program $check_forall_inst ((forall_vars @VarList) 
                                                       (body Bool)
                                                       (instantiated_body Bool) 
                                                       (variables_substitutions @VarList))
  (Bool @VarList) Bool
  (
   (;  TODO: ùë•ùëñ and ùë°ùëñ have the same sort
    ($check_forall_inst (@cl (or (not (forall forall_vars body)) instantiated_body))
                        variables_substitutions)
    ($eo_is_eq instantiated_body ($substitution_apply body 
                                                            ($substitution_build 
                                                             forall_vars
                                                             variables_substitutions)))
    )
   )
)

; rule: forall_inst
; implements: TODO?
; premises:
; - variables_substitutions @VarList:
; args:
; requires:
; conclusion:
(declare-rule forall_inst ((variables_substitutions @VarList))
  :args (variables_substitutions)
  :requires ((($check_forall_inst eo::conclusion variables_substitutions) true))
  :conclusion-given
)

;TODO: why is type T not mentioned in the body of check_refl?
(program $check_refl ((ctx Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (($check_refl ctx conclusion) true)
  )
)

;TRUST
(declare-rule refl ((ctx Bool))
  :args (ctx)
  :requires ((($check_refl ctx eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 23: trans
;-------------

; program: $last_eq_right
; args:
; - eqs Bool: Premises given to rule trans (equivalences), chained with "and".
; - lhs T: >
;   Expression of arbitrary type T, for which we want to determine its
;   transitively related element, traversing eqs
; return: >
;   The last element of type T related with lhs, through transitivity, 
;   following the equivalences in eqs.
(program $last_eq_right ((T Type) (t1 T) (t2 T) (eqs Bool))
  (Bool T) Bool
  (
   (; case (@cl (= t1 t2) false)
    ($last_eq_right (@cl (= t1 t2)) t1)
    
    t2
    )

   (; case (@cl (= t1 t2) false)
    ($last_eq_right (@cl (= t1 t2)) t2)
    
    t1
    )

   (; case (and (@cl (= t1 t2) false) true)
    ($last_eq_right (and (@cl (= t1 t2))) t1) 

    t2
    )

   (; case (and (@cl (= t1 t2) false) true)
    ($last_eq_right (and (@cl (= t1 t2))) t2) 

    t1
    )

    (; { eqs <> true}
     ; case (and (@cl (= t1 t2) false) eqs)
     ($last_eq_right (and (@cl (= t1 t2)) eqs) t1) 

     ($last_eq_right eqs t2)
     )

    (; { eqs <> true}
     ; case (and (@cl (= t1 t2) false) eqs)
     ($last_eq_right (and (@cl (= t1 t2)) eqs) t2)

     ($last_eq_right eqs t1)
     )

   ; TODO: are they always clauses? (seems that it is not the
   ; case if the premises where just "assume"s)
    (; case (and (= t1 t2) true) 
     ($last_eq_right (and (= t1 t2)) t1)

     t2
     )

    (; case (and (= t1 t2) true)
     ($last_eq_right (and (= t1 t2)) t2)

     t1
     )

    (; { eqs <> true}
     ; case (and (= t1 t2) eqs)
     ($last_eq_right (and (= t1 t2) eqs) t1)
     
     ($last_eq_right eqs t2)
     )

    (; { eqs <> true}
     ; case (and (= t1 t2) eqs)
     ($last_eq_right (and (= t1 t2) eqs) t2)
     
     ($last_eq_right eqs t1)
     )
  )
)

; program: $make_trans
; args:
; - eqs Bool: Premises given to rule trans (equivalences), chained with "and".
; - lhs T: >
;   Expression of arbitrary type T, for which we want to determine its
;   transitively related element, traversing eqs.
; return: >
;   An equivalence of the form (= lhs rhs), where rhs is the last element of 
;   type T related with lhs, through transitivity, following the equivalences 
;   in eqs.
(program $make_trans ((T Type) (t1 T) (t2 T) (eqs Bool :list))
  (Bool T) Bool
  (
   (; case (and (= t1 t2) true)
    ($make_trans (and (@cl (= t1 t2))) t1)
    
    (= t1 t2)
    )

   (; case (and (= t1 t2) true)
    ($make_trans (and (@cl (= t1 t2))) t2)
    
    (= t1 t2)
    )

   (; { eqs <> true }
    ($make_trans (and (@cl (= t1 t2)) eqs) t1) 
    
    (= t1 ($last_eq_right eqs t2))
    )

   (; { eqs <> true }
    ($make_trans (and (@cl (= t1 t2)) eqs) t2) 
    
    (= t2 ($last_eq_right eqs t1))
    )

   (; case (and (= t1 t2) true)
    ($make_trans (and (= t1 t2)) t1) 
    
    (= t1 t2)
    )

   (; case (and (= t1 t2) true)
    ($make_trans (and (= t1 t2)) t2) 
    
    (= t1 t2)
    )

   (; { eqs <> true }
    ($make_trans (and (= t1 t2) eqs) t1) 
    
    (= t1 ($last_eq_right eqs t2))
    )

   (; { eqs <> true }
    ($make_trans (and (= t1 t2) eqs) t2) 
    
    (= t2 ($last_eq_right eqs t1))
    )
  )
)

; program: $check_trans
; args:
; - premises Bool: Equivalence premises given to rule trans, chained through "and".
; - conclusion Bool: Conclusion given to rule trans. Must be built with @cl.
; return: >
;   A boolean indicating if "conclusion" is the equivalence resulting from
;   the transitivity of equivalence, identifying the lhs of the first 
;   premise equivalence with the rhs of the last premise equivalence.
(program $check_trans ((A Type) (lhs A) (lhs_1 A) (lhs_2 A)
                       (rhs A) (rhs_1 A) (rhs_2 A)
                       (eqs Bool :list))
  (Bool Bool) Bool
  (
   ; We perform the first step of $make_trans here, to be able to select
   ; which side of the equation to follow.
   (
    ($check_trans (and (@cl (= lhs rhs))) (@cl (= lhs rhs)))
    
    true
    )

   (
    ($check_trans (and (@cl (= lhs rhs))) (@cl (= rhs lhs)))
    
    true
    )

   (
    ($check_trans (and (@cl (= lhs rhs_2)) eqs) (@cl (= lhs rhs_1)))

    ($f_list_equal = ($make_trans (and (@cl (= lhs rhs_2)) eqs) lhs) (= lhs rhs_1))
    )

   (
    ($check_trans (and (@cl (= lhs_1 rhs)) eqs) (@cl (= lhs_2 rhs)))

    ($f_list_equal = ($make_trans (and (@cl (= lhs_1 rhs)) eqs) rhs) (= lhs_2 rhs))
    )

   (
    ($check_trans (and (= lhs rhs)) (@cl (= lhs rhs)))
    
    true
    )

   (
    ($check_trans (and (= lhs rhs)) (@cl (= rhs lhs)))
    
    true
    )

   (
    ($check_trans (and (= lhs rhs_2) eqs) (@cl (= lhs rhs_1)))

    ($f_list_equal = ($make_trans (and (= lhs rhs_2) eqs) lhs) (= lhs rhs_1))
    )

   (
    ($check_trans (and (= lhs_1 rhs) eqs) (@cl (= lhs_2 rhs)))

    ($f_list_equal = ($make_trans (and (= lhs_1 rhs) eqs) rhs) (= lhs_2 rhs))
    )
  )
)

;TODO what about scopes here? can a premise come from an outers scope
; rule: trans
; implements: TODO?
; premises:
; - premise-list Bool: Premises given to rule "trans", chained with "and"
; requires: >
;   For "conclusion" to be the equivalence resulting from
;   the transitivity of equivalence, identifying the lhs of the first 
;   premise equivalence with the rhs of the last premise equivalence.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule trans ((premises Bool))
  :premise-list premises and
  :requires ((($check_trans premises eo::conclusion) true))
  :conclusion-given
)

;---------------
; Rule 24: cong
;---------------
; program: $mk_variadic_cong_rhs
; args:
; - U Type:
; - f ->:
; - s1 U:
; - s2 U:
; - t U:
; - tail Bool:
; - nil U:
; return:
(program $mk_variadic_cong_rhs ((U Type) (f (-> U U U)) (s1 U) (s2 U) (t U :list) (tail Bool :list) (nil U))
    :signature (U Bool) U
    (
        (; TODO: remove this once we deal with embedding assumptions into
         ; @cl
         ($mk_variadic_cong_rhs (f s1 t) (and (= s1 s2) tail))  

         (eo::cons f s2 ($mk_variadic_cong_rhs t tail))
         )

        (
         ($mk_variadic_cong_rhs (f s1 t) (and (@cl (= s1 s2)) tail))  

         (eo::cons f s2 ($mk_variadic_cong_rhs t tail))
         )

        (
         ($mk_variadic_cong_rhs nil true)                       

         nil)
    )
)

; program: $mk_nary_cong_rhs
; args:
; - T Type:
; - U Type:
; - f ->:
; - t1 U:
; - t2 U:
; - t3 U:
; - tail Bool:
; return:
(program $mk_nary_cong_rhs ((T Type) (U Type) (f (-> T U)) (t1 U) (t2 U) (t3 U) (tail Bool :list))
    :signature (U Bool) U
    (
        (
         ($mk_nary_cong_rhs (f t1) (and (= t1 t2) tail))  

         (_ ($mk_nary_cong_rhs f tail) t2)
         )

        (; TODO: remove this case
         ($mk_nary_cong_rhs (f t1) (and (@cl (= t1 t2)) tail))

         (_ ($mk_nary_cong_rhs f tail) t2)
         )

        (
         ($mk_nary_cong_rhs f true)                       
         
         f
         )
    )
)

; program: $check_cong_nary
; args:
; - premises Bool:
; - A Type:
; - lhs A:
; - rhs A:
; return:
(program $check_cong_nary ((premises Bool) (A Type) (lhs A) (rhs A))
  (Bool Bool) Bool
  (
   (
    ($check_cong_nary premises (@cl (= lhs rhs)))

    ($f_list_equal = ($mk_nary_cong_rhs lhs (eo::list_rev and premises)) rhs)
    )
   )
)

; program: $check_cong_variadic
; args:
; - premises Bool:
; - A Type:
; - lhs A:
; - rhs A:
; return:
(program $check_cong_variadic ((premises Bool) (A Type) (lhs A) (rhs A))
  (Bool Bool) Bool
  (
   (
    ($check_cong_variadic premises (@cl (= lhs rhs)))

    ($f_list_equal = ($mk_variadic_cong_rhs lhs premises) rhs)
    )
   )
)

; rule: cong_nary
; implements: TODO?
; premises:
; - premises Bool:
; args:
; requires:
; conclusion:
(declare-rule cong_nary ((premises Bool))
  :premise-list premises and
  :requires ((($check_cong_nary premises eo::conclusion) true))
  :conclusion-given
)

; rule: cong_variadic
; implements: TODO?
; premises:
; - premises Bool:
; args:
; requires:
; conclusion:
(declare-rule cong_variadic ((premises Bool))
  :premise-list premises and
  :requires ((($check_cong_variadic premises eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_eq_reflexive ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_reflexive conclusion) true)
  )
)
; TODO: to preserve previous attempt
; (declare-rule eq_reflexive ((T Type) (t T))
;   :args ((@cl (= t t)))
;   :conclusion (@cl (= t t))
; )

(declare-rule eq_reflexive ()
  :requires ((($check_eq_reflexive eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_eq_transitive ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_transitive conclusion) true)
  )
)

;TRUST
(declare-rule eq_transitive ()
  :requires ((($check_eq_transitive eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_eq_congruent ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_congruent conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent ()
  :requires ((($check_eq_congruent eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_eq_congruent_pred ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_congruent_pred conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent_pred ()
  :requires ((($check_eq_congruent_pred eo::conclusion) true))
  :conclusion-given
)

;TODO: to preserve previous def
; 
; (program $check_qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;   (@VarList Bool @VarList Bool) Bool
;   (
;    (($check_qnt_cnf xs phi xsP phiP) true)
;   )
; )

; ;TRUST
; (declare-rule qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;   :args ((@cl (or (not (forall xs phi)) (forall xsP phiP))))
;   :requires ((($check_qnt_cnf xs phi xsP phiP) true))
;   :conclusion (@cl (or (not (forall xs phi)) (forall xsP phiP)))
; )

;TODO
(program $check_qnt_cnf ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_cnf conclusion) true)
  )
)

;TRUST
(declare-rule qnt_cnf ()
  :requires ((($check_qnt_cnf eo::conclusion) true))
  :conclusion-given
)

;-------------
; Table 7: Clausification rules
;-------------

;-------------
; Rule 30: and
;-------------

; program: check_and
; args:
; - premise Bool       : >
;   Premise of the "and" rule: a conjunction of terms. 
;   It could be embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from 
;   "premise", with index "index".
(program $check_and ((premise Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  ((($check_and premise index conclusion)
    ($cl_equal ($to_cl ($f_list_index and ($from_cl premise) index))
               conclusion))
  )
)

; TODO: this overloads PandP
; rule: and
; premises:
; - premise: The conjunctions over which "and elimination" is applied.
; args:
; - index Int: >
;   The index of the conjunct being selected. 0 <= index <= number of conjuncts - 1.
; requires: >
;   The conclusion should be one conjunct from the premise,
;   in the position indicated by index.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and ((premise Bool) (index Int))
  :premises (premise)
  :args (index)
  :requires ((($check_and premise index eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 31: not_or
;-------------

; program: check_not_or
; args:
; - premise Bool       : >
;   Premise of the "not_or" rule: a negation of a disjunction of terms.
;   It could be embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from "premise" (after
;   applying DeMorgan's law), in position "index".
(program $check_not_or ((disjuncts Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  (; To facilitate the use of the program, we allow 
   ; the presence of a @cl constructor
   (($check_not_or (@cl premise_non_cl) index conclusion)
    ($check_not_or premise_non_cl index conclusion))

   (($check_not_or (not disjuncts) index conclusion)
    ($cl_equal ($to_cl (not ($f_list_index or disjuncts index)))
               conclusion))
   )
)

; rule: not_or
; premises:
; - premise: The negated disjunction over which "not_or" is applied.
; args:
; - index Int: The index of the conjunct being selected.
;              0 <= index <= number of conjuncts - 1
; requires: >
;   The conclusion should be one disjunct from the result
;   of applying DeMorgan's rule over the premise. The disjunct
;   position must correspond to what is specified by the index
;   parameter
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_or ((premise Bool) (index Int))
  :premises (premise)
  :args (index)
  :requires ((($check_not_or premise index eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 32: or
;-------------

; program: check_or
; args:
; - premise Bool: >
;   Premise of the "or" rule: a disjunction of terms, built with "or" operator. 
;   It could be embedded within a single-term clause built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is equivalent to "premise", but built 
;   with @cl.
(program $check_or ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  ((($check_or (@cl premise) conclusion)
    ($cl_equal ($convert_or_to_cl premise)
               conclusion)
    )

   ; { premise is not built with @cl }
   (($check_or premise conclusion)
    ($cl_equal ($convert_or_to_cl premise) conclusion))
  )
)

; rule: or
; premises:
; - premise: >
;   The clause, built with the "or" operator, over which the rule is applied. 
;   It could be embedded within a single-term clause built with @cl.
; requires: >
;   The conclusion should be a clause equivalent to "premise", 
;   but built with @cl.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or ((premise Bool))
  :premises (premise)
  :requires ((($check_or premise eo::conclusion) true))
  :conclusion-given 
)

;-------------
; Rule 37: not_and
;-------------

; program: check_not_and
; args:
; - premise Bool: Premise of the not_and rule: a negated conjunction of propositions.
; - conclusion Bool: >
;   The conclusion provided to the not_and rule.
; return: >
;   A boolean indicating if "conclusion" is a clause built with
;   @cl, where each disjunct is negated and corresponds to some conjunct from
;   "premise".
(program $check_not_and ((conjunction Bool) (conclusion Bool))
  (Bool Bool) Bool
  ((($check_not_and (not conjunction) conclusion)
     ($cl_equal ($de_morgan_not_and conjunction) conclusion)
     )
  )
)

; rule: not_and
; premises:
; - premise Bool: >
;  The premise clause: a negated conjunction of propositions.
; requires: >
;  For "conclusion" to be a clause built with @cl, that results from applying
;  DeMorgan's rule over "premise".
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule not_and ((premise Bool))
  :premises (premise)
  :requires ((($check_not_and ($from_cl premise) eo::conclusion) true))
  :conclusion-given
)

(program $check_xor1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_xor1 (@cl (xor phi1 phi2)) refCL)
     ($cl_equal (@cl phi1 phi2) refCL)
   )
   (($check_xor1 (xor phi1 phi2) refCL)
     ($cl_equal (@cl phi1 phi2) refCL)
   )
  )
)

(declare-rule xor1 ((CL Bool))
  :premises (CL)
  :requires ((($check_xor1 CL eo::conclusion) true))
  :conclusion-given
)

(program $check_xor2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_xor2 (@cl (xor phi1 phi2)) refCL)
     ($cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
   (($check_xor2 (xor phi1 phi2) refCL)
     ($cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
  )
)

(declare-rule xor2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_xor2 CL refCL) true))
  :conclusion refCL
)

(program $check_not_xor1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_xor1 (@cl (xor phi1 phi2)) refCL)
     ($cl_equal (@cl phi1 (not phi2)) refCL)
   )
   (($check_not_xor1 (xor phi1 phi2) refCL)
     ($cl_equal (@cl phi1 (not phi2)) refCL)
   )
  )
)

(declare-rule not_xor1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_xor1 CL refCL) true))
  :conclusion refCL
)


(program $check_not_xor2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_xor2 (@cl (xor phi1 phi2)) refCL)
     ($cl_equal (@cl (not phi1) phi2) refCL)
   )
   (($check_not_xor2 (xor phi1 phi2) refCL)
     ($cl_equal (@cl (not phi1) phi2) refCL)
   )
  )
)

(declare-rule not_xor2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_xor2 CL refCL) true))
  :conclusion refCL
)

;-------------
; Rule 41: implies
;-------------

; program: check_implies
; args:
; - premise Bool: >
;   Premise of the implies rule. Should be an implication,
;   built with the => constructor. The premise could be embedded
;   within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   of the "premise" implication (i.e., "not antecedent or consequent" form).
(program $check_implies ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (($check_implies (@cl (=> phi1 phi2)) conclusion)
     ($cl_equal (@cl (not phi1) phi2) conclusion)
   )
   (($check_implies (=> phi1 phi2) conclusion)
     ($cl_equal (@cl (not phi1) phi2) conclusion)
   )
  )
)

; rule: implies
; implements: TODO?
; premises:
; - premise Bool: >
;   Premise of the implies rule. Should be an implication,
;   built with the => constructor. The premise could be embedded
;   within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication given as premise of the rule.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies ((premise Bool))
  :premises (premise)
  :requires ((($check_implies premise eo::conclusion) true))
  :conclusion-given
)

(program $check_not_implies1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_implies1 (@cl (not (=> phi1 phi2))) refCL)
     ($cl_equal (@cl phi1) refCL)
   )
   (($check_not_implies1 (not (=> phi1 phi2)) refCL)
     ($cl_equal (@cl phi1) refCL)
   )
  )
)

(declare-rule not_implies1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_implies1 CL refCL) true))
  :conclusion refCL
)

(program $check_not_implies2 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_implies2 (@cl (not (=> phi1 phi2))) refCL)
     ($cl_equal (@cl phi1) refCL)
   )
   (($check_not_implies2 (not (=> phi1 phi2)) refCL)
     ($cl_equal (@cl phi1) refCL)
   )
  )
)

(declare-rule not_implies2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_implies2 CL refCL) true))
  :conclusion refCL
)

;-------------
; Rule 44: equiv1
;-------------

; program: check_equiv1
; args:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   (i.e., "not antecedent or consequent" form) of the implication 
;   phi1 => phi2.
(program $check_equiv1 ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (($check_equiv1 (@cl (= phi1 phi2)) conclusion)
     ($cl_equal (@cl (not phi1) phi2) conclusion)
   )
   (($check_equiv1 (= phi1 phi2) conclusion)
     ($cl_equal (@cl (not phi1) phi2) conclusion)
   )
  )
)

; rule: equiv1
; implements: TODO?
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi1 => phi2.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
; conclusion:
(declare-rule equiv1 ((premise Bool))
  :premises (premise)
  :requires ((($check_equiv1 premise eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 45: equiv2
;-------------

; program: check_equiv2
; args:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule.
; return: >
;   A boolean indicating if "conclusion" is the characterization
;   (i.e., "not antecedent or consequent" form) of the implication 
;   phi2 => phi1.
(program $check_equiv2 ((phi1 Bool) (phi2 Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (($check_equiv2 (@cl (= phi1 phi2)) conclusion)
     ($cl_equal (@cl phi1 (not phi2)) conclusion)
   )
   (($check_equiv2 (= phi1 phi2) conclusion)
     ($cl_equal (@cl phi1 (not phi2)) conclusion)
   )
  )
)

; rule: equiv2
; implements: TODO?
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
;   The premise could be embedded within a unit clause, built with @cl.
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi2 => phi1.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
; conclusion:
(declare-rule equiv2 ((premise Bool))
  :premises (premise)
  :requires ((($check_equiv2 premise eo::conclusion) true))
  :conclusion-given
)

(program $check_not_equiv1 ((phi1 Bool) (phi2 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_equiv1 (@cl (not (= phi1 phi2))) refCL)
     ($cl_equal (@cl phi1 phi2) refCL)
   )
   (($check_not_equiv1 (not (= phi1 phi2)) refCL)
     ($cl_equal (@cl phi1 phi2) refCL)
   )
  )
)

(declare-rule not_equiv1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_equiv1 CL refCL) true))
  :conclusion refCL
)

;-------------
; Rule 48: and_pos
;-------------

; program: check_and_pos
; args:
; - pos Int: Position of the selected conjunct. 
;            0 <= pos <= number of conjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, where the antecedent is 
;   a conjunction.
(program $check_and_pos ((pos Int) (antecedent Bool) (consequent Bool))
  (Int Bool) Bool
  (
   (($check_and_pos pos (@cl (not antecedent) consequent))
    ($cl_equal ($f_list_index and antecedent pos) consequent))

   ; To simplify the use of the checker
   (($check_and_pos pos (@cl consequent (not antecedent)))
    ($cl_equal ($f_list_index and antecedent pos) consequent))
  )
)

;TRUST
; rule: and_pos
; implements: TODO?
; args:
; - pos Int: Position of the conjunct selected in the weakening. 
;            0 <= pos <= number of conjuncts - 1
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of an instance of the weakening rule for implication,
;   where the antecedent is a conjunction.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and_pos ((pos Int))
  :args (pos)
  :requires ((($check_and_pos pos eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 49: and_neg
;-------------

; program: check_and_neg
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of and_neg. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
(program $check_and_neg ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   (($check_and_neg (@cl left_disjunct right_disjunct))
    ($cl_equal ($de_morgan_not_and left_disjunct)
              right_disjunct))
  )
)

; rule: and_neg
; implements: TODO?
; requires: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule and_neg ()
  :requires ((($check_and_neg eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 50: or_pos
;-------------

; program: check_or_pos
; args:
; - conclusion Bool: >
;   Conclusion given to rule or_pos. It is expected to be built with @cl.
; return: >
;   A boolean indicating if conclusion is of the form
;   ¬¨(ùúë1 ‚à®‚ãØ‚à®ùúëùëõ), ùúë1, ‚Ä¶ , ùúëùëõ, for some given propositions ùúë1, ..., ùúëùëõ.
(program $check_or_pos ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   (($check_or_pos (@cl (not left_disjunct) right_disjunct))
    ($cl_equal ($convert_or_to_cl left_disjunct)
              (@cl right_disjunct))
    )
  )
)

; rule: or_pos
; implements: TODO?
; requires: >
;   For the conclusion to be of the form
;   ¬¨(ùúë1 ‚à®‚ãØ‚à®ùúëùëõ), ùúë1, ‚Ä¶ , ùúëùëõ, for some given propositions ùúë1, ..., ùúëùëõ.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or_pos ()
  :requires ((($check_or_pos eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 51: or_neg
;-------------

; program: check_or_neg
; args:
; - pos Int: Position of the selected disjunct.
;            0 <= pos <= number of disjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, with the form 
;   not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
(program $check_or_neg ((index Int) (left_disjunct Bool) (right_disjunct Bool))
  (Int Bool) Bool
  (
   (($check_or_neg index (@cl left_disjunct (not right_disjunct)))
    ($prop_syntax_eq ($f_list_index or left_disjunct index) right_disjunct))
   
   (($check_or_neg index (@cl (not left_disjunct) right_disjunct))
    ($prop_syntax_eq right_disjunct ($f_list_index or left_disjunct index)))
  )
)

; rule: or_neg
; implements: TODO?
; args:
; - index Int: The index of the disjunct which is weakened in the conclusion.
; requires: >
;   Th conclusion must be an instance of the weakening rule for implication, 
;   with the form not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule or_neg ((index Int))
  :args (index)
  :requires ((($check_or_neg index eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_xor_pos1 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_pos1 CL) true)
  )
)

;TRUST
(declare-rule xor_pos1 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_pos1 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_pos2 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_pos2 CL) true)
  )
)

;TRUST
(declare-rule xor_pos2 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_pos2 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_neg1 CL) true)
  )
)

;TRUST
(declare-rule xor_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_neg2 CL) true)
  )
)

;TRUST
(declare-rule xor_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_neg2 CL) true))
  :conclusion CL
)

;-------------
; Rule 56: implies_pos
;-------------

; program: check_implies_pos; 
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of implies_pos. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is an instance of excluded middle,
;   for a proposition of the form phi_1 -> phi_2.
(program $check_implies_pos ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   (($check_implies_pos (@cl (not (=> phi_1 phi_2)) phi_3 phi_4))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   (($check_implies_pos (@cl phi_3 (not (=> phi_1 phi_2)) phi_4))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   (($check_implies_pos (@cl phi_3 phi_4 (not (=> phi_1 phi_2))))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
  )
)

; rule: implies_pos
; implements: TODO?
; requires: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form phi_1 -> phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_pos ()
  :requires ((($check_implies_pos eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 57: implies_neg1
;-------------

; program: check_implies_neg1
; args:
; - CL Bool: >
;   This should be the conclusion to the application of implies_neg1. It must be
;   a clause built with @cl.
; return:
;   A boolean indicating if "conclusion" is cl_equal to phi_1 -> phi_2, phi1,
;   for some propositions phi_1 and phi_2.
(program $check_implies_neg1 ((phi_1 Bool) (phi_2 Bool))
  (Bool) Bool
  (
   (($check_implies_neg1 (@cl (=> phi_1 phi_2) phi_1))
    true)

   (($check_implies_neg1 (@cl phi_1 (=> phi_1 phi_2)))
    true)

   (($check_implies_neg1 phi_1)
    false)
  )
)

; rule: implies_neg1
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be cl_equal to phi_1 -> phi_2, phi1,
;   for some propositions phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_neg1 ()
  :requires ((($check_implies_neg1 eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 58: implies_neg2
;-------------

; program: check_implies_neg2
; args:
; - CL Bool: >
;   This should be the conclusion to the application of implies_neg2. It must be
;   a clause built with @cl.
; return:
;   A boolean indicating if "conclusion" is cl_equal to phi_1 -> phi_2, not phi2,
;   for some propositions phi_1 and phi_2.
(program $check_implies_neg2 ((phi_1 Bool) (phi_2 Bool))
  (Bool) Bool
  (
   (($check_implies_neg2 (@cl (=> phi_1 phi_2) (not phi_2)))
    true)

   (($check_implies_neg2 (@cl (not phi_2) (=> phi_1 phi_2)))
    true)

   (($check_implies_neg2 phi_1)
    false)
  )
)

; rule: implies_neg2
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be cl_equal to phi_1 -> phi_2, not phi2,
;   for some propositions phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_neg2 ()
  :requires ((($check_implies_neg2 eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 59: equiv_pos1
;-------------

; program: check_equiv_pos1
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of equiv_pos1. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is cl_equal to the clause 
;   not (phi_1 = phi2), phi_1, not phi_2, for some props. phi_1 and phi_2.
(program $check_equiv_pos1 ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   (($check_equiv_pos1 (@cl (not (= phi_1 phi_2)) phi_3 phi_4))
    ($cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))
   
   (($check_equiv_pos1 (@cl phi_3 (not (= phi_1 phi_2)) phi_4))
    ($cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))
   
   (($check_equiv_pos1 (@cl phi_3 phi_4 (not (= phi_1 phi_2))))
    ($cl_equal (@cl phi_1 (not phi_2)) (@cl phi_3 phi_4)))

   (($check_equiv_pos1 phi_1)
    false)
  )
)

; rule: equiv_pos1
; implements: TODO?
; requires: >
;   Requires for the conclusion to be cl_equal to the clause 
;   not (phi_1 = phi2), phi_1, not phi_2, for some props. phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_pos1 ()
  :requires ((($check_equiv_pos1 eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 60: equiv_pos2
;-------------

; program: check_equiv_pos2
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of equiv_pos2. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is cl_equal to the clause 
;   not (phi_1 = phi2), not phi_1, phi_2, for some props. phi_1 and phi_2.
(program $check_equiv_pos2 ((phi_1 Bool) (phi_2 Bool) (phi_3 Bool) (phi_4 Bool))
  (Bool) Bool
  (; TODO: simplify this
   (($check_equiv_pos2 (@cl (not (= phi_1 phi_2)) phi_3 phi_4))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
   
   (($check_equiv_pos2 (@cl phi_3 (not (= phi_1 phi_2)) phi_4))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))
   
   (($check_equiv_pos2 (@cl phi_3 phi_4 (not (= phi_1 phi_2))))
    ($cl_equal (@cl (not phi_1) phi_2) (@cl phi_3 phi_4)))

   (($check_equiv_pos2 phi_1)
    false)
  )
)

; rule: equiv_pos2
; implements: TODO?
; requires: >
;   Requires for the conclusion to be cl_equal to the clause 
;   not (phi_1 = phi2), not phi_1, phi_2, for some props. phi_1 and phi_2.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_pos2 ()
  :requires ((($check_equiv_pos2 eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_equiv_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_equiv_neg1 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_equiv_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_equiv_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_equiv_neg2 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_equiv_neg2 CL) true))
  :conclusion CL
)

(program $check_ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_ite1 (@cl (ite phi1 phi2 phi3)) refCL)
     ($cl_equal (@cl phi1 phi3) refCL)
   )
   (($check_ite1 (ite phi1 phi2 phi3) refCL)
     ($cl_equal (@cl phi1 phi3) refCL)
   )
  )
)

(declare-rule ite1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_ite1 CL refCL) true))
  :conclusion refCL
)

(program $check_ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_ite2 (@cl (ite phi1 phi2 phi3)) refCL)
     ($cl_equal (@cl (not phi1) phi2) refCL)
   )
   (($check_ite2 (ite phi1 phi2 phi3) refCL)
     ($cl_equal (@cl (not phi1) phi2) refCL)
   )
  )
)

(declare-rule ite2 ((refCL Bool) (CL Bool))
  :premises (CL)
  :requires ((($check_ite2 CL eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_ite_pos1 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_pos1 CL) true)
  )
)

;TRUST
(declare-rule ite_pos1 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_pos1 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_pos2 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_pos2 CL) true)
  )
)

;TRUST
(declare-rule ite_pos2 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_pos2 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_neg1 CL) true)
  )
)

;TRUST
(declare-rule ite_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_neg2 CL) true)
  )
)

;TRUST
(declare-rule ite_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_neg2 CL) true))
  :conclusion CL
)

(program $check_not_ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_ite1 (@cl (not (ite phi1 phi2 phi3))) refCL)
     ($cl_equal (@cl phi1 (not phi3)) refCL)
   )
   (($check_not_ite1 (not (ite phi1 phi2 phi3)) refCL)
     ($cl_equal (@cl phi1 (not phi3)) refCL)
   )
  )
)

(declare-rule not_ite1 ((refCL Bool) (CL Bool))
  :premises (CL)
  :args (refCL)
  :requires ((($check_not_ite1 CL refCL) true))
  :conclusion refCL
)

(program $check_not_ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (refCL Bool))
  (Bool Bool) Bool
  (
   (($check_not_ite2 (@cl (not (ite phi1 phi2 phi3))) refCL)
     ($cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
   (($check_not_ite2 (not (ite phi1 phi2 phi3)) refCL)
     ($cl_equal (@cl (not phi1) (not phi2)) refCL)
   )
  )
)

;TODO
(program $check_connective_def ((conclusion Bool))
  (Bool) Bool
  (
   (($check_connective_def conclusion) true)
  )
)

;TRUST
(declare-rule connective_def ((conclusion Bool))
  :requires ((($check_connective_def eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_and_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_and_simplify l r) true)
  )
)

;TRUST
(declare-rule and_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_and_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_or_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_or_simplify conclusion) true)
  )
)

;TRUST
(declare-rule or_simplify ()
  :requires ((($check_or_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_not_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_not_simplify conclusion) true)
  )
)

;TRUST
(declare-rule not_simplify ()
  :requires ((($check_not_simplify eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 75: implies_simplify
;-------------

; program: check_implies_simplify
; args:
; - conclusion Bool: Conclusion provided to rule implies_simplify.
; return: >
;   A boolean indicating if conclusion has the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_implication".
(program $check_implies_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   (($check_implies_simplify (@cl (= (=> phi_1 phi_2) psy)))
                            ; TODO: use proper comparison for props
                            ($cl_equal (@cl ($rewrite_implication (=> phi_1 phi_2)))
                                      (@cl psy)))
  )
)

; rule: implies_simplify
; implements: TODO?
; requires: >
;   For the conclusion to be of the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì 
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_implication".
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule implies_simplify ()
  :requires ((($check_implies_simplify eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 76: equiv_simplify
;-------------
; program: check_equiv_simplify
; args:
; - conclusion Bool: Conclusion provided to rule equiv_simplify.
; return: >
;   A boolean indicating if conclusion has the form (ùúë1 ‚âà ùúë2) ‚âà ùúì, where ùúì 
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_equivalence".
(program $check_equiv_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   (($check_equiv_simplify (@cl (= (= phi_1 phi_2) psy)))
                            ; TODO: use proper comparison for props
                            ($cl_equal (@cl ($rewrite_equivalence (= phi_1 phi_2)))
                                      (@cl psy)))
  )
)

; rule: equiv_simplify
; implements: TODO?
; requires: >
;   For the conclusion to be of the form ùúë1 ‚Üí ùúë2 ‚âà ùúì, where ùúì
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_equivalence".
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule equiv_simplify ()
  :requires ((($check_equiv_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_bool_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_bool_simplify conclusion) true)
  )
)

;TRUST
(declare-rule bool_simplify ()
  :requires ((($check_bool_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_ac_simp ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_ac_simp l r) true)
  )
)

;TRUST
(declare-rule ac_simp ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_ac_simp l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_ite_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_ite_simplify l r) true)
  )
)

;TRUST
(declare-rule ite_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_ite_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_qnt_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_qnt_simplify l r) true)
  )
)

;TRUST
(declare-rule qnt_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_qnt_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_onepoint ((conclusion Bool))
  (Bool) Bool
  (
   (($check_onepoint conclusion) true)
  )
)
; (program $check_onepoint ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
;   (Bool T T T T) Bool
;   (
;    (($check_onepoint ctx l r l1 r1) true)
;   )
; )

;TRUST
(declare-rule onepoint ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  ; :premises (old_ctx (@cl (= l1 r1)))
  ; :args ((@cl (= l r)))
  ; :requires ((($context_is_extended ctx old_ctx) true) (($check_onepoint ctx l r l1 r1) true))
  :requires ((($check_onepoint eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_qnt_join ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_join conclusion) true)
  )
)

;TRUST
(declare-rule qnt_join ()
  :requires ((($check_qnt_join eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_qnt_rm_unused ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_rm_unused conclusion) true)
  )
)

;TRUST
(declare-rule qnt_rm_unused ()
  :requires ((($check_qnt_rm_unused eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_eq_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_simplify conclusion) true)
  )
)

;TRUST
(declare-rule eq_simplify ()
  :requires ((($check_eq_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_div_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_div_simplify l r) true)
  )
)

;TRUST
(declare-rule div_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_div_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_prod_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_prod_simplify conclusion) true)
  )
)

;TRUST
(declare-rule prod_simplify ()
  :requires ((($check_prod_simplify eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_unary_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_unary_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule unary_minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_unary_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_sum_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_sum_simplify l r) true)
  )
)

;TRUST
(declare-rule sum_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_sum_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_comp_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_comp_simplify l r) true)
  )
)

;TRUST
(declare-rule comp_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_comp_simplify l r) true))
  :conclusion (@cl (= l r))
)

;-------------
; Rule 91: let
;-------------

(program $verify_let_premises ((context Bool) (premises Bool) 
                              (A Type) (var A)
                              (B Type) (value B)
                              (tl @VarList :list))
  (Bool Bool @VarList) Bool
  (
   (
    ($verify_let_premises context premises 
                         ($f_list_cons @varlist 
                                      ($f_list_cons @varlist var value) 
                                      tl))
    (eo::or ($f_list_contains_elem 
             and 
             (@cl (= value ($context_get_substitute context var)))
             premises)
            ($verify_let_premises context premises tl)
            )
    )

   (
    ($verify_let_premises context premises @varlist.nil)
    
    true
    )
   )
)

; This has to traverse the lets and the premises. Also has to check the
; context extension.
; program: check_let_elim
; args:
; - ctx Bool:
; - Cs Bool:
; - conclusion Bool:
; return:
(program $check_let_elim ((context Bool) (premises Bool) 
                         (let_type Type) (let_def let_type)
                         (var_defs @VarList) 
                         (A Type) (lhs A) (rhs A)
                         (B Type)
                         (var_values B))
  (Bool Bool let_type) Bool
  (
   (
    ($check_let_elim context premises
                    (@cl (= let_def rhs)))

    (eo::and 
     ; There should be a conclusion of the form (@cl (= lhs rhs))
     ; TODO: this conclusion must be just of the previous step
     ($f_list_contains_elem and (@cl (= ($let_get_body let_def) rhs)) premises)
     ($verify_let_premises context premises 
                          ($let_get_vars_substitutes ($let_get_vars let_def)
                                                    ($let_get_values let_def)))
     )
    )
   )
)

; rule: let_elim
; assumption:
; - ctx: Context from the actual subproof.
; premise-list:
; - Cs: Surrounding context 
; conclusion: >
;   
; note: >
(declare-rule let_elim ((ctx Bool) (premises Bool))
  :assumption ctx
  :premise-list premises and
  :requires ((($check_let_elim ctx premises eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 93: distinct_elim
;-------------

; program: build_distinct_list
; args:
; - list Bool: An and-list of distinct-list elements.
; return:
; Returns the reinterpretation of the given and-list of distinct-list elements,
; as a conjunction of inequalities.
(program $build_distinct_list ((A Type) (lhs A) (rhs A) (tl Bool :list))
  (Bool) Bool
  (
   (($build_distinct_list (and (distinct lhs rhs) tl))

    ($f_list_cons and 
                 (not (= lhs rhs)) 
                 ($build_distinct_list tl)))

   ; Only one proposition
   (($build_distinct_list (distinct lhs rhs)) 

    (not (= lhs rhs)))

   ; Only one proposition
   (($build_distinct_list (distinct lhs)) 

    true)
   
   (($build_distinct_list true) 

    true)
  )
)

; TODO: DELETE THIS IF WE FIND A GENERIC WAY TO IMPLEMENT THIS

; program: conjunction_contains_ineq
; args:
; - ineq Bool: >
;   An inequality of the form (not (= lhs rhs)), for some terms lhs and rhs of
;   type A.
; - conjunctions Bool: A conjunctions of inequalities of the form (not (= lhs' rhs'))
; return:
;   A boolean indicating if ineq appears in "conjunctions".
(program $conjunction_contains_ineq ((A Type) (lhs A) (rhs A) (hd Bool) (tl Bool :list))
  (Bool Bool) Bool
  (
   (($conjunction_contains_ineq (not (= lhs rhs)) (and (not (= lhs rhs)) tl))

    true)

   (($conjunction_contains_ineq (not (= lhs rhs)) (and (not (= rhs lhs)) tl))

    true)

   ; { hd =/= not (= rhs lhs))}
   (($conjunction_contains_ineq (not (= lhs rhs)) (and hd tl))

    ($conjunction_contains_ineq (not (= lhs rhs)) tl))

   
   (($conjunction_contains_ineq (not (= lhs rhs)) (not (= lhs rhs)))

    true)

   (($conjunction_contains_ineq (not (= lhs rhs)) (not (= rhs lhs)))

    true)

   ; { hd =/= (not (= lhs rhs))}
   (($conjunction_contains_ineq (not (= lhs rhs)) hd)

    false)
  )
)

; program: conjunction_contains_conjunction
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return:
; A boolean indicating if the elements from list_1 also appear in list_2.
(program $conjunction_contains_conjunction ((hd Bool) (tl Bool :list)
                                           (f_list_2 Bool))
  (Bool Bool) Bool
  (
   (($conjunction_contains_conjunction (and hd tl) f_list_2)
    ; TODO: I need some way to build boolean values
    ; combining other boolean values, but I would like
    ; to avoid built-in operators.
    (eo::and ($conjunction_contains_ineq hd f_list_2)
             ($conjunction_contains_conjunction tl f_list_2)))

 
   ; { f_list_1 is not an and-list}
   (($conjunction_contains_conjunction true f_list_2)
    true)
   
   ; { hd must be an inequaity }
   (($conjunction_contains_conjunction hd f_list_2)
    ($conjunction_contains_ineq hd f_list_2))
  )
)

; program: conjunctions_equal
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return: >
; A boolean indicating if the conjuncts from list_1 and list_2 are the 
; same, regardless of the order.
(program $conjunctions_equal ((list_1 Bool) (list_2 Bool))
  (Bool Bool) Bool
  (
   (($conjunctions_equal list_1 list_2)
    (eo::and ($conjunction_contains_conjunction list_1 list_2)
             ($conjunction_contains_conjunction list_2 list_1)))
  )
)

; program: check_distinct_elim
; args:
; - conclusion Bool: The conclusion give to the distinct_elim rule.
; return:
; A Boolean indicating if the given "conclusion" has the shape
; (distinct ùë°1 ‚Ä¶ ùë°ùëõ) ‚âà ‚ãÄ ùë°ùëñ ‚âà/‚âà ùë°ùëó.
(program $check_distinct_elim ((A Type) (hd A) (inequalities Bool) (conjunctions Bool))
  (Bool) Bool
  (; TODO: assuming that inequalities come first
   (($check_distinct_elim (@cl (= inequalities conjunctions)))
    ($conjunctions_equal ($build_distinct_list inequalities)
                        conjunctions))

   ; Only one proposition
   (($check_distinct_elim (@cl (= (distinct hd) true))) true)
  )
)

; rule: distinct_elim
; implements: TODO?
; requires: >
;   Requires for "conclusion" to be of the shape
;   (distinct ùë°1 ‚Ä¶ ùë°ùëõ) ‚âà ‚ãÄ ùë°ùëñ ‚âà/‚âà ùë°ùëó.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule distinct_elim ()
  :requires ((($check_distinct_elim eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 94: la_rw_eq
;-------------

; program: check_la_rw_eq
; args:
; - conclusion Bool: >
;   The conclusion provided to the la_rw_eq rule. Must be built with @cl.
; return: >
;   A boolean indicating if "conclusion" is a clause of the form 
;   (= (= t u) (and (<= t u) (<= u t))), for some numbers t and u.
(program $check_la_rw_eq ((t Real) (u Real))
  (Bool) Bool
  (
   (($check_la_rw_eq (@cl (= (= t u) (and (<= t u) (<= u t))))) true)
  )
)

; TODO: other number types. Can the equality be flipped?
; rule: la_rw_eq
; implements: TODO?
; requires: >
;   Requires for the conclusion to be a clause of the form 
;   (= (= t u) (and (<= t u) (<= u t))), for some numbers t and u.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule la_rw_eq ()
  :requires ((($check_la_rw_eq eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 95: nary_elim
;-------------

; program: check_nary_elim
; args:
; - conclusion Bool: >
;   Conclusion given to rule nary_elim. It must be built with @cl.
; return:
;   - A boolean indicating if conclusion has one of the following forms:
;     ‚óã ùë°ùëñ ‚âà (‚Ä¶ ((ùë°1 ‚àòùë°2) ‚àòùë°3) ‚àò‚ãØùë°ùëõ) (for a left assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àò‚ãØ‚àò(ùë°ùëõ‚àí2 ‚àò(ùë°ùëõ‚àí1 ‚àòùë°ùëõ) ‚Ä¶ ) (for a right assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àòùë°2) ‚àß(ùë°2 ‚àòùë°3) ‚àß‚ãØ‚àß (ùë°ùëõ‚àí1 ‚àòùë°ùëõ) (for a chainable operator ‚àò)
;   - ‚àò cannot be ‚àß or ‚à®.
(program $check_nary_elim ((A Type) (hd A) (tl A :list))
  (Bool) Bool
  (; TODO: check that op is not /\ nor \/
   ; TODO: do we have reflection mechanisms, useful to inspect properties
   ; of each operator, and define this program in a generic way?
   (($check_nary_elim (@cl (= (=> hd tl) (=> hd tl))))
    ; right-assoc operator
    ; We leverage the desugaring process, that turns both lists
    ; into the folded application of the operator, already
    ; associated to the right.
    true
    )
  )
)

; rule: nary_elim
; implements: TODO?
; requires: >
;   - The conclusion should have one of the following forms:
;     ‚óã ùë°ùëñ ‚âà (‚Ä¶ ((ùë°1 ‚àòùë°2) ‚àòùë°3) ‚àò‚ãØùë°ùëõ) (for a left assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àò‚ãØ‚àò(ùë°ùëõ‚àí2 ‚àò(ùë°ùëõ‚àí1 ‚àòùë°ùëõ) ‚Ä¶ ) (for a right assoc. operator ‚àò)
;     ‚óã ùë°ùëñ ‚âà (ùë°1 ‚àòùë°2) ‚àß(ùë°2 ‚àòùë°3) ‚àß‚ãØ‚àß (ùë°ùëõ‚àí1 ‚àòùë°ùëõ) (for a chainable operator ‚àò)
;   - ‚àò cannot be ‚àß or ‚à®.
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule nary_elim ()
  :requires ((($check_nary_elim eo::conclusion) true))
  :conclusion-given
)

;TODO
(program $check_bfun_elim ((psi Bool) (phi Bool))
  (Bool Bool) Bool
  (
   (($check_bfun_elim (@cl psi) phi) true)
  )
)

;TRUST
(declare-rule bfun_elim ((psi Bool) (phi Bool))
  :premises (psi)
  :args ((@cl phi))
  :requires ((($check_bfun_elim ($to_cl psi) phi) true))
  :conclusion (@cl phi)
)

;TODO
(program $check_ite_intro ((conclusion Bool))
  (Bool) Bool
  (
   (($check_ite_intro conclusion) true)
  )
)

;TRUST
(declare-rule ite_intro ()
  :requires ((($check_ite_intro eo::conclusion) true))
  :conclusion-given
)

;-------------
; Table 10: Rules used by cvc5, but not by veriT
;-------------

;-------------
; Rule 101: symm
;-------------
; program: check_symm
; args:
; - premise Bool: >
;   Premise given to rule symm. It could be  with @cl.
; - conclusion Bool: >
;   Conclusion given to rule symm. It must be built with @cl.
; return: >
;   A boolean indicating if conclusion is of the form (@cl (= psy phi)), for a 
;   given premise (@cl (= phi psy)) or (= psi psy). 
(program $check_symm ((phi Bool) (psy Bool))
  (Bool Bool) Bool
  (
   (
    ($check_symm (= phi psy) (@cl (= psy phi))) 

    true
    )

   (
    ($check_symm (@cl (= phi psy)) (@cl (= psy phi))) 

    true
    )
  )
)

; rule: symm
; implements: TODO?
; requires: >
;   The conclusion should have the form (@cl (= psy phi)), for a given
;   premise (@cl (= phi psy)) or (= psi psy).
; conclusion-given: >
;   Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule symm ((premise Bool))
  :premises (premise)
  :requires ((($check_symm premise eo::conclusion) true))
  :conclusion-given
)

;-------------
; Rule 34: reordering
;-------------

; program: check_reordering
; args:
; - premise Bool: >
;   Premise given to rule reordering. Must be a clause built with @cl.
; - conclusion Bool: >
;   Conclusion given to rule reordering. Must be a clause built with @cl.
; return: >
;   A boolean indicating if conclusion is a permutation of the premise.
(program $check_reordering ((hd_premise Bool) (tl_premise Bool :list)
                           (hd_conclusion Bool) (tl_conclusion Bool :list))
  (Bool Bool) Bool
  (
   (
    ($check_reordering (@cl hd_premise tl_premise) (@cl hd_conclusion tl_conclusion))

    ($check_reordering tl_premise 
                      ($f_list_remove_elem @cl (@cl hd_conclusion tl_conclusion) hd_premise false))
    )

   (
    ($check_reordering false false)

    true
    )

   (
    ($check_reordering hd_premise hd_conclusion)

    false
    )
  )
)

;TRUST
; rule: reordering
; implements: TODO?
; premises:
; - premise Bool: >
;   Premise given to rule reordering. Must be a clause built with @cl.
; requires: >
;   For conclusion to be a permutation of the premise.
; conclusion-given: >
;  Only the "requires" predicate checks if a proper conclusion is given.
(declare-rule reordering ((premise Bool))
  :premises (premise)
  :requires ((($check_reordering premise eo::conclusion) 
              true))
  :conclusion-given
)

;-------------
; Rare
;-------------

;TODO
(program $check_rare_rewrite ((Flag Bool) (CL Bool))
  (Bool Bool) Bool
  (
   (($check_rare_rewrite Flag CL) true)
  )
)

;TRUST
(declare-rule rare_rewrite ((flag Bool))
  :args (flag)
  :requires ((($check_rare_rewrite flag eo::conclusion) true))
  :conclusion-given
)

;-------------
; Misc.
;-------------

(program $check_discard_context ((CL Bool))
  (Bool) Bool
  (
   (($check_discard_context CL) true)
  )
)

; TODO: dummy step-pop step, to discard contexts
(declare-rule discard_context ((ctx Bool))
  :assumption ctx
  ; :requires ((($check_discard_context eo::conclusion) true))
  :conclusion-given
)
