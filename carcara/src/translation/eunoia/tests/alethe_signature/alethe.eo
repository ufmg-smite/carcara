(include "./theory.eo")
(include "./programs.eo")

; Rule: assume is native
; Note: The hole here does not allow for args or premises.

; rule: hole
; conclusion: Just the arbitrary conclusion passed to the rule.
; sorry: >
;   This models the following (taken from the standard spec.):
;   "A proof checker must not accept as valid a proof that contains this
;     rule even if the checker can somehow check this rule."
(declare-rule hole ((conclusion Bool))
  :conclusion-explicit (@cl conclusion)
  :sorry
)

(declare-rule true ()
  :conclusion-explicit (@cl true)
)

;-------------
; Rule 4: false
;-------------

; rule: false
; conclusion: Conclusion must be of the form (@cl (not false)).
(declare-rule false ()
  :conclusion-explicit (@cl (not false))
)

;-------------
; Rule 5: not_not
;-------------

; rule: not_not
; conclusion: >
;   Conclusion should be of the form ¬(¬¬𝜑), 𝜑, for some proposition 𝜑.
(declare-rule not_not ((phi Bool))
  :conclusion-explicit (@cl (not (not (not phi))) phi)
)

;-------------
; Rule 6: th_resolution
;-------------

; program: $normalize_single_clause
; args:
; - clause Bool: A clause built with @cl.
; return: >
;    A clause logically equivalent to "clause", where leading double negations
;    in disjuncts are removed.
(program $normalize_single_clause ((literal Bool) (literals Bool :list))
         :signature (Bool) Bool
         (
          (
           ($normalize_single_clause (@cl (not (not literal)) literals))

           ($f_list_cons @cl literal 
                         ($normalize_single_clause literals))
           )

          (; { "literal" does not begin with a double negation } 
           ($normalize_single_clause (@cl literal literals))

           ($f_list_cons @cl literal
                         ($normalize_single_clause literals))
           )

          (
           ($normalize_single_clause (@cl false false literals))

           ($f_list_cons @cl false
                         ($normalize_single_clause literals))
           )

          (
           ($normalize_single_clause false)

           false
           )
          )
         )

; program: $normalize_clauses
; args:
; - clauses Bool: And-list of clauses.
; return: >
;    An and-list of clauses logically equivalent to "clauses", where each single
;    "clause" is normalized, according to $normalize_single_clause.
(program $normalize_clauses ((clause Bool) (clauses Bool :list))
         :signature (Bool) Bool
         (
          (
           ($normalize_clauses (and clause clauses))

           ($f_list_cons and ($normalize_single_clause clause)
                         ($normalize_clauses clauses))
           )

          (
           ($normalize_clauses true)

           true
           )
          )
         )

; program: $clause_contains_pivot
; args:
; - clause Bool: Clause within which we want to search for "pivot".
; - pivot Bool: Pivot to search within "clause".
; - $clause_contains_pivot nil:
; return: A bool indicating if "pivot" is contained within "clause".
(program $clause_contains_pivot ((hd Bool) (tail Bool :list) 
                                 (pivot Bool))
         :signature (Bool Bool) Bool
         (
          (
           ($clause_contains_pivot (@cl pivot tail) pivot)

           true
           )

          (; { hd <> pivot }
           ($clause_contains_pivot (@cl hd tail) pivot)

           ($clause_contains_pivot tail pivot)
           )

          (
           ($clause_contains_pivot false pivot)

           false
           )
           )
         )

; program: $remove_pivot_from_clause
; args:
; - pivot Bool: Pivot literal contained in "clause".
; - clause Bool: Clause containing the pivot.
; return: The clause obtained from removing "pivot" from "clause".
; note: PRE : { "pivot" is contained in "clause" }
(program $remove_pivot_from_clause ((hd Bool) (tail Bool :list) 
                                      (pivot Bool))
         :signature (Bool Bool) Bool
         (
          (
           ($remove_pivot_from_clause pivot (@cl pivot tail))

           tail
           )

          (; { hd <> pivot }
           ($remove_pivot_from_clause pivot (@cl hd tail))

           ($f_list_cons @cl 
                         hd 
                         ($remove_pivot_from_clause pivot tail))
           )
          )
         )

; program: $find_and_remove_pivot_from_clauses
; args:
; - pivot Bool: >
;   Pivot to be found and removed from the corresponding clause, if it exists.
; - clauses Bool: And-list of clauses.
; return: The clause containing "pivot", without "pivot" itself.
; note: PRE : { "pivot" is contained in some clause from "clauses" }
(program $find_and_remove_pivot_from_clauses ((clause Bool) (clauses Bool :list) 
                                               (pivot Bool))
         :signature (Bool Bool) Bool
         (
          (; By pre, "clause" should contain "pivot".
           ($find_and_remove_pivot_from_clauses pivot (and clause true))
           
           ($remove_pivot_from_clause pivot clause)
           )

          (
           ($find_and_remove_pivot_from_clauses pivot (and clause clauses))

           (eo::ite ($clause_contains_pivot clause pivot)

                  ($remove_pivot_from_clause pivot clause)
                  
                  ($find_and_remove_pivot_from_clauses pivot clauses)
                  )
           )
          )
)

; program: $check_resolution_with_normalized_clauses 
; args:
; - clauses Bool: And-list of normalized clauses (double negation is simplified).
; - pivots @VarList: A list of pivots used during resolution.
; - conclusion Bool: Conclusion provided to the rule.
; return: >
;   A boolean indicating if "conclusion" is a resolvent that can be
;   obtained from applying resolution over "clauses", using the pivots
;   contained in "pivots", in the same order of their appearance in the list.
; note: PRE : { "clauses" are normalized: double negation is simplified }
(program $check_resolution_with_normalized_clauses  ((clauses Bool) 
                                                     (pivot @VarList) (pivots @VarList :list)
                            (conclusion Bool))
  (Bool @VarList Bool) Bool
  (
   (; TODO: Still don't know the purpose of these "false" pivots
    ($check_resolution_with_normalized_clauses clauses (@varlist false pivots)
                                               conclusion)
    
    ($check_resolution_with_normalized_clauses clauses pivots conclusion)
    )

   (; TODO: Sometimes with might get a pivot that is in its negated form
    ($check_resolution_with_normalized_clauses clauses (@varlist pivot pivots)
                                               conclusion)

    (eo::define
     (
      (clause_without_pivot
       ;; We normalize to remove repeated occurrences of "false"
       ($normalize_single_clause
        ($find_and_remove_pivot_from_clauses pivot clauses)))

      (clause_without_not_pivot
       ;; We normalize to remove repeated occurrences of "false"
       ($normalize_single_clause
        ($find_and_remove_pivot_from_clauses (not pivot) clauses)))
      )

     ; eo::define's body:
     (eo::ite (eo::or ($cl_equal clause_without_pivot conclusion)
                      ($cl_equal clause_without_not_pivot conclusion))

              true

              ;; {not ($cl_equal new_clause conclusion) }
              ($check_resolution_with_normalized_clauses 
               ($f_list_cons and clause_without_pivot
                             ($f_list_cons and clause_without_not_pivot
                                           clauses))
               pivots conclusion)
              )
     )
    )

   (
    ($check_resolution_with_normalized_clauses clauses @varlist.nil conclusion)

    false
    )
   )
)

; program: $check_resolution
; args:
; - clauses Bool: And-list of clauses.
; - pivots @VarList: A list of pivots used during resolution.
; - conclusion Bool: Conclusion provided to the rule.
; return: >
;   A boolean indicating if "conclusion" is a resolvent that can be
;   obtained from applying resolution over "clauses", using the pivots
;   contained in "pivots", in the same order of their appearance in the list.
(program $check_resolution ((clauses Bool) (pivots @VarList)
                            (conclusion Bool))
  (Bool @VarList Bool) Bool
  (
   (; TODO: Still don't know the purpose of these "false" pivots
    ($check_resolution clauses pivots conclusion)

    ($check_resolution_with_normalized_clauses 
     ($normalize_clauses clauses) pivots conclusion)
    )
   )
)

(declare-rule th_resolution ((premises Bool) (conclusion Bool) (pivots @VarList))
  :premise-list premises and
  :args (pivots)
  :requires ((($check_resolution premises pivots conclusion) true))
  :conclusion-explicit conclusion
)

;TRUST
(declare-rule resolution ((premises Bool) (conclusion Bool) (pivots @VarList))
  :premise-list premises and
  :args (pivots)
  :requires ((($check_resolution premises pivots conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_tautology ((CL1 Bool))
  (Bool) Bool
  (
   (($check_tautology CL1) true)
  )
)

;TRUST
(declare-rule tautology ((CL1 Bool))
  :premises (CL1)
  :args ((@cl true))
  :requires ((($check_tautology CL1) true))
  :conclusion (@cl true)
)

;-------------
; Rule 9: contraction
;-------------

; program: check_contraction
; args:
; - premise Bool: Premise given to rule "contraction". Must be a @cl.
; - conclusion Bool: Conclusion given to rule "contraction". Must be a @cl.
; return:
;   A boolean indicating if conclusion is equivalent to premise, without 
;   duplicated disjuncts.
(program $check_contraction ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (
    ; Check that both clauses contain the same elements, regardless of order
    ; and possible repetitions.
    ($check_contraction premise conclusion)

    ($f_list_equal @cl ($cl_remove_duplicates premise) conclusion)
    )
   )
  )

; rule: contraction
; premises:
; - premise Bool: A clause from which we want to eliminate duplicated literals.
; requires: >
;   For the conclusion to be equivalent to premise, with removed duplicated disjuncts.
; conclusion: The previously described conclusion.
(declare-rule contraction ((premise Bool) (conclusion Bool))
  :premises (premise)
  :requires ((($check_contraction premise conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 10: subproof
;-------------

; program: $check_subproof
; args:
; - assumption Bool: Assumption passed to "subproof".
; - premise Bool: Last step before the application of "subproof".
; - conclusion Bool: Conclusion of the "subproof" step.
; return: >
;   A boolean indicating if "conclusion" is of the form 
;   (@cl (not assumption), premise)
(program $check_subproof ((assumption Bool) (premise Bool) 
                          (conclusion Bool))
  (Bool Bool Bool) Bool
  (
   (
    ($check_subproof (@cl assumption) @empty_cl conclusion)

    (eo::and
     ($f_list_contains_elem @cl (not assumption) conclusion)
     ; To deal with the inclusion of @empty_cl within conclusion
     ($f_list_contains_elem @cl false conclusion))
    )

   (; { premise =/= @empty_cl }
    ($check_subproof (@cl assumption) premise conclusion)

    (eo::and
     ($f_list_contains_elem @cl (not assumption) conclusion)
     ($f_list_contains_f_list @cl premise conclusion))
    )
  )
)

; rule: subproof
; assumption:
; - assumption Bool: Assumption passed to "subproof".
; premises:
; - premise Bool: Last step before the application of "subproof".
; args:
; - conclusion Bool: Conclusion of the step.
; requires: >
;   For conclusion to be of the form (@cl (not assumption) premise).
;   Note that, for the cases where we have more than 1 assumption,
;   rule subproof is applied stepwise, discharging 1 assumption at a time.
; conclusion:  The previously described conclusion.
(declare-rule subproof ((assumption Bool) (premise Bool) (conclusion Bool))
  :assumption assumption
  :premises (premise)
  :requires ((($check_subproof assumption premise conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
; From "The Alethe Proof Format":
; "Checking the validity of this clause amounts to checking the unsatisfiability 
; of the system of linear equations 𝜑1, 𝜑2, … , 𝜑𝑛. The annotation of an 
; la_generic step contains a coefficient for each (in)equality. The result of 
; forming the linear combination of the literals with the coefficients is a trivial 
; inequality between constants".
(program $check_la_generic ((coeffs Real) (CL Bool))
  (Real Bool) Bool
  (
   (($check_la_generic coeffs CL) true)
  )
)

; NOTE: The coefficients are one single argument.  This means they must be
;       be wrapped in a single function call using an n-ary function.  See
;       the example `small.smt3`.
;TRUST
(declare-rule la_generic ((coeffs Real) (conclusion Bool))
  :args (coeffs)
  :requires ((($check_la_generic coeffs conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_lia_generic ((CL Bool))
  (Bool) Bool
  (
   (($check_lia_generic CL) true)
  )
)

;TRUST
(declare-rule lia_generic ((CL Bool))
  :args (CL)
  :requires ((($check_lia_generic CL) true))
  :conclusion CL
)

(declare-rule la_disequality ((t1 Real) (t2 Real))
  :args ((@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1)))))
  :conclusion (@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1))))
)

(declare-rule la_totality ((t1 Real) (t2 Real))
  :args ((@cl (or (<= t1 t2) (<= t2 t1))))
  :conclusion (@cl (or (<= t1 t2) (<= t2 t1)))
)

;TODO
(program $check_la_tautology ((CL Bool))
  (Bool) Bool
  (
   (($check_la_tautology CL) true)
  )
)

;TRUST
(declare-rule la_tautology ((CL Bool))
  :args (CL)
  :requires ((($check_la_tautology CL) true))
  :conclusion CL
)

;TODO
(program $check_la_mult_neg ((CL Bool))
  (Bool) Bool
  (
   (($check_la_mult_neg CL) true)
  )
)

;TRUST
(declare-rule la_mult_neg ((conclusion Bool))
  :requires ((($check_la_mult_neg conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 18: bind
;-------------
; TODO: remove this once we have higher-order programs
; program: $embed_within_vars
; args:
; - varlist @VarList: A list of names of variables.
; return: >
;   A @VarList obtained by embedding each name within varlist
;   within a @var construction (i.e., (@var (@varlist id) id) for a name id in 
;   varlist).
(program $embed_within_vars ((Var Type) (id Var) (tail @VarList :list))
         :signature (@VarList) @VarList
         (
          (
           ($embed_within_vars @varlist.nil)
           
           @varlist.nil
           )

          (
           ($embed_within_vars (@varlist id tail))
           
           ($f_list_cons @varlist 
                         (@var (@varlist id) id)
                         ($embed_within_vars tail))
           )
          )
)

; NOTE: Rules like `bind` can have multiple forms: without and with
; @var.  In the first case the bind rule is
;                @var xs. φ = @var ys. φ'
;              --­­------­­­­­------------­ bind
;                   ∀ xs. φ = ∀ ys. φ'
; This means that the variable that are free in the premise get bound by
; a @var.  However, since `bind` and other context-extending steps can
; be nested, it could also have the form
;              @var xs₁ ∪ xs₂. φ = @var ys₁ ∪ ys₂. φ'
;        --­­­­­­­--------------------------------­ bind
;             @var xs₁. ∀ xs₂. φ = @var ys₁. ∀ ys₂. φ'
; In situations where `bind` is combined with rules like `sko_ex`, the
; @var could occur on only one side.
; Since this signature would check the binders in the side condition,
; the binders are invisible here.
; This affects the rules `bind`, `sko_ex`, `sko_forall`, `let`,
; and `onepoint`.

; program: $check_bind
; args:
; - old_context Bool: >
;    Context enclosing the premise passed to the application of the rule "bind".
; - new_context Bool: >
;    Context enclosing the conclusion passed to the application of the rule "bind".
; - premise Bool: >
;    Premise passed to the application of the rule "bind". Must be of the form
;    (@cl (= lhs_body rhs_body)).
; - conclusion Bool: >
;    Conclusion passed to the application of the rule "bind". Must be of the form
;    (@cl (= (Q lhs_vars lhs_body) (Q rhs_vars rhs_body))), for some quantifier Q,
;    and bounded variables lhs_vars and rhs_vars.
; return: >
;    A boolean resulting from the conjunction of the following conditions:
;    - Every variable in rhs_vars appear fixed in "new_context".
;    - Vars in lhs_vars are substituted by rhs_vars
;    - rhs_vars should not appear free in (Q lhs_vars lhs_body)
;    - rhs_vars should not appear in the first part of the new_context (old_context)
;    - lhs_vars should not appear in the first part of the new_context (old_context)
;    - new_context must be just an extension of old_context
(program $check_bind ((old_context Bool) (new_context Bool)
                      (T Type) (l T) (r T) (l1 T) (r1 T)
                      (premise Bool) 
                      (lhs_vars @VarList) (lhs_body Bool) 
                      (rhs_vars @VarList) (rhs_body Bool))
  (Bool Bool Bool Bool) Bool
  (
   (
    ($check_bind old_context new_context
                 (@cl (= lhs_body rhs_body))
                 (@cl (= (forall lhs_vars lhs_body) 
                         (forall rhs_vars rhs_body))))

    (eo::and
     ; Every variable in rhs_vars appear fixed in "new_context".
     ($context_vars_are_fixed new_context rhs_vars)

     ; Vars in lhs_vars are substituted by rhs_vars.
     ; Note: we need to embed each var in rhs_vars within a @var construction,
     ; since that is how they will appear within a context.
     ($f_list_equal @varlist 
                    ($embed_within_vars rhs_vars)
                    ($context_get_vars_substs new_context lhs_vars))

     ; rhs_vars should not appear free in (forall lhs_vars lhs_body)
     (eo::define ((lhs_free_vars ($fv (forall lhs_vars lhs_body))))
                 ($f_list_equal @varlist
                                lhs_free_vars
                                ($f_list_filter @varlist
                                                @varlist.nil
                                                lhs_free_vars
                                                ($varlist_flag_members 
                                                 lhs_free_vars
                                                 rhs_vars))))

     ; rhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context rhs_vars))

     ; lhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context lhs_vars))

     ; new_context must be just an extension of old_context
     ($context_is_extended new_context old_context)
     )
    )

   (
    ($check_bind old_context new_context
                 (@cl (= lhs_body rhs_body))
                 (@cl (= (exists lhs_vars lhs_body) (exists rhs_vars rhs_body))))

    (eo::and

     ; Every variable in rhs_vars appear fixed in "context".
     ($context_vars_are_fixed new_context rhs_vars)

     ; Vars in lhs_vars are substituted by rhs_vars
     ; Note: we need to embed each var in rhs_vars within a @var construction,
     ; since that is how they will appear within a context.
     ($f_list_equal @varlist 
                    ($embed_within_vars rhs_vars)
                    ($context_get_vars_substs new_context lhs_vars))

     ; rhs_vars should not appear free in (forall lhs_vars lhs_body)
     (eo::define ((lhs_free_vars ($fv (forall lhs_vars lhs_body))))
                 ($f_list_equal @varlist
                                lhs_free_vars
                                ($f_list_filter @varlist
                                                @varlist.nil
                                                lhs_free_vars
                                                ($varlist_flag_members lhs_free_vars
                                                                       rhs_vars))))
    
     ; rhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context rhs_vars))

     ; lhs_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context lhs_vars))

     ; new_context must be just an extension of old_context
     ($context_is_extended new_context old_context)
     )
    )
   )
  )

; rule: bind
; premises:
; - premise Bool: >
;    Premise passed to the application of the rule "bind". Must be of the form
;    (@cl (= lhs_body rhs_body)).
; assumption:
; - new_context Bool: >
;    Context enclosing the conclusion passed to the application of the rule "bind".
; args:
; - old_context Bool: >
;    Context enclosing the premise passed to the application of the rule "bind".
; requires: >
;    For old_context, new_context, premise and  conclusion to be well-formed with
;    respect to the definitions enforced by $check_bind.
; conclusion: A proper renaming of bound variables, according to $check_bind.
(declare-rule bind ((old_context Bool) (new_context Bool) (premise Bool) (conclusion Bool) 
                    (phi_lhs Bool) (phi_rhs Bool) (lhs_vars @VarList) (rhs_vars @VarList)
                    (quantifier (-> @VarList Bool Bool)))
  :assumption new_context
  :premises ((@cl (= phi_lhs phi_rhs)))
  :args (old_context)
  :requires ((($check_bind old_context new_context 
                           (@cl (= phi_lhs phi_rhs)) 
                           (@cl (= (quantifier lhs_vars phi_lhs) (quantifier rhs_vars phi_rhs)))) true))
  :conclusion-explicit (@cl (= (quantifier lhs_vars phi_lhs) (quantifier rhs_vars phi_rhs)))
)

;-------------
; Rule 19: sko_ex
;-------------

; program: $check_sko_build_skolem_vars
; args:
; - choice_body Bool: Body of the choice operator to be built.
; - exist_vars @VarList: @VarList containing the existentially quantified variables.
; return: >
;    A @VarList containing pairs (also as @VarList) of the form (𝑥𝑖, 𝜀𝑥𝑖.(∃𝑥𝑖+1, … , 𝑥𝑛.𝜑).)
(program $check_sko_ex_build_skolem_vars ((choice_body Bool) (A Type) (x A) 
                                       (tail @VarList :list))
         (Bool @VarList) @VarList
         (
          (
           ($check_sko_ex_build_skolem_vars choice_body (@varlist x))

           ($f_list_cons @varlist 
                         ($f_list_cons @varlist 
                                       x
                                       (@varlist (choice (@varlist x) x choice_body)
                                                 @varlist.nil))
                         @varlist.nil)
           )

          (; { tail <> @varlist.nil }
           ($check_sko_ex_build_skolem_vars choice_body (@varlist x tail))

           ($f_list_cons @varlist 
                         ($f_list_cons @varlist 
                                       x
                                       (@varlist (choice (@varlist x) x (exists tail choice_body)) 
                                                 @varlist.nil))
                         ($check_sko_ex_build_skolem_vars choice_body tail))
           )

          (; { tail <> @varlist.nil }
           ($check_sko_ex_build_skolem_vars choice_body @varlist.nil)

           @varlist.nil
           )
          )
)

; program: $check_sko_ex_new_context
; args:
; - ex_body Bool: Body of the existential quantification.
; - new_context Bool: Context of sko_ex premise.
; - ex_vars @VarList: List of existentially quantified variables.
; return: >
;    Checks that "new_context" contains the expected mapping between each variable in
;    "ex_vars" and its corresponding skolem term.
(program $check_sko_ex_new_context ((ex_body Bool) (new_context Bool) (ex_vars @VarList))
         (Bool Bool @VarList) Bool
         (
          (
           ($check_sko_ex_new_context ex_body new_context ex_vars)

           ($f_list_equal @varlist 
                          ($check_sko_ex_build_skolem_vars ex_body ex_vars)
                          ($context_get_var_subst_pairs new_context ex_vars))
           )
          )
)

; program: $check_sko_ex
; args:
; - old_context Bool: Context used outside of the current subproof.
; - new_context Bool: Context within the subproof.
; - premise Bool: Premise passed to sko_ex rule.
; - conclusion Bool: Conclusion passed to sko_ex rule.
; return:
;    A boolean indicating if conclusion has the form
;    𝑄𝑥1, … , 𝑥𝑛.𝜑 ≈ 𝑄𝑦1, … , 𝑦𝑛.𝜑′, for a premise 𝜑 ≈ 𝜑′. It also indicates
;    if the context within the subproof has the form 
;    Γ, 𝑦1, … , 𝑦𝑛, 𝑥1 ↦ 𝑦1, … , 𝑥𝑛 ↦ 𝑦𝑛, where Γ should be the context
;    outside of the subproof being closed by sko_ex.
(program $check_sko_ex ((old_context Bool) (new_context Bool) (lhs Bool) (rhs Bool) 
                                                 (conclusion Bool) (ex_vars @VarList))
  (Bool Bool Bool Bool) Bool
  (
   (
    ($check_sko_ex old_context new_context 
                   (@cl (= lhs rhs)) (@cl (= (exists ex_vars lhs) rhs)))

    (eo::and
     ; new_context should be just an extension of old_context.
     ($context_is_extended new_context old_context)

     ; new_context should contain the expected mapping between each variable in
     ; "ex_vars" and its corresponding skolem term.
     ($check_sko_ex_new_context lhs new_context ex_vars)

     ; ex_vars should not appear in the first part of the new_context (old_context)
     (eo::not ($context_vars_are_defined old_context ex_vars))
     )
    )
  )
)

; rule: sko_ex
; assumption:
; - new_context Bool: The subproof context, built with @ctx.
; premises:
; - premise Bool: Premise passed to rule sko_ex.
; args:
; - old_context Bool: >
;    Context from the outside of current subproof, built with @ctx.
; requires: >
;    Conclusion should have the form exists 𝑥1, … , 𝑥𝑛.𝜑 ≈ 𝜓, with enclosing
;     Γ, for a premise 𝜑 ≈ 𝜓 with enclosing context of the form.
;     Γ, 𝑥1 ↦𝜀1, … , 𝑥𝑛↦𝜀𝑛 .
; conclusion: Conclusion of the form exists 𝑥1, … , 𝑥𝑛.𝜑 ≈ 𝜓.
(declare-rule sko_ex ((old_context Bool) (new_context Bool) (premise Bool) 
                      (phi Bool) (psi Bool) (existential_vars @VarList))
  :assumption new_context
  :premises ((@cl (= phi psi)))
  :args (old_context)
  :requires ((($check_sko_ex old_context new_context (@cl (= phi psi))
                             (@cl (= (exists existential_vars phi) psi))) true))
  :conclusion-explicit (@cl (= (exists existential_vars phi) psi))
)

;TODO
(program $check_sko_forall ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  (Bool T T T T) Bool
  (
   (($check_sko_forall ctx l r l1 r1) true)
  )
)

;TRUST
(declare-rule sko_forall ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
  :assumption ctx
  :premises (old_ctx (@cl (= l1 r1)))
  :args ((@cl (= l r)))
  :requires ((($context_is_extended ctx old_ctx) true) (($check_sko_forall ctx l r l1 r1) true))
  :conclusion (@cl (= l r))
)

;--------------------
; Rule 21: forall_inst
;--------------------

; program: $check_forall_inst
; args:
; - conclusion Bool: Conclusion given to rule forall_inst.
; - variables_substitutions @VarList: A list of the substitutes of each quantified variable.
; return: >
;    A boolean indicating if conclusion is of the form ¬(∀𝑥1, … , 𝑥𝑛.𝑃) ∨𝑃[𝑥1 ↦𝑡1, … , 𝑥𝑛↦𝑡𝑛],
;    for terms t1,...,tn taken from variables_substitutions.
(program $check_forall_inst ((forall_vars @VarList) 
                                                       (body Bool)
                                                       (instantiated_body Bool) 
                                                       (variables_substitutions @VarList))
  (Bool @VarList) Bool
  (
   (;  TODO: 𝑥𝑖 and 𝑡𝑖 have the same sort
    ($check_forall_inst (@cl (or (not (forall forall_vars body)) instantiated_body))
                        variables_substitutions)
    ($eo_is_eq instantiated_body ($substitution_apply body 
                                                            ($substitution_build 
                                                             forall_vars
                                                             variables_substitutions)))
    )
   )
)

; rule: forall_inst
; args:
; - variables_substitutions @VarList: A list of the substitutes of each quantified variable.
;    Conclusion should be of the form ¬(∀𝑥1, … , 𝑥𝑛.𝑃) ∨𝑃[𝑥1 ↦𝑡1, … , 𝑥𝑛↦𝑡𝑛],
;    for terms t1,...,tn being used in the instantiation.
; requires:
; conclusion: A conclusion of the form of the ¬(∀𝑥1, … , 𝑥𝑛.𝑃) ∨𝑃[𝑥1 ↦𝑡1, … , 𝑥𝑛↦𝑡𝑛].
(declare-rule forall_inst ((variables_substitutions @VarList) (variables_quantified @VarList)
                           (forall_body Bool) (forall_body_instantiated Bool))

  :args (variables_substitutions)
  :requires ((($check_forall_inst 
               (@cl (or (not (forall variables_quantified forall_body))
                        forall_body_instantiated))
               variables_substitutions) true))
  :conclusion-explicit (@cl (or (not (forall variables_quantified forall_body))
                                forall_body_instantiated))
)

;--------------------
; Rule 22: refl
;--------------------

; program: $check_refl
; args:
; - context Bool: Context corresponding to the refl step.
; - conclusion Bool: >
;    Conclusion of the form (@cl (= lhs rhs)), provided to the application of the
;    refl rule.
; return: >
;    A boolean indicating if, by applying the substitution (induced by the 
;    context) to the left-hand side of the conclusion, we obtain a term that is
;    equivalent (modulo alpha-conversion) to the right-hand side.
(program $check_refl ((context Bool) (conclusion Bool) (A Type) (lhs A) (rhs A))
  (Bool Bool) Bool
  (
   (
    ($check_refl context (@cl (= lhs rhs)))

    ($eo_is_eq 

     ($substitution_apply lhs 
                          ($substitution_build_from_context context))

     rhs)
    )
  )
)

; rule: refl
; premises:
; - context Bool: The context that corresponds to the step applying rule refl.
; requires: >
;    That, by applying the substitution (induced by the context) to the left-hand 
;    side of the conclusion, we obtain a term that is equivalent (modulo 
;    alpha-conversion) to the right-hand side.
; conclusion:
(declare-rule refl ((context Bool) (t1 Bool) (t2 Bool))
  :premises (context)
  :requires ((($check_refl context (@cl (= t1 t2))) true))
  :conclusion-explicit (@cl (= t1 t2))
)

;-------------
; Rule 23: trans
;-------------

; program: $last_eq_right
; args:
; - eqs Bool: Premises given to rule trans (equivalences), chained with "and".
; - lhs T: >
;   Expression of arbitrary type T, for which we want to determine its
;   transitively related element, traversing eqs
; return: >
;   The last element of type T related with lhs, through transitivity, 
;   following the equivalences in eqs.
(program $last_eq_right ((T Type) (t1 T) (t2 T) (eqs Bool))
  (Bool T) Bool
  (
   (; case (@cl (= t1 t2) false)
    ($last_eq_right (@cl (= t1 t2)) t1)
    
    t2
    )

   (; case (@cl (= t1 t2) false)
    ($last_eq_right (@cl (= t1 t2)) t2)
    
    t1
    )

   (; case (and (@cl (= t1 t2) false) true)
    ($last_eq_right (and (@cl (= t1 t2))) t1) 

    t2
    )

   (; case (and (@cl (= t1 t2) false) true)
    ($last_eq_right (and (@cl (= t1 t2))) t2) 

    t1
    )

    (; { eqs <> true}
     ; case (and (@cl (= t1 t2) false) eqs)
     ($last_eq_right (and (@cl (= t1 t2)) eqs) t1) 

     ($last_eq_right eqs t2)
     )

    (; { eqs <> true}
     ; case (and (@cl (= t1 t2) false) eqs)
     ($last_eq_right (and (@cl (= t1 t2)) eqs) t2)

     ($last_eq_right eqs t1)
     )

   ; TODO: are they always clauses? (seems that it is not the
   ; case if the premises where just "assume"s)
    (; case (and (= t1 t2) true) 
     ($last_eq_right (and (= t1 t2)) t1)

     t2
     )

    (; case (and (= t1 t2) true)
     ($last_eq_right (and (= t1 t2)) t2)

     t1
     )

    (; { eqs <> true}
     ; case (and (= t1 t2) eqs)
     ($last_eq_right (and (= t1 t2) eqs) t1)
     
     ($last_eq_right eqs t2)
     )

    (; { eqs <> true}
     ; case (and (= t1 t2) eqs)
     ($last_eq_right (and (= t1 t2) eqs) t2)
     
     ($last_eq_right eqs t1)
     )
  )
)

; program: $make_trans
; args:
; - eqs Bool: Premises given to rule trans (equivalences), chained with "and".
; - lhs T: >
;   Expression of arbitrary type T, for which we want to determine its
;   transitively related element, traversing eqs.
; return: >
;   An equivalence of the form (= lhs rhs), where rhs is the last element of 
;   type T related with lhs, through transitivity, following the equivalences 
;   in eqs.
(program $make_trans ((T Type) (t1 T) (t2 T) (eqs Bool :list))
  (Bool T) Bool
  (
   (; case (and (= t1 t2) true)
    ($make_trans (and (@cl (= t1 t2))) t1)
    
    (= t1 t2)
    )

   (; case (and (= t1 t2) true)
    ($make_trans (and (@cl (= t1 t2))) t2)
    
    (= t1 t2)
    )

   (; { eqs <> true }
    ($make_trans (and (@cl (= t1 t2)) eqs) t1) 
    
    (= t1 ($last_eq_right eqs t2))
    )

   (; { eqs <> true }
    ($make_trans (and (@cl (= t1 t2)) eqs) t2) 
    
    (= t2 ($last_eq_right eqs t1))
    )
  )
)

; program: $check_trans
; args:
; - premises Bool: Equivalence premises given to rule trans, chained through "and".
; - conclusion Bool: Conclusion given to rule trans. Must be built with @cl.
; return: >
;   A boolean indicating if "conclusion" is the equivalence resulting from
;   the transitivity of equivalence, identifying the lhs of the first 
;   premise equivalence with the rhs of the last premise equivalence.
(program $check_trans ((A Type) (lhs A) (lhs_1 A) (lhs_2 A)
                       (rhs A) (rhs_1 A) (rhs_2 A)
                       (eqs Bool :list))
  (Bool Bool) Bool
  (
   ; We perform the first step of $make_trans here, to be able to select
   ; which side of the equation to follow.
   (
    ($check_trans (and (@cl (= lhs rhs))) (@cl (= lhs rhs)))
    
    true
    )

   (
    ($check_trans (and (@cl (= lhs rhs))) (@cl (= rhs lhs)))
    
    true
    )

   (
    ($check_trans (and (@cl (= lhs rhs_2)) eqs) (@cl (= lhs rhs_1)))

    ($f_list_equal = ($make_trans (and (@cl (= lhs rhs_2)) eqs) lhs) (= lhs rhs_1))
    )

   (
    ($check_trans (and (@cl (= lhs_1 rhs)) eqs) (@cl (= lhs_2 rhs)))

    ($f_list_equal = ($make_trans (and (@cl (= lhs_1 rhs)) eqs) rhs) (= lhs_2 rhs))
    )
  )
)

;TODO what about scopes here? can a premise come from an outers scope
; rule: trans
; premises:
; - premise-list Bool: Premises given to rule "trans", chained with "and"
; requires: >
;   For "conclusion" to be the equivalence resulting from
;   the transitivity of equivalence, identifying the lhs of the first 
;   premise equivalence with the rhs of the last premise equivalence.
; conclusion-explicit: >
;   Conclusion should be of the form (@cl (= t1 tn)), satisfying the described
;   side-condition.
(declare-rule trans ((premises Bool) (premises Bool) (t1 Bool) (tn Bool))
  :premise-list premises and
  :requires ((($check_trans premises (@cl (= t1 tn))) true))
  :conclusion-explicit (@cl (= t1 tn))
)

;---------------
; Rule 24: cong
;---------------

; program: $check_n_ary_application
; args:
; - lhs U: LHS of the equality in the conclusion passed to the cong rule.
; - rhs U: RHS of the equality in the conclusion passed to the cong rule.
; - premises Bool: Premises passed to the cong rule, but in the reverse order.
; return: >
;    A boolean indicating if lhs, rhs and premises correspond to the proper
;    application of the cong rule, for a n-ary operator. Note that, in this case,
;    we are dealing with the single application of a n-ary operator. No 
;    associativity is involved.
(program $check_n_ary_application ((T Type) (U Type) 
                                          (f (-> T U U)) (f2 (-> T U U)) (t1 T) (t2 T) (t3 T)
                                          (lhs U) (rhs U) (tail Bool :list) (premises Bool))
    :signature (U U Bool) Bool
    (
     (
      ($check_n_ary_application (f t1) (f t2) (and (@cl (= t1 t2))))

      true
      )

     ( ; TODO: ill-typed?
      ($check_n_ary_application (f t1) (f2 t2) (and (@cl (= t1 t2)) tail))

      ($check_n_ary_application f f2 tail)
      )
     
     ( ; Rule cong allows for the premises to not include the cases of reflexive 
       ; equalities. We treat that here.
      ($check_n_ary_application (f t1) (f2 t1) (and (@cl (= t2 t3)) tail))

      ($check_n_ary_application f f2 (and (@cl (= t2 t3)) tail))
      )
     )
    )

; program: $check_variadic_left_assoc
; args:
; - lhs U: LHS of the equality in the conclusion passed to the cong rule.
; - rhs U: RHS of the equality in the conclusion passed to the cong rule.
; - premises Bool: Premises passed to the cong rule, but in the reverse order.
; return: >
;    A boolean indicating if lhs, rhs and premises correspond to the proper
;    application of the cong rule, for a left-assoc operator.
(program $check_variadic_left_assoc ((T Type) (U Type) 
                                          (f (-> T U U)) (f2 (-> T U U)) (t1 T) (t2 T) (t3 T)
                                          (lhs U) (rhs U) (tail Bool :list) (premises Bool))
    :signature (U U Bool) Bool
    (
     (; This case covers the situation where f is actually
      ; the original variadic operator being applied to its nil
      ; value, as it would be the case for a left-assoc-nil op.
      ($check_variadic_left_assoc (f t1) (f t2) (and (@cl (= t1 t2))))

      true
      )

     ( ; TODO: ill-typed?
      ($check_variadic_left_assoc (f t1) (f2 t2) (and (@cl (= t1 t2)) tail))

      ($check_variadic_left_assoc f f2 tail)
      )

     (; Rule cong allows for the premises to not include the cases of reflexive 
      ; equalities. We treat that here.
      ($check_variadic_left_assoc (f t1) (f2 t1) (and (@cl (= t2 t3)) tail))

      ($check_variadic_left_assoc f f2 (and (@cl (= t2 t3)) tail))
      )
     )
    )

; program: $check_variadic_right_assoc
; args:
; - lhs U: LHS of the equality, in the conclusion.
; - rhs U: RHS of the equality, in the conclusion.
; - rev_premises Bool: Premises given to the cong rule.
; return:
(program $check_variadic_right_assoc ((T Type) (U Type) (f (-> T U U)) 
                                           (f2 (-> T U U)) (t1 T) (t2 T) (t3 T) (nil U :list) (lhs U :list) (rhs U :list)
                                           (premises Bool) (tail Bool :list))
    :signature (U U Bool) Bool
    (
     (; Ending of both f-lists
      ($check_variadic_right_assoc (f t1 nil) (f t2 nil) (and (@cl (= t1 t2))))

      true
      )

     ( ; TODO: ill-typed
      ($check_variadic_right_assoc (f t1 lhs) (f t2 rhs) (and (@cl (= t1 t2)) tail))

      ($check_variadic_right_assoc lhs rhs tail)
      )

     (; Rule cong allows for the premises to not include the cases of reflexive 
      ; equalities. We treat that here.
      ($check_variadic_right_assoc (f t1 lhs) (f t1 rhs) (and (@cl (= t2 t3)) tail))

      ($check_variadic_right_assoc lhs rhs (and (@cl (= t2 t3)) tail))
      )
     )
    )

; program: $cong_extract_operator
; args:
; - lhs (-> T U) : >
;    The left-hand side of the conclusion given to the cong rule, where the last argument
;    of the function application has been removed. This is so for typing purposes.
; - rhs (-> T U) : >
;    The right-hand side of the conclusion given to the cong rule, where the last argument
;    of the function application has been removed. This is so for typing purposes.
; return: >
;    If both sides contain the same function being applied, 
;    $cong_extract_operator returns it.
(program $cong_extract_operator ((T Type) (U Type)
                                 (lhs_f (-> T U)) (rhs_f (-> T U)) (lhs U) (rhs U))
    :signature ((-> T U) (-> T U)) (-> T U)
    (
     (; I can type lhs_f and rhs_f as being unary, because of currying.
      ; This matches, regardless of the associativity of the operators involved.
      ($cong_extract_operator (lhs_f lhs) (rhs_f rhs))
      ; Since the expected type of the parameters is (-> T U), it contemplates the case
      ; where lhs_f and rhs_f are not actual unary functions.
      ($cong_extract_operator lhs_f rhs_f)
      )

     (; We cannot decompose the parameters received as an application of some
      ; unary function: we must have reached to the function itself, and lhs and rhs
      ; should contain the same function.
      ($cong_extract_operator lhs_f lhs_f)

      lhs_f
      )
     )
    )

; program: $check_cong
; args:
; - premises Bool: >
;   Premises given to rule cong. Must be an and-list of each premise (equality).
; - conclusion Bool: Conclusion clause given to rule cong.
; return: >
;   A boolean indicating if "conclusion" follows from the and-list of premises
;   given.
(program $check_cong ((T Type) (U Type) (f_lhs (-> T U)) (lhs U) (f_rhs (-> T U)) (rhs U) 
                      (premises Bool))
  (Bool Bool) Bool
  (
   (
    ($check_cong premises (@cl (= (f_lhs lhs) (f_rhs rhs))))

    (eo::define ((operator ($cong_extract_operator f_lhs f_rhs)))
                (eo::ite ($is_theory_f_list operator)
                         ; Operator is variadic. It must be left or right assoc.
                         (eo::ite ($is_theory_op_left_assoc operator)
                                  ($check_variadic_left_assoc (f_lhs lhs) (f_rhs rhs)
                                                              (eo::list_rev and premises))

                                  ; { not ($is_theory_op_left_assoc operator) }
                                  ($check_variadic_right_assoc (f_lhs lhs) (f_rhs rhs)
                                                               premises)
                                  )
                         
                         ; { not ($is_theory_f_list operator) }
                         ; For the single application of a n-ary operator, there is no associativity
                         ; involved. We do not need to distinguish among left/righ assoc. or no assoc.
                         ; at all.
                         ; Note that every user defined function constant ends up being n-ary.
                         ($check_n_ary_application (f_lhs lhs) (f_rhs rhs) (eo::list_rev and premises)))
                )
    )
   )
)

; rule: cong
; premises:
; - premises Bool: An and-list of premises of the form t1 = u1, ..., tm = um.
; requires: >
;   For "conclusion" to be of the form:
;   f s1 ... sn t1 ... tm = f s1 ... sn u1 ... um
;   with premises: 
;   t1 = u1, ..., tm = um.
; conclusion-explicit: >
;   A conclusion of the form f s1 ... sn t1 ... tm = f s1 ... sn u1 ... um, 
;   satisfying the previous side-condition.
(declare-rule cong ((premises Bool) (conclusion Bool))
  :premise-list premises and
  :requires ((($check_cong premises conclusion) true))
  :conclusion-explicit conclusion
)

;----------------------
; Rule 25: eq_reflexive
;----------------------
; rule: eq_reflexive
; conclusion: >
; Conclusion should be of the form (@cl (= t t)), for some arbitrary
; term t.
(declare-rule eq_reflexive ((T Type) (t T))
  :conclusion-explicit (@cl (= t t))
)

;TODO
(program $check_eq_transitive ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_transitive conclusion) true)
  )
)

;TRUST
(declare-rule eq_transitive ((conclusion Bool))
  :requires ((($check_eq_transitive conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_eq_congruent ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_congruent conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent ((conclusion Bool))
  :requires ((($check_eq_congruent conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_eq_congruent_pred ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_congruent_pred conclusion) true)
  )
)

;TRUST
(declare-rule eq_congruent_pred ((conclusion Bool))
  :requires ((($check_eq_congruent_pred conclusion) true))
  :conclusion-explicit conclusion
)

;TODO: to preserve previous def
; 
; (program $check_qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;   (@VarList Bool @VarList Bool) Bool
;   (
;    (($check_qnt_cnf xs phi xsP phiP) true)
;   )
; )

; ;TRUST
; (declare-rule qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
;   :args ((@cl (or (not (forall xs phi)) (forall xsP phiP))))
;   :requires ((($check_qnt_cnf xs phi xsP phiP) true))
;   :conclusion (@cl (or (not (forall xs phi)) (forall xsP phiP)))
; )

;TODO
(program $check_qnt_cnf ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_cnf conclusion) true)
  )
)

;TRUST
(declare-rule qnt_cnf ((conclusion Bool))
  :requires ((($check_qnt_cnf conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Table 7: Clausification rules
;-------------

;-------------
; Rule 30: and
;-------------

; program: check_and
; args:
; - premise Bool       : >
;   Premise of the "and" rule: a conjunction of terms, embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from 
;   "premise", with index "index".
(program $check_and ((premise Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  (
   (
    ($check_and premise index conclusion)

    ($cl_equal ($to_cl ($f_list_index and ($from_cl premise) index))
               conclusion)
    )
  )
)

; TODO: this overloads PandP
; rule: and
; premises:
; - premise: The conjunctions over which "and elimination" is applied.
; args:
; - index Int: >
;   The index of the conjunct being selected. 0 <= index <= number of conjuncts - 1.
; requires: >
;   The conclusion should be one conjunct from the premise,
;   in the position indicated by index.
; conclusion: A conjunct from "premise", satisfying the previous side-condition.
(declare-rule and ((premise Bool) (index Int) (conclusion Bool))
  :premises (premise)
  :args (index)
  :requires ((($check_and premise index conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 31: not_or
;-------------

; program: check_not_or
; args:
; - premise Bool       : >
;   Premise of the "not_or" rule: a negation of a disjunction of terms.
;   It could be embedded within a single-term clause 
;   (built with @cl).
; - index Int          : >
;   Conjunct index, as provided to the rule. 0 <= index <= number of conjuncts - 1
; - conclusion Bool    : >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is a conjunct from "premise" (after
;   applying DeMorgan's law), in position "index".
(program $check_not_or ((disjuncts Bool) (premise_non_cl Bool) (index Int) (conclusion Bool))
  (Bool Int Bool) Bool
  (; To facilitate the use of the program, we allow 
   ; the presence of a @cl constructor
   (($check_not_or (@cl premise_non_cl) index conclusion)
    ($check_not_or premise_non_cl index conclusion))

   (($check_not_or (not disjuncts) index conclusion)
    ($cl_equal ($to_cl (not ($f_list_index or disjuncts index)))
               conclusion))
   )
)

; rule: not_or
; premises:
; - premise: The negated disjunction over which "not_or" is applied.
; args:
; - index Int: The index of the conjunct being selected.
;              0 <= index <= number of conjuncts - 1
; requires: >
;   The conclusion should be one disjunct from the result
;   of applying DeMorgan's rule over the premise. The disjunct
;   position must correspond to what is specified by the index
;   parameter
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule not_or ((premise Bool) (index Int) (conclusion Bool))
  :premises (premise)
  :args (index)
  :requires ((($check_not_or premise index conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 32: or
;-------------

; program: check_or
; args:
; - premise Bool: >
;   Premise of the "or" rule: a disjunction of terms, built with "or" operator. 
;   It could be embedded within a single-term clause built with @cl.
; - conclusion Bool: >
;   Conclusion provided to the rule. 
; return: >
;   A boolean indicating if "conclusion" is equivalent to "premise", but built 
;   with @cl.
(program $check_or ((premise Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (
    ($check_or (@cl premise) conclusion)

    ($cl_equal ($convert_or_to_cl premise)
               conclusion)
    )
  )
)

; rule: or
; premises:
; - premise: >
;   The clause, built with the "or" operator, over which the rule is applied. 
;   It could be embedded within a single-term clause built with @cl.
; requires: >
;   The conclusion should be a clause equivalent to "premise", 
;   but built with @cl.
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule or ((premise Bool) (conclusion Bool))
  :premises (premise)
  :requires ((($check_or premise conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 37: not_and
;-------------

; program: check_not_and
; args:
; - premise Bool: Premise of the not_and rule: a negated conjunction of propositions.
; - conclusion Bool: >
;   The conclusion provided to the not_and rule.
; return: >
;   A boolean indicating if "conclusion" is a clause built with
;   @cl, where each disjunct is negated and corresponds to some conjunct from
;   "premise".
(program $check_not_and ((conjunction Bool) (conclusion Bool))
  (Bool Bool) Bool
  (
   (
    ($check_not_and (@cl (not conjunction)) conclusion)

     ($cl_equal ($de_morgan_not_and conjunction) conclusion)
     )
  )
)

; rule: not_and
; premises:
; - premise Bool: >
;  The premise clause: a negated conjunction of propositions.
; requires: >
;  For "conclusion" to be a clause built with @cl, that results from applying
;  DeMorgan's rule over "premise".
; conclusion-explicit: >
;  A conclusion satisfying the previous side-condition.
(declare-rule not_and ((premise Bool) (conclusion Bool))
  :premises (premise)
  :requires ((($check_not_and premise conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 37: xor1
;-------------

; rule: xor1
; premises:
; - premise Bool: A premise of the form (@cl (xor phi1 phi2)).
; conclusion: A conclusion of the form (@cl phi1 phi2).
(declare-rule xor1 ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (xor phi1 phi2)))
  :conclusion-explicit (@cl phi1 phi2)
)

;-------------
; Rule 38: xor2
;-------------

; rule: xor2
; premises:
; - premise Bool: A premise of the form (@cl (xor phi1 phi2)).
; conclusion: A conclusion of the form (@cl (not phi1) (not phi2)).
(declare-rule xor2  ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (xor phi1 phi2)))
  :conclusion-explicit (@cl (not phi1) (not phi2))
)

;-------------
; Rule 39: not_xor1
;-------------

; rule: not_xor1
; premises:
; - premise Bool: A premise of the form (@cl (not (xor phi1 phi2))).
; conclusion: A conclusion of the form (@cl phi1 (not phi2)).
(declare-rule not_xor1  ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (xor phi1 phi2))))
  :conclusion-explicit (@cl phi1 (not phi2))
)


;-------------
; Rule 40: not_xor2
;-------------

; rule: not_xor2
; premises:
; - premise Bool: A premise of the form (@cl (not (xor phi1 phi2))).
; conclusion: A conclusion of the form (@cl (not phi1) phi2).
(declare-rule not_xor2   ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (xor phi1 phi2))))
  :conclusion-explicit (@cl (not phi1) phi2)
)

;-------------
; Rule 41: implies
;-------------
; rule: implies
; premises:
; - premise Bool: >
;   Premise of the implies rule. Should be an implication,
;   built with the => constructor.
; conclusion-explicit: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication given as premise of the rule.
(declare-rule implies ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (=> phi1 phi2)))
  :conclusion-explicit (@cl (not phi1) phi2)
)

;----------------------
; Rule 42: not_implies1
;----------------------

; rule: not_implies1
; premises:
; - premise Bool: A premise of the form ((@cl (not (=> phi1 phi2)))).
; conclusion: >
;    Conclusion must be just the antecedent phi1 of the implication
;    in the premise.
(declare-rule not_implies1 ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (=> phi1 phi2))))
  :conclusion-explicit (@cl phi1)
)

;----------------------
; Rule 43: not_implies2
;----------------------
; rule: not_implies2
; premises:
; - premise Bool: A premise of the form ((@cl (not (=> phi1 phi2)))).
; conclusion: >
;    Conclusion must be just the negated consequent phi2 of the 
;    implication in the premise.
(declare-rule not_implies2  ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (=> phi1 phi2))))
  :conclusion-explicit (@cl (not phi2))
)

;-------------
; Rule 44: equiv1
;-------------
; rule: equiv1
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
; conclusion-explicit: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi1 => phi2.
(declare-rule equiv1 ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (= phi1 phi2)))
  :conclusion-explicit (@cl (not phi1) phi2)
)

;-------------
; Rule 45: equiv2
;-------------

; rule: equiv2
; premises:
; - premise Bool: >
;   An equivalence between some propositions phi1 and phi2 (phi1 = phi2).
; conclusion-explicit: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of the implication phi2 => phi1.
(declare-rule equiv2  ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (= phi1 phi2)))
  :conclusion-explicit (@cl phi1 (not phi2))
)


;-------------
; Rule 46: not_equiv1
;-------------
; rule: not_equiv1
; premises:
; - premise Bool: >
;   A negated equivalence between some propositions phi1 and phi2, in clause form:
;   (@cl (not (phi1 = phi2))).
; conclusion-explicit: >
;   The conclusion should be of the form (@cl phi1 phi2).
(declare-rule not_equiv1 ((phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (= phi1 phi2))))
  :conclusion-explicit (@cl phi1 phi2)
)

;-------------
; Rule 48: and_pos
;-------------

; program: check_and_pos
; args:
; - pos Int: Position of the selected conjunct. 
;            0 <= pos <= number of conjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, where the antecedent is 
;   a conjunction.
(program $check_and_pos ((pos Int) (antecedent Bool) (consequent Bool))
  (Int Bool) Bool
  (
   (
    ($check_and_pos pos (@cl (not antecedent) consequent))

    ($cl_equal ($f_list_index and antecedent pos) consequent)
    )

   ; To simplify the use of the checker
   (
    ($check_and_pos pos (@cl consequent (not antecedent)))

    ($cl_equal ($f_list_index and antecedent pos) consequent)
    )
  )
)

;TRUST
; rule: and_pos
; args:
; - pos Int: Position of the conjunct selected in the weakening. 
;            0 <= pos <= number of conjuncts - 1
; requires: >
;   The conclusion should be the characterization (i.e., "not antecedent 
;   or consequent" form) of an instance of the weakening rule for implication,
;   where the antecedent is a conjunction.
; conclusion-explicit: >
;   A conclusion of the form described by the previous side-condition.
(declare-rule and_pos ((pos Int) (conclusion Bool))
  :args (pos)
  :requires ((($check_and_pos pos conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 49: and_neg
;-------------

; program: check_and_neg
; args:
; - conclusion Bool: >
;   This should be the conclusion to the application of and_neg. It must be
;   a clause built with @cl.
; return: >
;   A boolean indicating if "conclusion" is an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
(program $check_and_neg ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   (
    ($check_and_neg (@cl left_disjunct right_disjunct))

    ($cl_equal ($de_morgan_not_and left_disjunct) right_disjunct)
    )
  )
)

; rule: and_neg
; requires: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form phi_1 /\ ... /\ phi_n.
; conclusion-explicit: >
;   A conclusion of the form described by the previous side-condition.
(declare-rule and_neg ((conclusion Bool))
  :requires ((($check_and_neg conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 50: or_pos
;-------------

; program: check_or_pos
; args:
; - conclusion Bool: >
;   Conclusion given to rule or_pos. It is expected to be built with @cl.
; return: >
;   A boolean indicating if conclusion is of the form
;   ¬(𝜑1 ∨⋯∨𝜑𝑛), 𝜑1, … , 𝜑𝑛, for some given propositions 𝜑1, ..., 𝜑𝑛.
(program $check_or_pos ((left_disjunct Bool) (right_disjunct Bool :list))
  (Bool) Bool
  (
   (
    ($check_or_pos (@cl (not left_disjunct) right_disjunct))

    ($cl_equal ($convert_or_to_cl left_disjunct)
              (@cl right_disjunct))
    )
  )
)

; rule: or_pos
; requires: >
;   For the conclusion to be of the form
;   ¬(𝜑1 ∨⋯∨𝜑𝑛), 𝜑1, … , 𝜑𝑛, for some given propositions 𝜑1, ..., 𝜑𝑛.
; conclusion-explicit: >
;   A conclusion of the form described by the previous side-condition.
(declare-rule or_pos ((conclusion Bool))
  :requires ((($check_or_pos conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 51: or_neg
;-------------

; program: check_or_neg
; args:
; - pos Int: Position of the selected disjunct.
;            0 <= pos <= number of disjuncts - 1.
; - conclusion Bool: >
;   The conclusion clause provided to the rule. It must be always built with
;   @cl.
; return: >
;   A boolean indicating if "conclusion" satisfies the property of being
;   an instance of the weakening rule for implication, with the form 
;   not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
(program $check_or_neg ((index Int) (left_disjunct Bool) (right_disjunct Bool))
  (Int Bool) Bool
  (
   (
    ($check_or_neg index (@cl left_disjunct (not right_disjunct)))
    
    ($prop_syntax_eq ($f_list_index or left_disjunct index) right_disjunct)
    )
   
   (
    ($check_or_neg index (@cl (not left_disjunct) right_disjunct))
    
    ($prop_syntax_eq right_disjunct ($f_list_index or left_disjunct index))
    )
  )
)

; rule: or_neg
; args:
; - index Int: The index of the disjunct which is weakened in the conclusion.
; requires: >
;   Th conclusion must be an instance of the weakening rule for implication, 
;   with the form not phi_k, phi_0 \/ ... \/ phi_n, with 0 <= k <= n.
; conclusion-explicit: >
;   A conclusion of the form described by the previous side-condition.
(declare-rule or_neg ((index Int) (conclusion Bool))
  :args (index)
  :requires ((($check_or_neg index conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_xor_pos1 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_pos1 CL) true)
  )
)

;TRUST
(declare-rule xor_pos1 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_pos1 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_pos2 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_pos2 CL) true)
  )
)

;TRUST
(declare-rule xor_pos2 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_pos2 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_neg1 CL) true)
  )
)

;TRUST
(declare-rule xor_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_xor_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_xor_neg2 CL) true)
  )
)

;TRUST
(declare-rule xor_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_xor_neg2 CL) true))
  :conclusion CL
)

;-------------
; Rule 56: implies_pos
;-------------
; rule: implies_pos
; conclusion-explicit: >
;   The conclusion should be an instance of excluded middle,
;   for a proposition of the form (=> phi_1 phi_2).
(declare-rule implies_pos ((phi1 Bool) (phi2 Bool))
  :conclusion-explicit (@cl (not (=> phi1 phi2)) (not phi1) phi2)
)

;-------------
; Rule 57: implies_neg1
;-------------

; rule: implies_neg1
; conclusion-explicit: >
;   The conclusion should be of the form (@cl (=>phi1 phi2) phi1),
;   for given formulas phi1 and phi2.
(declare-rule implies_neg1  ((phi1 Bool) (phi2 Bool))
  :conclusion-explicit (@cl (=> phi1 phi2) phi1)
)

;-------------
; Rule 58: implies_neg2
;-------------
; rule: implies_neg2
; conclusion-explicit: >
;   The conclusion should be of the form (@cl (=>phi1 phi2) (not phi2)),
;   for given formulas phi1 and phi2.
(declare-rule implies_neg2 ((phi1 Bool) (phi2 Bool))
  :conclusion-explicit (@cl (=> phi1 phi2) (not phi2))
)

;-------------
; Rule 59: equiv_pos1
;-------------
; rule: equiv_pos1
; conclusion-explicit: >
;   Conclusion should be equal to the clause 
;   (@cl (not (= phi_1 phi2)) phi_1 (not phi_2)), for some props. phi_1 and phi_2.
(declare-rule equiv_pos1 ((phi1 Bool) (phi2 Bool))
  :conclusion-explicit (@cl (not (= phi1 phi2)) phi1 (not phi2))
)

;-------------
; Rule 60: equiv_pos2
;-------------
; rule: equiv_pos2
; conclusion-explicit: >
;   Conclusion should be equal to the clause 
;   (@cl (not (= phi_1 phi2)) (not phi_1) phi_2), for some props. phi_1 and phi_2.
(declare-rule equiv_pos2 ((phi1 Bool) (phi2 Bool)) 
  :conclusion-explicit (@cl (not (= phi1 phi2)) (not phi1) phi2)
)

;TODO
(program $check_equiv_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_equiv_neg1 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_equiv_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_equiv_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_equiv_neg2 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_equiv_neg2 CL) true))
  :conclusion CL
)

;-------------
; Rule 63: ite1
;-------------
; rule: ite1
; premises: >
;   A premise of the form (@cl (ite phi1 phi2 phi3)). Note that phi2 and phi3 must be
;   of boolean type.
; conclusion-explicit: >
;   Conclusion should be of the form (@cl phi_1 phi_3).
(declare-rule ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool))
  :premises ((@cl (ite phi1 phi2 phi3)))
  :conclusion-explicit (@cl phi1 phi3)
)

; rule: ite2
; premises: >
;   A premise of the form (@cl (ite phi1 phi2 phi3)). Note that phi2 and phi3 must be
;   of boolean type.
; conclusion-explicit: >
;   Conclusion should be of the form (@cl (not phi_1) phi_2).
(declare-rule ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool))
  :premises ((@cl (ite phi1 phi2 phi3)))
  :conclusion-explicit (@cl (not phi1) phi2)
)

;TODO
(program $check_ite_pos1 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_pos1 CL) true)
  )
)

;TRUST
(declare-rule ite_pos1 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_pos1 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_pos2 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_pos2 CL) true)
  )
)

;TRUST
(declare-rule ite_pos2 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_pos2 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_neg1 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_neg1 CL) true)
  )
)

;TRUST
(declare-rule ite_neg1 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_neg1 CL) true))
  :conclusion CL
)

;TODO
(program $check_ite_neg2 ((CL Bool))
  (Bool) Bool
  (
   (($check_ite_neg2 CL) true)
  )
)

;TRUST
(declare-rule ite_neg2 ((CL Bool))
  :args (CL)
  :requires ((($check_ite_neg2 CL) true))
  :conclusion CL
)

;-------------
; Rule 69: not_ite1
;-------------
; rule: not_ite1
; premises: >
;   A premise of the form (@cl (not (ite phi1 phi2 phi3))). Note that phi2 and phi3 must be
;   of boolean type.
; conclusion-explicit: >
;   Conclusion should be of the form (@cl phi_1 (not phi_3)).
(declare-rule not_ite1  ((phi1 Bool) (phi2 Bool) (phi3 Bool))
  :premises ((@cl (not (ite phi1 phi2 phi3))))
  :conclusion-explicit (@cl phi1 (not phi3))
)

;-------------
; Rule 70: not_ite2
;-------------
; rule: not_ite2
; premises: >
;   A premise of the form (@cl (not (ite phi1 phi2 phi3))). Note that phi2 and phi3 must be
;   of boolean type.
; conclusion-explicit: >
;   Conclusion should be of the form (@cl (not phi_1) (not phi_2)).
(declare-rule not_ite2  ((phi1 Bool) (phi2 Bool) (phi3 Bool))
  :premises ((@cl (not (ite phi1 phi2 phi3))))
  :conclusion-explicit (@cl (not phi1) (not phi2))

)

;TODO
(program $check_connective_def ((conclusion Bool))
  (Bool) Bool
  (
   (($check_connective_def conclusion) true)
  )
)

;TRUST
(declare-rule connective_def ((conclusion Bool))
  :requires ((($check_connective_def conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_and_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_and_simplify l r) true)
  )
)

;TRUST
(declare-rule and_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_and_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_or_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_or_simplify conclusion) true)
  )
)

;TRUST
(declare-rule or_simplify ((conclusion Bool))
  :requires ((($check_or_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_not_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_not_simplify conclusion) true)
  )
)

;TRUST
(declare-rule not_simplify ((conclusion Bool))
  :requires ((($check_not_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 75: implies_simplify
;-------------

; program: check_implies_simplify
; args:
; - conclusion Bool: Conclusion provided to rule implies_simplify.
; return: >
;   A boolean indicating if conclusion has the form 𝜑1 → 𝜑2 ≈ 𝜓, where 𝜓
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_implication".
(program $check_implies_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   (
    ($check_implies_simplify (@cl (= (=> phi_1 phi_2) psy)))

                                        ; TODO: use proper comparison for props
    ($cl_equal (@cl ($rewrite_implication (=> phi_1 phi_2)))
               (@cl psy))
    )
   )
)

; rule: implies_simplify
; requires: >
;   For the conclusion to be of the form 𝜑1 → 𝜑2 ≈ 𝜓, where 𝜓 
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_implication".
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule implies_simplify ((conclusion Bool))
  :requires ((($check_implies_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 76: equiv_simplify
;-------------
; program: check_equiv_simplify
; args:
; - conclusion Bool: Conclusion provided to rule equiv_simplify.
; return: >
;   A boolean indicating if conclusion has the form (𝜑1 ≈ 𝜑2) ≈ 𝜓, where 𝜓 
;   results from the application of equivalence preserving transformations, 
;   as specified in "rewrite_equivalence".
(program $check_equiv_simplify ((phi_1 Bool) (phi_2 Bool) (psy Bool))
  (Bool) Bool
  (
   (
    ($check_equiv_simplify (@cl (= (= phi_1 phi_2) psy)))
    
                                        ; TODO: use proper comparison for props
    ($cl_equal (@cl ($rewrite_equivalence (= phi_1 phi_2))) (@cl psy))
    )
   )
)

; rule: equiv_simplify
; requires: >
;   For the conclusion to be of the form 𝜑1 → 𝜑2 ≈ 𝜓, where 𝜓
;   results from the application of equivalence
;   preserving transformations, as specified in "rewrite_equivalence".
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition
(declare-rule equiv_simplify ((conclusion Bool))
  :requires ((($check_equiv_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_bool_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_bool_simplify conclusion) true)
  )
)

;TRUST
(declare-rule bool_simplify ((conclusion Bool))
  :requires ((($check_bool_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_ac_simp ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_ac_simp l r) true)
  )
)

;TRUST
(declare-rule ac_simp ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_ac_simp l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_ite_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_ite_simplify l r) true)
  )
)

;TRUST
(declare-rule ite_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_ite_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_qnt_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_qnt_simplify l r) true)
  )
)

;TRUST
(declare-rule qnt_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_qnt_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_onepoint ((conclusion Bool))
  (Bool) Bool
  (
   (($check_onepoint conclusion) true)
  )
)
; (program $check_onepoint ((ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T))
;   (Bool T T T T) Bool
;   (
;    (($check_onepoint ctx l r l1 r1) true)
;   )
; )

;TRUST
(declare-rule onepoint ((ctx Bool) (old_ctx Bool) (T Type) (l T) (r T) (l1 T) (r1 T)
                        (conclusion Bool))
  :assumption ctx
  ; :premises (old_ctx (@cl (= l1 r1)))
  ; :args ((@cl (= l r)))
  ; :requires ((($context_is_extended ctx old_ctx) true) (($check_onepoint ctx l r l1 r1) true))
  :requires ((($check_onepoint conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_qnt_join ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_join conclusion) true)
  )
)

;TRUST
(declare-rule qnt_join ((conclusion Bool))
  :requires ((($check_qnt_join conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_qnt_rm_unused ((conclusion Bool))
  (Bool) Bool
  (
   (($check_qnt_rm_unused conclusion) true)
  )
)

;TRUST
(declare-rule qnt_rm_unused ((conclusion Bool))
  :requires ((($check_qnt_rm_unused conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_eq_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_eq_simplify conclusion) true)
  )
)

;TRUST
(declare-rule eq_simplify ((conclusion Bool))
  :requires ((($check_eq_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_div_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_div_simplify l r) true)
  )
)

;TRUST
(declare-rule div_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_div_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_prod_simplify ((conclusion Bool))
  (Bool) Bool
  (
   (($check_prod_simplify conclusion) true)
  )
)

;TRUST
(declare-rule prod_simplify ((conclusion Bool))
  :requires ((($check_prod_simplify conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_unary_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_unary_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule unary_minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_unary_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_sum_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_sum_simplify l r) true)
  )
)

;TRUST
(declare-rule sum_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_sum_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program $check_comp_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   (($check_comp_simplify l r) true)
  )
)

;TRUST
(declare-rule comp_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires ((($check_comp_simplify l r) true))
  :conclusion (@cl (= l r))
)

;-------------
; Rule 91: let
;-------------

(program $verify_let_premises ((context Bool) (premises Bool) 
                              (A Type) (var A)
                              (B Type) (value B)
                              (tl @VarList :list))
  (Bool Bool @VarList) Bool
  (
   (
    ($verify_let_premises context premises 
                         ($f_list_cons @varlist 
                                      ($f_list_cons @varlist var value) 
                                      tl))

    (eo::or ($f_list_contains_elem 
             and 
             (@cl (= value ($context_get_substitute context var)))
             premises)
            ($verify_let_premises context premises tl)
            )
    )

   (
    ($verify_let_premises context premises @varlist.nil)
    
    true
    )
   )
)

; program: check_let_elim
; args:
; - context Bool: Context of the subproof being closed.
; - premises Bool: And-list containing premises passed to rule let_elim.
; - conclusion Bool: Conclusion given to rule let_elim.
; return: >
;    A boolean indicating if the given conclusion has the form
;    (let 𝑥1 = 𝑡1, … , 𝑥𝑛= 𝑡𝑛 in 𝑢) ≈ 𝑢′
;    And the premises are of the form:
;    𝑖1. Γ ⊳ 𝑡1 ≈ 𝑠1 (… )
;     ...
;   𝑖𝑛. Γ ⊳ 𝑡𝑛 ≈ 𝑠𝑛 (… )
;   𝑗. Γ, 𝑥1 ↦𝑠1, … , 𝑥𝑛 ↦ 𝑠𝑛 ⊳ 𝑢 ≈ 𝑢′ (… )
;   Note that the context given must correspond to the one of the immediate
;   premise j, that is, Γ, 𝑥1 ↦𝑠1, … , 𝑥𝑛 ↦ 𝑠𝑛.
(program $check_let_elim ((context Bool) (premises Bool) 
                         (let_type Type) (let_def let_type)
                         (var_defs @VarList) 
                         (A Type) (lhs A) (rhs A)
                         (B Type)
                         (var_values B))
  (Bool Bool Bool) Bool
  (
   (
    ($check_let_elim context premises
                    (@cl (= let_def rhs)))

    (eo::and 
     ; There should be a conclusion of the form (@cl (= lhs rhs))
     ; TODO: this must be the just the conclusion of the previous step
     ($f_list_contains_elem and (@cl (= ($let_get_body let_def) rhs)) premises)
     ($verify_let_premises context premises 
                          ($let_get_vars_substitutes ($let_get_vars let_def)
                                                    ($let_get_values let_def)))
     )
    )
   )
)


; rule: let_elim
; assumption:
; - ctx: Context from the actual subproof.
; premise-list: And-list of the premises passed to the rule.
; requires: >
;    For the given conclusion to be a proper elimination of a let, under the provided
;    premises and context, as specified by predicate $check_let_elim.
; conclusion-explicit: A conclusion satisfying the previous side-condition.
(declare-rule let_elim ((ctx Bool) (premises Bool) (conclusion Bool))
  :assumption ctx
  :premise-list premises and
  :requires ((($check_let_elim ctx premises conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 93: distinct_elim
;-------------

; program: build_distinct_list
; args:
; - list Bool: An and-list of distinct-list elements.
; return:
; Returns the reinterpretation of the given and-list of distinct-list elements,
; as a conjunction of inequalities.
(program $build_distinct_list ((A Type) (lhs A) (rhs A) (tl Bool :list))
  (Bool) Bool
  (
   (
    ($build_distinct_list (and (distinct lhs rhs) tl))

    ($f_list_cons and 
                 (not (= lhs rhs)) 
                 ($build_distinct_list tl))
    )

   ; Only one proposition
   (
    ($build_distinct_list (distinct lhs rhs)) 

    (not (= lhs rhs))
    )

   ; Only one proposition
   (
    ($build_distinct_list (distinct lhs)) 

    true
    )
   
   (
    ($build_distinct_list true) 

    true
    )
  )
)

; TODO: DELETE THIS IF WE FIND A GENERIC WAY TO IMPLEMENT THIS

; program: conjunction_contains_ineq
; args:
; - ineq Bool: >
;   An inequality of the form (not (= lhs rhs)), for some terms lhs and rhs of
;   type A.
; - conjunctions Bool: A conjunctions of inequalities of the form (not (= lhs' rhs'))
; return: >
;   A boolean indicating if ineq appears in "conjunctions", modulo symmetry of the
;   equality within ineq.
(program $conjunction_contains_ineq ((A Type) (lhs A) (rhs A) (hd Bool) (tl Bool :list))
  (Bool Bool) Bool
  (
   (
    ($conjunction_contains_ineq (not (= lhs rhs)) (and (not (= lhs rhs)) tl))

    true
    )

   (
    ($conjunction_contains_ineq (not (= lhs rhs)) (and (not (= rhs lhs)) tl))

    true
    )

   ; { hd =/= not (= rhs lhs))}
   (
    ($conjunction_contains_ineq (not (= lhs rhs)) (and hd tl))

    ($conjunction_contains_ineq (not (= lhs rhs)) tl)
    )

   (
    ($conjunction_contains_ineq (not (= lhs rhs)) (not (= lhs rhs)))

    true
    )

   (
    ($conjunction_contains_ineq (not (= lhs rhs)) (not (= rhs lhs)))

    true
    )

   ; { hd =/= (not (= lhs rhs))}
   (
    ($conjunction_contains_ineq (not (= lhs rhs)) hd)

    false
    )
  )
)

; program: conjunction_contains_conjunction
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return: >
;    A boolean indicating if the elements from list_1 also appear in list_2, 
;    according to comparison predicate $conjunction_contains_ineq.
(program $conjunction_contains_conjunction ((hd Bool) (tl Bool :list)
                                           (f_list_2 Bool))
  (Bool Bool) Bool
  (
   (
    ($conjunction_contains_conjunction (and hd tl) f_list_2)

    ; TODO: I need some way to build boolean values
    ; combining other boolean values, but I would like
    ; to avoid built-in operators.
    (eo::and ($conjunction_contains_ineq hd f_list_2)
             ($conjunction_contains_conjunction tl f_list_2))
    )

   ; { f_list_1 is not an and-list}
   (
    ($conjunction_contains_conjunction true f_list_2)

    true
    )

   ; { hd must be an inequaity }
   (
    ($conjunction_contains_conjunction hd f_list_2)

    ($conjunction_contains_ineq hd f_list_2)
    )
  )
)

; program: conjunctions_equal
; args:
; - list_1 A: An and-list, of inequalities of the form (not (= lhs rhs))
; - list_2 A: An and-list, of inequalities of the form (not (= lhs rhs)).
; return: >
; A boolean indicating if the conjuncts from list_1 and list_2 are the 
; same, regardless of the order.
(program $conjunctions_equal ((list_1 Bool) (list_2 Bool))
  (Bool Bool) Bool
  (
   (
    ($conjunctions_equal list_1 list_2)
    
    (eo::and ($conjunction_contains_conjunction list_1 list_2)
             ($conjunction_contains_conjunction list_2 list_1))
    )
  )
)

; program: check_distinct_elim
; args:
; - conclusion Bool: The conclusion give to the distinct_elim rule.
; return:
; A Boolean indicating if the given "conclusion" has the shape
; (distinct 𝑡1 … 𝑡𝑛) ≈ ⋀ 𝑡𝑖 ≈/≈ 𝑡𝑗.
(program $check_distinct_elim ((A Type) (hd A) (inequalities Bool) (conjunctions Bool))
  (Bool) Bool
  (; TODO: assuming that inequalities come first
   (
    ($check_distinct_elim (@cl (= inequalities conjunctions)))
    
    ($conjunctions_equal ($build_distinct_list inequalities) conjunctions)
    )

   ; Only one proposition
   (
    ($check_distinct_elim (@cl (= (distinct hd) true))) 
    
    true
    )
  )
)

; rule: distinct_elim
; requires: >
;   Requires for "conclusion" to be of the shape
;   (distinct 𝑡1 … 𝑡𝑛) ≈ ⋀ 𝑡𝑖 ≈/≈ 𝑡𝑗.
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule distinct_elim ((conclusion Bool))
  :requires ((($check_distinct_elim conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Rule 94: la_rw_eq
;-------------

; TODO: other number types. Can the equality be flipped?
; rule: la_rw_eq
; conclusion-explicit: >
;   Conclusion shoud be a clause of the form 
;   (= (= t u) (and (<= t u) (<= u t))), for some numbers t and u.
(declare-rule la_rw_eq ((t Int) (u Int))
  :conclusion-explicit (@cl (= (= t u) (and (<= t u) (<= u t))))
)

;-------------
; Rule 95: nary_elim
;-------------

; program: check_nary_elim
; args:
; - conclusion Bool: >
;   Conclusion given to rule nary_elim. It must be built with @cl.
; return:
;   - A boolean indicating if conclusion has one of the following forms:
;     ○ 𝑡𝑖 ≈ (… ((𝑡1 ∘𝑡2) ∘𝑡3) ∘⋯𝑡𝑛) (for a left assoc. operator ∘)
;     ○ 𝑡𝑖 ≈ (𝑡1 ∘⋯∘(𝑡𝑛−2 ∘(𝑡𝑛−1 ∘𝑡𝑛) … ) (for a right assoc. operator ∘)
;     ○ 𝑡𝑖 ≈ (𝑡1 ∘𝑡2) ∧(𝑡2 ∘𝑡3) ∧⋯∧ (𝑡𝑛−1 ∘𝑡𝑛) (for a chainable operator ∘)
;   - ∘ cannot be ∧ or ∨.
(program $check_nary_elim ((A Type) (hd A) (tl A :list))
  (Bool) Bool
  (; TODO: check that op is not /\ nor \/
   (
    ($check_nary_elim (@cl (= (=> hd tl) (=> hd tl))))
    ; right-assoc operator
    ; We leverage the desugaring process, that turns both lists
    ; into the folded application of the operator, already
    ; associated to the right.
    true
    )
  )
)

; rule: nary_elim
; requires: >
;   - The conclusion should have one of the following forms:
;     ○ 𝑡𝑖 ≈ (… ((𝑡1 ∘𝑡2) ∘𝑡3) ∘⋯𝑡𝑛) (for a left assoc. operator ∘)
;     ○ 𝑡𝑖 ≈ (𝑡1 ∘⋯∘(𝑡𝑛−2 ∘(𝑡𝑛−1 ∘𝑡𝑛) … ) (for a right assoc. operator ∘)
;     ○ 𝑡𝑖 ≈ (𝑡1 ∘𝑡2) ∧(𝑡2 ∘𝑡3) ∧⋯∧ (𝑡𝑛−1 ∘𝑡𝑛) (for a chainable operator ∘)
;   - ∘ cannot be ∧ or ∨.
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule nary_elim ((conclusion Bool))
  :requires ((($check_nary_elim conclusion) true))
  :conclusion-explicit conclusion
)

;TODO
(program $check_bfun_elim ((psi Bool) (phi Bool))
  (Bool Bool) Bool
  (
   (($check_bfun_elim (@cl psi) phi) true)
  )
)

;TRUST
(declare-rule bfun_elim ((psi Bool) (phi Bool))
  :premises (psi)
  :args ((@cl phi))
  :requires ((($check_bfun_elim ($to_cl psi) phi) true))
  :conclusion (@cl phi)
)

;TODO
(program $check_ite_intro ((conclusion Bool))
  (Bool) Bool
  (
   (($check_ite_intro conclusion) true)
  )
)

;TRUST
(declare-rule ite_intro ((conclusion Bool))
  :requires ((($check_ite_intro conclusion) true))
  :conclusion-explicit conclusion
)

;-------------
; Table 10: Rules used by cvc5, but not by veriT
;-------------

;-------------
; Rule 101: symm
;-------------

; rule: symm
; premises: >
;   An equality of the form (@cl (= phi psy)), for arbitrary formulas phi and psy.
; conclusion-explicit: >
;   The conclusion should have the form (@cl (= psy phi)).
(declare-rule symm ((phi Bool) (psy Bool))
  :premises ((@cl (= phi psy)))
  :conclusion-explicit (@cl (= psy phi))
)

;-------------
; Rule 34: reordering
;-------------

; program: check_reordering
; args:
; - premise Bool: >
;   Premise given to rule reordering. Must be a clause built with @cl.
; - conclusion Bool: >
;   Conclusion given to rule reordering. Must be a clause built with @cl.
; return: >
;   A boolean indicating if conclusion is a permutation of the premise.
(program $check_reordering ((hd_premise Bool) (tl_premise Bool :list)
                           (hd_conclusion Bool) (tl_conclusion Bool :list))
  (Bool Bool) Bool
  (
   (
    ($check_reordering (@cl hd_premise tl_premise) (@cl hd_conclusion tl_conclusion))

    ($check_reordering tl_premise 
                       ($f_list_remove_elem @cl (@cl hd_conclusion tl_conclusion) hd_premise false))
    )

   (
    ($check_reordering false false)

    true
    )

   (
    ($check_reordering hd_premise hd_conclusion)

    false
    )
  )
)

;TRUST
; rule: reordering
; premises:
; - premise Bool: >
;   Premise given to rule reordering. Must be a clause built with @cl.
; requires: >
;   For conclusion to be a permutation of the premise.
; conclusion-explicit: >
;   A conclusion satisfying the previous side-condition.
(declare-rule reordering ((premise Bool) (conclusion Bool))
  :premises (premise)
  :requires ((($check_reordering premise conclusion) 
              true))
  :conclusion-explicit conclusion
)

;-------------
; Rare
;-------------

;TODO
(program $check_rare_rewrite ((Flag Bool) (CL Bool))
  (Bool Bool) Bool
  (
   (($check_rare_rewrite Flag CL) true)
  )
)

;TRUST
(declare-rule rare_rewrite ((flag Bool) (conclusion Bool))
  :args (flag)
  :requires ((($check_rare_rewrite flag conclusion) true))
  :conclusion-explicit conclusion
)
